# Project Analysis created on 12/12/2024 15:47:06


## Project Structure
==========================================
|-- bin
|   +-- Debug
|       +-- net8.0
|           |-- Bdziam.UI.deps.json
|           |-- Bdziam.UI.dll
|           |-- Bdziam.UI.pdb
|           |-- Bdziam.UI.staticwebassets.endpoints.json
|           +-- Bdziam.UI.staticwebassets.runtime.json
|-- Components
|   |-- Additional
|   |   |-- BThemeManager.razor
|   |   +-- BThemeManager.razor.cs
|   |-- Buttons
|   |   |-- BButton.razor
|   |   |-- BButton.razor.cs
|   |   |-- BIconButton.razor
|   |   |-- BIconButton.razor.cs
|   |   |-- BIconButtonBase.cs
|   |   |-- BToggleButton.razor
|   |   |-- BToggleButton.razor.cs
|   |   |-- BToggleIconButton.razor
|   |   +-- BToggleIconButton.razor.cs
|   |-- CommonBase
|   |   |-- BButtonBase.cs
|   |   |-- BComponentBase.cs
|   |   |-- BInput.cs
|   |   |-- IControlChildContent.cs
|   |   |-- IControlColor.cs
|   |   |-- IControlIcon.cs
|   |   |-- IControlIcons.cs
|   |   |-- IControlIconSize.cs
|   |   +-- IControlSize.cs
|   |-- Effects
|   |   |-- BPillRipple.razor
|   |   |-- BPillRipple.razor.cs
|   |   |-- BRipple.razor
|   |   +-- BRipple.razor.cs
|   |-- Foldout
|   |   |-- BFoldout.razor
|   |   +-- BFoldout.razor.cs
|   |-- Icon
|   |   |-- BIcon.razor
|   |   +-- BIcon.razor.cs
|   |-- Inputs
|   |   |-- Field
|   |   |   |-- BInputField.cs
|   |   |   |-- BInputView.razor
|   |   |   |-- BInputView.razor.cs
|   |   |   |-- BSelect.razor
|   |   |   |-- BSelect.razor.cs
|   |   |   |-- BTextField.razor
|   |   |   |-- BTextField.razor.cs
|   |   |   |-- InputFieldIcon.razor
|   |   |   +-- InputFieldIcon.razor.cs
|   |   |-- BSwitch.razor
|   |   +-- BSwitch.razor.cs
|   |-- Layout
|   |   |-- BBody.razor
|   |   |-- BBody.razor.cs
|   |   |-- BCanonicalLayout.razor
|   |   |-- BCanonicalLayout.razor.cs
|   |   |-- BContainer.razor
|   |   |-- BContainer.razor.cs
|   |   |-- BMasonryGrid.razor
|   |   |-- BMasonryGrid.razor.cs
|   |   |-- BSpacer.razor
|   |   |-- BSpacer.razor.cs
|   |   |-- BStack.razor
|   |   |-- BStack.razor.cs
|   |   |-- BUniformGrid.razor
|   |   +-- BUniformGrid.razor.cs
|   |-- Navigation
|   |   |-- Drawer
|   |   |   |-- BDrawer.razor
|   |   |   |-- BDrawer.razor.cs
|   |   |   |-- BDrawerHeader.razor
|   |   |   |-- BDrawerHeader.razor.cs
|   |   |   |-- BDrawerMenu.razor
|   |   |   |-- BDrawerMenu.razor.cs
|   |   |   |-- BDrawerMenuBase.cs
|   |   |   |-- BDrawerMenuComposer.razor
|   |   |   |-- BDrawerMenuComposer.razor.cs
|   |   |   |-- BDrawerMenuItem.razor
|   |   |   |-- BDrawerMenuItem.razor.cs
|   |   |   |-- BDrawerMenuItemBase.cs
|   |   |   |-- BDrawerMenuItemModel.cs
|   |   |   |-- BDrawerSeparator.razor
|   |   |   |-- BDrawerSeparator.razor.cs
|   |   |   |-- NavigationItemAttribute.cs
|   |   |   +-- NavigationService.cs
|   |   |-- Tabs
|   |   |   |-- BTab.razor
|   |   |   |-- BTab.razor.cs
|   |   |   |-- BTabs.razor
|   |   |   |-- BTabs.razor.cs
|   |   |   +-- TabsService.cs
|   |   |-- BMenu.razor
|   |   |-- BMenu.razor.cs
|   |   |-- BTopBar.razor
|   |   +-- BTopBar.razor.cs
|   |-- Popover
|   |   |-- BPopover.razor
|   |   |-- BPopover.razor.cs
|   |   |-- BPopover.razor.css
|   |   +-- PopoverService.cs
|   |-- Progress
|   |   |-- BProgress.razor
|   |   +-- BProgress.razor.cs
|   |-- Tooltip
|   |   |-- BTooltip.razor
|   |   +-- BTooltip.razor.cs
|   +-- Typography
|       |-- BMarkdown.razor
|       |-- BMarkdown.razor.cs
|       |-- BText.razor
|       +-- BText.razor.cs
|-- Enums
|   |-- BorderRadius.cs
|   |-- ButtonVariant.cs
|   |-- DrawerMode.cs
|   |-- DrawerPosition.cs
|   |-- FieldVariant.cs
|   |-- IControlElevation.cs
|   |-- InputType.cs
|   |-- MaterialColor.cs
|   |-- Motion.cs
|   |-- Orientation.cs
|   |-- Position.cs
|   |-- ProgressIndicatorVariant.cs
|   |-- RippleVariant.cs
|   |-- SpacingSize.cs
|   |-- TabVariant.cs
|   +-- Typo.cs
|-- Extensions
|   |-- BdziamExtensions.cs
|   +-- SvgIconExtensions.cs
|-- Interop
|   |-- BackgroundColorService.cs
|   |-- DOMRect.cs
|   |-- ElementPosition.cs
|   |-- ElementSize.cs
|   |-- ElementSizeService.cs
|   +-- InteropService.cs
|-- obj
|   |-- Debug
|   |   +-- net8.0
|   |       |-- ref
|   |       |   +-- Bdziam.UI.dll
|   |       |-- refint
|   |       |   +-- Bdziam.UI.dll
|   |       |-- scopedcss
|   |       |   |-- bundle
|   |       |   |   +-- Bdziam.UI.styles.css
|   |       |   |-- Components
|   |       |   |   +-- Popover
|   |       |   |       +-- BPopover.razor.rz.scp.css
|   |       |   +-- projectbundle
|   |       |       +-- Bdziam.UI.bundle.scp.css
|   |       |-- staticwebassets
|   |       |   |-- msbuild.Bdziam.UI.Microsoft.AspNetCore.StaticWebAssetEndpoints.props
|   |       |   |-- msbuild.Bdziam.UI.Microsoft.AspNetCore.StaticWebAssets.props
|   |       |   |-- msbuild.build.Bdziam.UI.props
|   |       |   |-- msbuild.buildMultiTargeting.Bdziam.UI.props
|   |       |   +-- msbuild.buildTransitive.Bdziam.UI.props
|   |       |-- .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
|   |       |-- Bdziam.UI.AssemblyInfo.cs
|   |       |-- Bdziam.UI.AssemblyInfoInputs.cache
|   |       |-- Bdziam.UI.assets.cache
|   |       |-- Bdziam.UI.csproj.AssemblyReference.cache
|   |       |-- Bdziam.UI.csproj.CoreCompileInputs.cache
|   |       |-- Bdziam.UI.csproj.FileListAbsolute.txt
|   |       |-- Bdziam.UI.dll
|   |       |-- Bdziam.UI.GeneratedMSBuildEditorConfig.editorconfig
|   |       |-- Bdziam.UI.GlobalUsings.g.cs
|   |       |-- Bdziam.UI.pdb
|   |       |-- Bdziam.UI.sourcelink.json
|   |       |-- staticwebassets.build.endpoints.json
|   |       |-- staticwebassets.build.json
|   |       |-- staticwebassets.development.json
|   |       +-- staticwebassets.pack.json
|   |-- Bdziam.UI.csproj.nuget.dgspec.json
|   |-- Bdziam.UI.csproj.nuget.g.props
|   |-- Bdziam.UI.csproj.nuget.g.targets
|   |-- project.assets.json
|   |-- project.nuget.cache
|   |-- project.packagespec.json
|   |-- rider.project.model.nuget.info
|   +-- rider.project.restore.info
|-- Style
|   +-- bdziam.css
|-- Theming
|   |-- MaterialColors
|   |   |-- Blend
|   |   |   +-- Blend.cs
|   |   |-- ColorSpace
|   |   |   |-- Cam16.cs
|   |   |   |-- Hct.cs
|   |   |   |-- HctSolver.cs
|   |   |   +-- ViewingConditions.cs
|   |   |-- Dislike
|   |   |   +-- DislikeAnalyzer.cs
|   |   |-- DynamicColor
|   |   |   |-- ContrastCurve.cs
|   |   |   |-- DynamicColor.cs
|   |   |   |-- DynamicScheme.cs
|   |   |   |-- DynamicSchemeVariant.cs
|   |   |   |-- MaterialDynamicColors.cs
|   |   |   |-- ToneDeltaPair.cs
|   |   |   +-- TonePolarity.cs
|   |   |-- Palettes
|   |   |   |-- KeyColor.cs
|   |   |   +-- TonalPalette.cs
|   |   |-- Scheme
|   |   |   |-- ContentScheme.cs
|   |   |   |-- DynamicSchemeMap.cs
|   |   |   |-- ExpressiveScheme.cs
|   |   |   |-- FidelityScheme.cs
|   |   |   |-- FruitSaladTheme.cs
|   |   |   |-- MonochromeScheme.cs
|   |   |   |-- NeutralScheme.cs
|   |   |   |-- RainbowScheme.cs
|   |   |   |-- TonalSpotScheme.cs
|   |   |   +-- VibrantScheme.cs
|   |   |-- Score
|   |   |   +-- Score.cs
|   |   |-- Temperature
|   |   |   +-- TemperatureCache.cs
|   |   |-- Utils
|   |   |   |-- ColorUtils.cs
|   |   |   |-- MathUtils.cs
|   |   |   +-- StringUtils.cs
|   |   |-- Contrast.cs
|   |   +-- Readme.md
|   |-- Model
|   |   |-- BColorScheme.cs
|   |   +-- ThemeSettings.cs
|   |-- BThemeProvider.razor
|   |-- BThemeProvider.razor.cs
|   |-- ThemeService.cs
|   +-- ThemingConstants.cs
|-- Utilities
|   |-- CaseUtility.cs
|   |-- ColorUtility.cs
|   |-- CssClassBuilder.cs
|   |-- CssStyleBuilder.cs
|   |-- MotionUtility.cs
|   |-- SizeUtility.cs
|   +-- StyleUtility.cs
|-- wwwroot
|   |-- css
|   |   +-- bdziam.css
|   |-- font
|   |   +-- LibreFranklin.ttf
|   |-- js
|   |   |-- background-color.js
|   |   |-- bdziamui.js
|   |   |-- element-size.js
|   |   |-- popover.js
|   |   |-- ripple.js
|   |   +-- tabs.js
|   +-- background.png
|-- _Imports.razor
|-- Bdziam.UI.csproj
|-- bdziam_ui_codebase.txt
|-- CreateCodeBase.ps1
|-- merge-code.ps1
|-- RunTailwind.ps1
+-- tailwind.config.js


## File Statistics
==========================================
Total Files: 162

File Types:
- .cs: 124 files
- .razor: 38 files

## Source Code
==========================================


==========================================
FILE: Components\Additional\BThemeManager.razor
==========================================
Last Modified: 12/05/2024 13:22:39
Size: 2489 bytes
------------------------------------------

@using Bdziam.UI.Model.Enums
@using Bdziam.UI.Theming.MaterialColors.DynamicColor
@using Color = Bdziam.UI.Model.Enums.MaterialColor
@namespace Bdziam.UI
@using Size = Bdziam.UI.Model.Enums.Size

<BToggleIconButton Id="ThemeManagerButton" IconSize="Size.Small" Variant="ButtonVariant.Text" Color="MaterialColor.SurfaceContainer" CheckedIcon="GoogleMaterialFilledIcon.Palette" UncheckedIcon="GoogleMaterialOutlinedIcon.Palette" @bind-Checked="IsThemeManagerOpen"></BToggleIconButton>
<BPopover TargetElementId="ThemeManagerButton" Position="Position.Bottom" @bind-IsOpen="IsThemeManagerOpen">
    <BText Typo="Typo.LabelLarge" Color="Color.Surface">Seed Color</BText>
    <BStack Orientation="Orientation.Horizontal" Spacing="Size.Small">
        <BButton Variant="ButtonVariant.Text" Style="background-color: orangered; width: 25px; height: 25px;" BorderRadius="BorderRadius.Pill" OnClick="() => SeedColorChanged?.Invoke(System.Drawing.Color.OrangeRed)"></BButton>
        <BButton Variant="ButtonVariant.Text" Style="background-color: red; width: 25px; height: 25px;" BorderRadius="BorderRadius.Pill" OnClick="() => SeedColorChanged?.Invoke(System.Drawing.Color.Red)"></BButton>
        <BButton Variant="ButtonVariant.Text" Style="background-color: lime; width: 25px; height: 25px;" BorderRadius="BorderRadius.Pill" OnClick="() => SeedColorChanged?.Invoke(System.Drawing.Color.Lime)"></BButton>
        <BButton Variant="ButtonVariant.Text" Style="background-color: magenta; width: 25px; height: 25px;" BorderRadius="BorderRadius.Pill" OnClick="() => SeedColorChanged?.Invoke(System.Drawing.Color.Magenta)"></BButton>
        <BButton Variant="ButtonVariant.Text" Style="background-color: blue; width: 25px; height: 25px;" BorderRadius="BorderRadius.Pill" OnClick="() => SeedColorChanged?.Invoke(System.Drawing.Color.Blue)"></BButton>
        <BButton Variant="ButtonVariant.Text" Style="background-color: deepskyblue; width: 25px; height: 25px;" BorderRadius="BorderRadius.Pill" OnClick="() => SeedColorChanged?.Invoke(System.Drawing.Color.DeepSkyBlue)"></BButton>
    </BStack>
    <BText Typo="Typo.LabelLarge">Style</BText>
    <BStack Orientation="Orientation.Vertical" Spacing="Size.Small">
        @foreach (var colorVariant in Enum.GetValues<DynamicSchemeVariant>())
        {
            <BButton Variant="ButtonVariant.Gradient" OnClick="() => StyleChanged?.Invoke(colorVariant)">@colorVariant.ToString()</BButton>
        }
    </BStack>
</BPopover>


==========================================
FILE: Components\Additional\BThemeManager.razor.cs
==========================================
Last Modified: 12/05/2024 13:23:10
Size: 401 bytes
------------------------------------------

using System.Drawing;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BThemeManager : ComponentBase
{
    public bool IsThemeManagerOpen { get; set; }
    [Parameter] public Action<Color> SeedColorChanged { get; set; }
    [Parameter] public Action<DynamicSchemeVariant> StyleChanged { get; set; }
}


==========================================
FILE: Components\Buttons\BButton.razor
==========================================
Last Modified: 12/05/2024 13:22:57
Size: 508 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Utilities
@inherits BButtonBase
<button id="@Id" class="@ButtonClasses" style="@ButtonStyles" @onclick="HandleClick" disabled="@Disabled">
    <BRipple @ref="Ripple"/>
    @if (StartIcon != null)
    {
        <BIcon Icon="StartIcon" Size="IconSize" Color="ColorUtility.GetTextColor(Color)"/>
    }
    @ChildContent
    @if (EndIcon != null)
    {
        <BIcon Icon="EndIcon" Size="IconSize" Color="ColorUtility.GetTextColor(Color)"/>
    }
</button>


==========================================
FILE: Components\Buttons\BButton.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:38
Size: 491 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BButton : BButtonBase, IControlChildContent, IControlIcons, IControlIconSize
{
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public SvgIcon? StartIcon { get; set; }
    [Parameter] public SvgIcon? EndIcon { get; set; }
    [Parameter] public Size IconSize { get; set; }
}


==========================================
FILE: Components\Buttons\BIconButton.razor
==========================================
Last Modified: 12/05/2024 13:22:37
Size: 311 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Utilities
@inherits BIconButtonBase
<button id="@Id" class="@ButtonClasses" style="@ButtonStyles" @onclick="HandleClick" disabled="@Disabled">
    <BRipple @ref="Ripple"/>
    <BIcon Icon="@Icon" Size="IconSize" Color="ColorUtility.GetTextColor(Color)"/>
</button>


==========================================
FILE: Components\Buttons\BIconButton.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:47
Size: 173 bytes
------------------------------------------

namespace Bdziam.UI;

public partial class BIconButton : BIconButtonBase
{
    protected override void OnInitialized()
    {
        base.OnInitialized();
    }
}


==========================================
FILE: Components\Buttons\BIconButtonBase.cs
==========================================
Last Modified: 12/05/2024 13:22:33
Size: 1352 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Model.Utility;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public class BIconButtonBase : BButtonBase, IControlIcon, IControlIconSize
{
    internal Dictionary<string, object> IconAttributes => new()
    {
        ["style"] = new CssStyleBuilder()
            .AddStyle("width", SizeUtility.GetIconSize(IconSize))
            .AddStyle("height", SizeUtility.GetIconSize(IconSize))
            .Build(),
        ["width"] = SizeUtility.GetIconSize(IconSize),
        ["height"] = SizeUtility.GetIconSize(IconSize)
    };

    [Parameter] public SvgIcon? Icon { get; set; }
    [Parameter] public Size IconSize { get; set; } = Size.Medium;

    protected override string GetVariantStyles()
    {
        var colorVariantName = Color.ToString().ToLower();

        var styleBuilder = new CssStyleBuilder()
            .AddStyle("padding", "0.5rem")
            .AddStyle("border-radius", "100%")
            .AddStyle("background", "transparent")
            .AddStyle("color", ColorUtility.GetTextColorVariable(Color))
            .AddStyle("display", "flex")
            .AddStyle("flex-direction", "row")
            .Build();

        return styleBuilder;
    }
}


==========================================
FILE: Components\Buttons\BToggleButton.razor
==========================================
Last Modified: 12/05/2024 13:23:09
Size: 508 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Utilities
@inherits BButtonBase
<button id="@Id" class="@ButtonClasses" style="@ButtonStyles" @onclick="ToggleState" disabled="@Disabled">
    <BRipple @ref="Ripple"/>
    @if (StartIcon != null)
    {
        <BIcon Icon="StartIcon" Size="IconSize" Color="ColorUtility.GetTextColor(Color)"/>
    }
    @ChildContent
    @if (EndIcon != null)
    {
        <BIcon Icon="EndIcon" Size="IconSize" Color="ColorUtility.GetTextColor(Color)"/>
    }
</button>


==========================================
FILE: Components\Buttons\BToggleButton.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:40
Size: 908 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public partial class BToggleButton : BButtonBase, IControlChildContent, IControlIcons, IControlIconSize
{
    [Parameter] public bool Checked { get; set; }
    [Parameter] public EventCallback<bool> CheckedChanged { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public SvgIcon? StartIcon { get; set; }
    [Parameter] public SvgIcon? EndIcon { get; set; }
    [Parameter] public Size IconSize { get; set; }

    private async Task ToggleState(MouseEventArgs e)
    {
        if (!Disabled)
        {
            Ripple?.CreateRipple(e);
            Checked = !Checked;
            await CheckedChanged.InvokeAsync(Checked);
        }
    }
}


==========================================
FILE: Components\Buttons\BToggleIconButton.razor
==========================================
Last Modified: 12/05/2024 13:22:40
Size: 313 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Utilities
@inherits BIconButtonBase

<button id="@Id" class="@ButtonClasses" style="@ButtonStyles" @onclick="ToggleState" disabled="@Disabled">
    <BRipple @ref="Ripple"/>
    <BIcon Icon="@Icon" Size="IconSize" Color="ColorUtility.GetTextColor(Color)"/>
</button>


==========================================
FILE: Components\Buttons\BToggleIconButton.razor.cs
==========================================
Last Modified: 12/05/2024 13:23:09
Size: 923 bytes
------------------------------------------

using Bdziam.UI.Model.Enums;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public partial class BToggleIconButton : BIconButtonBase
{
    [Parameter] public SvgIcon? CheckedIcon { get; set; }
    [Parameter] public SvgIcon? UncheckedIcon { get; set; }
    [Parameter] public bool Checked { get; set; } = false;
    [Parameter] public EventCallback<bool> CheckedChanged { get; set; }

    public SvgIcon Icon => Checked ? CheckedIcon : UncheckedIcon;

    protected override void OnInitialized()
    {
        BorderRadius = BorderRadius.Pill;
        base.OnInitialized();
    }

    private async Task ToggleState(MouseEventArgs e)
    {
        if (!Disabled)
        {
            Ripple?.CreateRipple(e);
            Checked = !Checked;
            await CheckedChanged.InvokeAsync(Checked);
        }
    }
}


==========================================
FILE: Components\CommonBase\BButtonBase.cs
==========================================
Last Modified: 12/09/2024 17:02:03
Size: 5016 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public abstract class BButtonBase : BComponentBase
{
    [Parameter] public EventCallback OnClick { get; set; }
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public MaterialColor Color { get; set; } = MaterialColor.Primary;
    [Parameter] public ButtonVariant Variant { get; set; } = ButtonVariant.Normal;
    [Parameter] public BorderRadius BorderRadius { get; set; } = BorderRadius.Pill;
    [Parameter] public Size HorizontalPadding { get; set; } = Size.Medium;
    [Parameter] public Size VerticalPadding { get; set; } = Size.Small;
    public BRipple? Ripple { get; set; } = null;

    protected virtual string ButtonClasses => new CssClassBuilder()
        .AddClass("bd-button")
        .AddClass("font-semibold")
        .AddClass(StyleUtility.GetRadiusClass(BorderRadius))
        .AddClass("transition-all transform flex items-center justify-center gap-1")
        .AddClass("opacity-50 cursor-not-allowed", Disabled)
        .AddClass("hover:brightness-90 hover:scale-102 active:scale-95", !Disabled)
        .AddClass(Class)
        .Build();

    protected virtual string ButtonStyles => GetVariantStyles();

    protected virtual async Task HandleClick(MouseEventArgs e)
    {
        if (!Disabled)
        {
            Ripple?.CreateRipple(e);
            await OnClick.InvokeAsync(e);
        }
    }


    protected virtual string GetVariantStyles()
    {
        var colorVariantName = Color.ToString().ToLower();

        var styleBuilder = new CssStyleBuilder()
            .AddStyle("padding",
                Variant == ButtonVariant.Outline
                    ? $"calc({StyleUtility.GetVerticalPadding(VerticalPadding)} - 2px) {StyleUtility.GetHorizontalPadding(HorizontalPadding)}"
                    : $"{StyleUtility.GetVerticalPadding(VerticalPadding)} {StyleUtility.GetHorizontalPadding(HorizontalPadding)}")
            .AddStyle("display", "flex")
            .AddStyle("flex-direction", "row");


        switch (Variant)
        {
            case ButtonVariant.Normal:
                styleBuilder
                    .AddStyle("background-color", ColorUtility.GetColorVariable(Color))
                    .AddStyle("color", ColorUtility.GetTextColorVariable(Color));
                break;
            case ButtonVariant.Outline:
                styleBuilder
                    .AddStyle("background-color", "transparent")
                    .AddStyle("border", $"2px solid {ColorUtility.GetColorVariable(Color)}")
                    .AddStyle("color", ColorUtility.GetColorVariable(Color));
                break;
            case ButtonVariant.Gradient:
                styleBuilder
                    .AddStyle("background",
                        $"linear-gradient(to right,  {ColorUtility.GetColorVariable(Color)}, {GetAlternateColorForGradient()})")
                    .AddStyle("color", ColorUtility.GetTextColorVariable(Color));
                break;
            case ButtonVariant.Text:
                styleBuilder
                    .AddStyle("background", "transparent")
                    .AddStyle("color", $"{ColorUtility.GetColorVariable(Color)}");
                break;
            default:
                styleBuilder
                    .AddStyle("background-color", ColorUtility.GetColorVariable(Color))
                    .AddStyle("color", $"{ColorUtility.GetTextColorVariable(Color)}");
                break;
        }

        return styleBuilder.Build(Style);
    }

    private string GetAlternateColorForGradient()
    {
        return Color switch
        {
            MaterialColor.Primary => ColorUtility.GetColorVariable(MaterialColor.Secondary),
            MaterialColor.Secondary => ColorUtility.GetColorVariable(MaterialColor.Primary),
            MaterialColor.Tertiary => ColorUtility.GetColorVariable(MaterialColor.Secondary),
            MaterialColor.Surface => ColorUtility.GetColorVariable(MaterialColor.SurfaceContainer),
            MaterialColor.SurfaceContainer => ColorUtility.GetColorVariable(MaterialColor.Surface),
            MaterialColor.Info => ColorUtility.GetColorVariable(MaterialColor.InfoContainer),
            MaterialColor.InfoContainer => ColorUtility.GetColorVariable(MaterialColor.Info),
            MaterialColor.Warning => ColorUtility.GetColorVariable(MaterialColor.WarningContainer),
            MaterialColor.WarningContainer => ColorUtility.GetColorVariable(MaterialColor.Warning),
            MaterialColor.Error => ColorUtility.GetColorVariable(MaterialColor.ErrorContainer),
            MaterialColor.ErrorContainer => ColorUtility.GetColorVariable(MaterialColor.Error),
            _ => ColorUtility.GetColorVariable(MaterialColor.Primary)
        };
    }
}


==========================================
FILE: Components\CommonBase\BComponentBase.cs
==========================================
Last Modified: 12/05/2024 13:23:12
Size: 803 bytes
------------------------------------------

using Bdziam.UI.Interop;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI.Components.CommonBase;

public abstract class BComponentBase : ComponentBase
{
    [Parameter] public string Class { get; set; } = string.Empty;
    [Parameter] public string Style { get; set; } = string.Empty;
    [Parameter] public string Id { get; set; } = Guid.NewGuid().ToString();

    [Inject] public ElementSizeService SizeService { get; set; }

    /// <summary>
    ///     Retrieves the width and height of the component using its unique ID.
    /// </summary>
    /// <returns>A tuple containing the width and height of the component, or null if unavailable.</returns>
    public Task<DOMRect?> GetElementSizeAsync()
    {
        return SizeService.GetElementSizeAsync(Id);
    }
}


==========================================
FILE: Components\CommonBase\BInput.cs
==========================================
Last Modified: 12/05/2024 21:25:47
Size: 2845 bytes
------------------------------------------

using System.ComponentModel.DataAnnotations;
using System.Linq.Expressions;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;

namespace Bdziam.UI.Components.CommonBase;

public abstract class BInput<T> : BComponentBase
{
    private T? _value;
    private FieldIdentifier _fieldIdentifier;

    [Parameter]
    public T? Value
    {
        get => _value;
        set
        {
            if (!EqualityComparer<T>.Default.Equals(value, _value))
            {
                _value = value;
                FieldChanged(_value);
                StateHasChanged();
            }
        }
    }

    [Parameter] public EventCallback<T?> ValueChanged { get; set; }
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public bool ReadOnly { get; set; }
    [Parameter] public bool Required { get; set; }
    [Parameter] public string RequiredError { get; set; } = "Required";
    [Parameter] public Expression<Func<T?>>? For { get; set; }
    [Parameter] public object? Validation { get; set; }

    [CascadingParameter] private EditContext? EditContext { get; set; }

    public string? ErrorText => string.Join("\n", ValidationErrors);
    public bool Touched { get; private set; }
    protected List<string> ValidationErrors { get; } = new();
    protected bool Error => ValidationErrors.Count > 0;
    protected abstract bool IsEmpty();

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (For != null) _fieldIdentifier = FieldIdentifier.Create(For);
    }

    public void Validate()
    {
        ValidationErrors.Clear();

        if (Required && IsEmpty())
            ValidationErrors.Add(RequiredError);

        if (Validation is ValidationAttribute validationAttribute)
        {
            var validationContext = new ValidationContext(EditContext?.Model ?? this)
            {
                MemberName = _fieldIdentifier.FieldName
            };
            var result = validationAttribute.GetValidationResult(Value, validationContext);
            if (result != ValidationResult.Success && result?.ErrorMessage != null)
                ValidationErrors.Add(result.ErrorMessage);
        }
    }

    public void Reset()
    {
        Value = default;
        Touched = false;
        ValidationErrors.Clear();
        StateHasChanged();
    }

    public void MarkAsTouched()
    {
        Touched = true;
    }

    public void MarkAsUntouched()
    {
        Touched = false;
    }

    protected void FieldChanged(T? newValue)
    {
        ValueChanged.InvokeAsync(newValue);
        Validate();
    }

    private void OnValidationStateChanged(object? sender, ValidationStateChangedEventArgs e)
    {
        Validate();
    }
}



==========================================
FILE: Components\CommonBase\IControlChildContent.cs
==========================================
Last Modified: 11/25/2024 18:48:22
Size: 201 bytes
------------------------------------------

using Microsoft.AspNetCore.Components;

namespace Bdziam.UI.Components.CommonBase;

public interface IControlChildContent
{
    [Parameter] public RenderFragment? ChildContent { get; set; }
}


==========================================
FILE: Components\CommonBase\IControlColor.cs
==========================================
Last Modified: 12/05/2024 13:22:43
Size: 215 bytes
------------------------------------------

using Bdziam.UI.Model.Enums;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI.Components.CommonBase;

public interface IControlColor
{
    [Parameter] public MaterialColor Color { get; set; }
}


==========================================
FILE: Components\CommonBase\IControlIcon.cs
==========================================
Last Modified: 11/25/2024 18:53:18
Size: 196 bytes
------------------------------------------

using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI.Components.CommonBase;

public interface IControlIcon
{
    [Parameter] public SvgIcon? Icon { get; set; }
}


==========================================
FILE: Components\CommonBase\IControlIcons.cs
==========================================
Last Modified: 11/25/2024 18:43:32
Size: 257 bytes
------------------------------------------

using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI.Components.CommonBase;

public interface IControlIcons
{
    [Parameter] public SvgIcon? StartIcon { get; set; }
    [Parameter] public SvgIcon? EndIcon { get; set; }
}


==========================================
FILE: Components\CommonBase\IControlIconSize.cs
==========================================
Last Modified: 11/27/2024 14:36:13
Size: 212 bytes
------------------------------------------

using Bdziam.UI.Model.Enums;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI.Components.CommonBase;

public interface IControlIconSize
{
    [Parameter] public Size IconSize { get; set; }
}


==========================================
FILE: Components\CommonBase\IControlSize.cs
==========================================
Last Modified: 11/25/2024 18:43:56
Size: 204 bytes
------------------------------------------

using Bdziam.UI.Model.Enums;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI.Components.CommonBase;

public interface IControlSize
{
    [Parameter] public Size Size { get; set; }
}


==========================================
FILE: Components\Effects\BPillRipple.razor
==========================================
Last Modified: 12/05/2024 13:22:47
Size: 392 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@using Bdziam.UI.Utilities
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div id="@Id" class="@PillRippleClasses" style="@PillRippleStyle">

</div>
@if (Hover)
{
    <div class="pill-ripple-hover" style="@($"background-color: {ColorUtility.GetColorVariable(MaterialColor.OnSurfaceVariant)};" + Style)">

    </div>
}


==========================================
FILE: Components\Effects\BPillRipple.razor.cs
==========================================
Last Modified: 12/05/2024 13:23:10
Size: 2347 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BPillRipple : BComponentBase
{
    private bool _isActive = false;

    /// <summary>
    ///     Invoked when the seed color changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> IsActiveChanged { get; set; }

    /// <summary>
    ///     Tracks the current Active state and triggers changes.
    /// </summary>
    [Parameter]
    public bool IsActive
    {
        get => _isActive;
        set
        {
            if (_isActive != value)
            {
                _isActive = value;
                IsActiveChanged.InvokeAsync(_isActive);
                StateHasChanged();
            }
        }
    }

    private string RippleTransition { get; set; } =
        MotionUtility.ConstructTransition(Motion.EasingEmphasizedAccelerate, 0.3, "transform", "opacity");

    [Parameter] public MaterialColor MaterialColor { get; set; } = MaterialColor.Secondary;
    [Parameter] public bool Scale { get; set; } = true;
    [Parameter] public bool Behind { get; set; } = true;
    [Parameter] public bool Hover { get; set; } = true;

    public string PillRippleClasses => new CssClassBuilder()
        .AddClass("pill-ripple")
        .AddClass("active-scalex", IsActive && Scale)
        .AddClass("active", IsActive && !Scale)
        .Build();

    public string PillRippleStyle => new CssStyleBuilder()
        .AddStyle("background-color", ColorUtility.GetColorVariable(MaterialColor), IsActive)
        .AddStyle("z-index", "-3", Behind)
        .AddStyle("transform", "scaleX(100)", !Scale)
        .Build(Style);

    public void Pulsate()
    {
        IsActive = true;
        StateHasChanged();
        // Reset IsActive after animation duration to allow re-triggering
        Task.Delay(450).ContinueWith(_ => InvokeAsync(() => IsActive = false));
    }

    private string GetActivePulsateTransitionStyles()
    {
        return new CssStyleBuilder()
            .AddStyle("animation", "pulsate 0.6s ease-in-out")
            .AddStyle("animation-fill-mode", "forwards") // Ensures the final state is maintained after animation
            .Build();
    }
}


==========================================
FILE: Components\Effects\BRipple.razor
==========================================
Last Modified: 11/29/2024 10:56:26
Size: 154 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div id="@Id" class="ripple-container" @ref="_rippleContainer">
</div>


==========================================
FILE: Components\Effects\BRipple.razor.cs
==========================================
Last Modified: 12/05/2024 13:23:10
Size: 1011 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.JSInterop;

namespace Bdziam.UI;

public partial class BRipple : BComponentBase, IAsyncDisposable
{
    private IJSObjectReference? _jsModule;
    private ElementReference _rippleContainer;

    [Inject] private IJSRuntime JSRuntime { get; set; } = default!;

    public async ValueTask DisposeAsync()
    {
        if (_jsModule != null) await _jsModule.DisposeAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "./_content/Bdziam.UI/js/ripple.js"
            );
    }

    public async Task CreateRipple(MouseEventArgs e)
    {
        if (_jsModule != null) await _jsModule.InvokeVoidAsync("createRipple", _rippleContainer, e.ClientX, e.ClientY);
    }
}


==========================================
FILE: Components\Foldout\BFoldout.razor
==========================================
Last Modified: 12/06/2024 09:22:00
Size: 1207 bytes
------------------------------------------

@using Bdziam.UI.Model.Enums
@using Bdziam.UI.Utilities
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
@namespace Bdziam.UI
<BContainer Padding="Size.None" BorderRadius="BorderRadius.Large">
    <div id="@Id" class="foldout-header flex items-center px-4 py-4 cursor-pointer relative @StyleUtility.GetRadiusClass(BorderRadius.Large) @Class"
         style="@HeaderStyles"
         @onclick="ToggleExpand">
        @if (Icon != null)
        {
        <BIcon Icon="Icon" Color="MaterialColor.OnSurfaceVariant"/>
        }
        <BText Typo="Typo.TitleMedium" Style="padding-left: .75rem">@Header</BText>
        <div style="position: absolute; right: 15px;">
            <BIcon Icon="ExpandIcon"  Color="MaterialColor.OnSurfaceVariant" Style="@ExpandIconStyle"/>
        </div>
    </div>

    <div style="@ChildContentStyle">
        <BContainer Padding="Size.Small" Id="@ChildContainerId">
            <BStack Orientation="Orientation.Vertical" Padding="Size.None">
                <CascadingValue Value="this" IsFixed="true">
                    @ChildContent
                </CascadingValue>
            </BStack>
        </BContainer>
    </div>
</BContainer>



==========================================
FILE: Components\Foldout\BFoldout.razor.cs
==========================================
Last Modified: 12/06/2024 09:49:13
Size: 3113 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Interop;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BFoldout : BComponentBase, IControlChildContent, IControlColor
{
    private double expandedHeight;
    [Parameter] public string Header { get; set; } = string.Empty;
    [Parameter] public SvgIcon? Icon { get; set; }
    [Parameter] public SvgIcon ExpandIcon { get; set; } = GoogleMaterialFilledIcon.ChevronRight;
    [Parameter] public bool IsExpanded { get; set; }
    [CascadingParameter] public BFoldout? Parent { get; set; }

    [Inject] private ElementSizeService ElementSizeService { get; set; }

    private string HeaderStyles => new CssStyleBuilder()
        .AddStyle("background-color", ColorUtility.GetSurfaceColorVariable(0))
        .AddStyle("color", "var(--md-sys-color-on-surface-variant)")
        .AddStyle("transition", MotionUtility.ConstructTransition("all"))
        .AddStyle("border-radius", IsExpanded? $"{StyleUtility.GetRadiusStyle(BorderRadius.Large)} {StyleUtility.GetRadiusStyle(BorderRadius.Large)} 0rem 0rem" : StyleUtility.GetRadiusStyle(BorderRadius.Large))
        .AddStyle("box-shadow", "0px 1px 0px var(--md-sys-color-surface-variant)")
        .Build();

    private string ChildContentStyle => new CssStyleBuilder()
        .AddStyle("width: 100%")
        .AddStyle("max-height", IsExpanded ? $"{ExpandedHeight}px" : "0px")
        .AddStyle("overflow-y", "hidden", !IsExpanded)
        .AddStyle("transition", MotionUtility.ConstructTransition(Motion.EasingEmphasized, 0.2, "max-height"))
        .Build();


    private string ExpandIconStyle => new CssStyleBuilder()
        .AddStyle("transform", IsExpanded ? "rotate(90deg)" : "rotate(0deg)")
        .AddStyle("transition", MotionUtility.ConstructTransition(Motion.EasingEmphasized, 0.2, "transform"))
        .Build();


    private string ChildContainerId { get; } = $"child-container-{Guid.NewGuid()}";

    public double ExpandedHeight
    {
        get => expandedHeight;
        set
        {
            expandedHeight = value;
            Parent?.Refresh(ExpandedHeight);
        }
    }

    [Parameter] public RenderFragment? ChildContent { get; set; }

    [Parameter] public MaterialColor Color { get; set; } = MaterialColor.Primary;

    public void Refresh(double heightChange)
    {
        ExpandedHeight += heightChange;
        Parent?.Refresh(ExpandedHeight);
        StateHasChanged();
    }

    private async Task ToggleExpand()
    {
        IsExpanded = !IsExpanded;

        if (IsExpanded)
        {
            // Force reflow to ensure the style is applied
            _ = ElementSizeService.GetElementSizeAsync(ChildContainerId);

            var size = await ElementSizeService.GetElementSizeAsync(ChildContainerId);
            ExpandedHeight = size?.Height ?? 0;
        }
        else
        {
            ExpandedHeight = 0;
        }

        StateHasChanged();
    }
}


==========================================
FILE: Components\Icon\BIcon.razor
==========================================
Last Modified: 12/03/2024 21:29:40
Size: 143 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<Blazicon Svg="Icon" Attributes="IconAttributes"></Blazicon>


==========================================
FILE: Components\Icon\BIcon.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:48
Size: 753 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Model.Utility;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BIcon : BComponentBase, IControlIcon, IControlSize, IControlColor
{
    private string AdditionalStyle => new CssStyleBuilder()
        .AddStyle("color", ColorUtility.GetColorVariable(Color))
        .Build(Style);

    private Dictionary<string, object> IconAttributes => SizeUtility.GetIconSizeAttributes(Size, AdditionalStyle);

    [Parameter] public MaterialColor Color { get; set; }
    [Parameter] public SvgIcon? Icon { get; set; }
    [Parameter] public Size Size { get; set; } = Size.Medium;
}


==========================================
FILE: Components\Inputs\Field\BInputField.cs
==========================================
Last Modified: 12/06/2024 17:38:18
Size: 1718 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Services;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public class BInputField<T> : BInput<T>
{
    protected string inputId = $"input_{Guid.NewGuid().ToString()}";
    protected bool IsFocusedOrFilled => !IsEmpty() || IsFocused;
    public bool IsFocused { get; set; }

    protected override bool IsEmpty()
    {
        return Value != null;
    }
    
    [Parameter] public BInputView View { get; set; }
    [Parameter] public FieldVariant Variant { get; set; } = FieldVariant.Filled;
    [Parameter] public SvgIcon? LeadingIcon { get; set; }
    [Parameter] public bool FullWidth { get; set; }
    [Parameter] public string? SupportingText { get; set; }
    [Parameter] public SvgIcon? TrailingIcon { get; set; }
    [Parameter] public string Label { get; set; }
    [Parameter] public EventCallback<string> LabelChanged { get; set; }

    [Parameter] public EventCallback OnLeadingIconClick { get; set; }
    [Parameter] public EventCallback OnTrailingIconClick { get; set; }
    [Parameter] public EventCallback<FocusEventArgs> OnFieldFocus { get; set; }
    [Parameter] public EventCallback<FocusEventArgs> OnFieldBlur { get; set; }
    [Parameter] public bool ShowClearButton { get; set; }
    [Parameter] public EventCallback OnClear { get; set; }
    public async Task OnFocus(FocusEventArgs args)
    {
        IsFocused = true;
        await OnFieldFocus.InvokeAsync(args);
    }
    public async Task OnBlur(FocusEventArgs args)
    {
        IsFocused = false;
        await OnFieldBlur.InvokeAsync(args);
    }
}


==========================================
FILE: Components\Inputs\Field\BInputView.razor
==========================================
Last Modified: 12/06/2024 19:48:26
Size: 2067 bytes
------------------------------------------

@using System.Runtime.InteropServices.JavaScript
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
@namespace Bdziam.UI 
<div  class="@Class" id="@Id"  style="@ContainerStyles">
    <div class="field-container" style="@FieldContainerStyles" id="@FieldContainerId">
        <div style="position: relative; display: flex; align-items: top; width: 100%;">

            @if (LeadingIcon != null)
            {
                <InputFieldIcon Icon="@LeadingIcon" IsErrored="IsError" OnClick="@OnLeadingIconClick"/>
            }

            <div class="input-container" style="@InputContainerStyles">
                <label style="@LabelStyles">@Label</label>
                @ChildContent
                </div>
            @if (ShowClearButton)
            {
                <InputFieldIcon Icon="MdiIcon.DeleteCircle" OnClick="Clear" IsTrailing="true"/>
            }
            
            @if (TrailingIcon != null)
            {
                <InputFieldIcon Icon="@TrailingIcon" IsErrored="IsError" OnClick="@OnTrailingIconClick" IsTrailing="true"/>
            }
        </div>

        @if (Variant == FieldVariant.Filled)
        {
            <div class="inactive-line" style="@InactiveLineStyles"></div>
            <div class="active-line" style="@ActiveLineStyles"></div>
        }
    </div>
</div>

@if (!string.IsNullOrEmpty(SupportingText) && !IsError)
{
    <div class="validation-text" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--md-sys-color-on-surface-variant);">
        <BText Typo="Typo.BodySmall" Color="MaterialColor.OnSurfaceVariant" IsSurface="false">@SupportingText</BText> <br />
    </div>
}
@if (!string.IsNullOrEmpty(ErrorText))
{
    <div class="validation-text" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--md-sys-color-error);">
    @foreach (var error in ErrorText.Split("\n"))
    {
        <BText Typo="Typo.BodySmall" Color="MaterialColor.Error" IsSurface="false">@error</BText> <br />
    }
    </div>
}


==========================================
FILE: Components\Inputs\Field\BInputView.razor.cs
==========================================
Last Modified: 12/09/2024 15:47:43
Size: 8540 bytes
------------------------------------------

using System.Drawing;
using System.Runtime.InteropServices.JavaScript;
using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Services;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BInputView : BComponentBase
{
    [Parameter] public string Label { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> LabelChanged { get; set; }

    [Parameter] public string InputId { get; set; } = string.Empty;

    [Parameter] public bool FullWidth { get; set; }
    [Parameter] public EventCallback<bool> FullWidthChanged { get; set; }
    
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public EventCallback<bool> DisabledChanged { get; set; }

    [Parameter] public RenderFragment ChildContent { get; set; }

    [Parameter] public FieldVariant Variant { get; set; } = FieldVariant.Filled;
    [Parameter] public EventCallback<FieldVariant> VariantChanged { get; set; }

    [Parameter] public SvgIcon? LeadingIcon { get; set; }
    [Parameter] public EventCallback<SvgIcon?> LeadingIconChanged { get; set; }

    [Parameter] public string? SupportingText { get; set; }
    [Parameter] public EventCallback<string?> SupportingTextChanged { get; set; }

    [Parameter] public SvgIcon? TrailingIcon { get; set; }
    [Parameter] public EventCallback<SvgIcon?> TrailingIconChanged { get; set; }

    [Parameter] public bool IsFocused { get; set; }
    [Parameter] public EventCallback<bool> IsFocusedChanged { get; set; }
    
    [Parameter] public bool IsFilled { get; set; }
    [Parameter] public EventCallback<bool> IsFilledChanged { get; set; }

    [Parameter] public bool IsError { get; set; }
    [Parameter] public EventCallback<bool> IsErrorChanged { get; set; }

    [Parameter] public string? ErrorText { get; set; }
    [Parameter] public EventCallback<string?> ErrorTextChanged { get; set; }

    [Parameter] public EventCallback OnLeadingIconClick { get; set; }

    [Parameter] public EventCallback OnTrailingIconClick { get; set; }

    [Inject] public BackgroundColorService BackgroundColorService { get; set; }
    
    [Parameter] public bool ShowClearButton { get; set; }
    
    [Parameter] public EventCallback OnClear { get; set; }
    public string FieldContainerId = $"FieldContainer_{Guid.NewGuid()}";
    private string BackgroundColor { get; set; }

    protected string ContainerStyles => new CssStyleBuilder()
        .AddStyle("width", FullWidth ? "100%" : "auto")
        .AddStyle("display", "flex")
        .AddStyle("flex-direction", "column")
        .AddStyle("position", "relative")
        .Build(Style);

    protected string FieldContainerStyles => new CssStyleBuilder()
        .AddStyle("display", "flex")
        .AddStyle("align-items", "top")
        .AddStyle("position", "relative")
        .AddStyle("height", "3.5rem")
        .AddStyle(Variant == FieldVariant.Outline ? "border" : "background-color",
            Variant == FieldVariant.Outline
                ? $"{(IsFocused ? "0.125rem" : "0.063rem")} solid {(IsError ? "var(--md-sys-color-error)" : IsFocused ? "var(--md-sys-color-primary)" : "var(--md-sys-color-outline)")}"
                : "var(--md-sys-color-surface-container-highest)")
        .AddStyle("border-radius", Variant == FieldVariant.Outline ? "0.25rem" : "0.25rem 0.25rem 0 0")
        .AddStyle("width", FullWidth ? "100%" : "fit-content")
        .AddStyle("max-width", FullWidth ? "none" : "20rem")
        .AddStyle("transition", Variant == FieldVariant.Outline ? "border-color 0.3s ease" : "none")
        .Build();

    protected string LabelStyles => new CssStyleBuilder()
        .AddStyle("position", "absolute")
        .AddStyle("top",
            IsFocused || IsFilled
                ? Variant == FieldVariant.Outline ? "-0.65rem" : "-0.5rem"
                : Variant == FieldVariant.Filled ? "0" : "30%")
        .AddStyle("left", ".4rem", Variant == FieldVariant.Outline && (IsFocused || IsFilled))
        .AddStyle("font-size", IsFocused || IsFilled ? "0.8rem" : "1rem")
        .AddStyle("transition", MotionUtility.ConstructTransition())
        .AddStyle("padding", "0rem 0.2rem 0rem 0.2rem", Variant == FieldVariant.Outline)
        .AddStyle("color",
            Disabled ? ColorUtility.GetColorVariable(MaterialColor.SurfaceBright) :
            IsError ? "var(--md-sys-color-error)" :
            IsFocused ? "var(--md-sys-color-primary)" : "var(--md-sys-color-on-surface)")
        .AddStyle("font-weight", "400")
        .AddStyle("opacity", Disabled ? ColorUtility.DisabledOpacity : "1")
        .AddStyle("background-color", Variant == FieldVariant.Outline ? BackgroundColor : "transparent")
        .AddStyle("pointer-events", "none")
        .Build();

    protected string ActiveLineStyles => new CssStyleBuilder()
        .AddStyle("position", "absolute")
        .AddStyle("bottom", "0")
        .AddStyle("left", "0")
        .AddStyle("right", "0")
        
        .AddStyle("height", "0.125rem")
        .AddStyle("background-color", IsError ? "var(--md-sys-color-error)" : IsFocused ? "var(--md-sys-color-primary)" : ColorUtility.GetColorVariable(MaterialColor.OnSurface))
        .AddStyle("transform-origin", "middle center")
        .AddStyle("transition", MotionUtility.ConstructTransition("transform"))
        .AddStyle("transform", IsFocused || IsFilled ? "scaleX(1)" : "scaleX(0)")
        .Build();

    protected string InactiveLineStyles => new CssStyleBuilder()
        .AddStyle("position", "absolute")
        .AddStyle("bottom", "0")
        .AddStyle("left", "0")
        .AddStyle("right", "0")
        .AddStyle("height", "0.125rem")
        .AddStyle("background-color", "var(--md-sys-color-surface-variant)")
        .Build();

    public string InputContainerStyles => new CssStyleBuilder()
        .AddStyle("display", "flex")
        .AddStyle("position", "relative")
        .AddStyle("margin-top", Variant == FieldVariant.Filled ? "1rem" : "0rem")
        .AddStyle("padding-left", "1rem")
        .AddStyle("padding-right", "1rem")
        .Build();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var size = await GetElementSizeAsync();
            BackgroundColor = await BackgroundColorService.GetBackgroundColorFromPointAsync(size.X, size.Y);
        }
    }

    // Notify methods for all bindable parameters
    private async Task NotifyLabelChanged(string newValue)
    {
        Label = newValue;
        await LabelChanged.InvokeAsync(newValue);
    }

    private async Task NotifyFullWidthChanged(bool newValue)
    {
        FullWidth = newValue;
        await FullWidthChanged.InvokeAsync(newValue);
    }

    private async Task NotifyVariantChanged(FieldVariant newValue)
    {
        Variant = newValue;
        await VariantChanged.InvokeAsync(newValue);
    }

    private async Task NotifyLeadingIconChanged(SvgIcon? newValue)
    {
        LeadingIcon = newValue;
        await LeadingIconChanged.InvokeAsync(newValue);
    }

    private async Task NotifySupportingTextChanged(string? newValue)
    {
        SupportingText = newValue;
        await SupportingTextChanged.InvokeAsync(newValue);
    }

    private async Task NotifyTrailingIconChanged(SvgIcon? newValue)
    {
        TrailingIcon = newValue;
        await TrailingIconChanged.InvokeAsync(newValue);
    }

    private async Task NotifyIsFocusedChanged(bool newValue)
    {
        IsFocused = newValue;
        await IsFocusedChanged.InvokeAsync(newValue);
    }

    private async Task NotifyIsFilledChanged(bool newValue)
    {
        IsFilled = newValue;
        await IsFilledChanged.InvokeAsync(newValue);
    }

    private async Task NotifyIsErrorChanged(bool newValue)
    {
        IsError = newValue;
        await IsErrorChanged.InvokeAsync(newValue);
    }

    private async Task NotifyErrorTextChanged(string? newValue)
    {
        ErrorText = newValue;
        await ErrorTextChanged.InvokeAsync(newValue);
    }
    
    private async Task NotifyDisabledChanged(bool newValue)
    {
        Disabled = newValue;
        await DisabledChanged.InvokeAsync(newValue);
    }

    private async Task Clear()
    {
        await OnClear.InvokeAsync();
    }
}



==========================================
FILE: Components\Inputs\Field\BSelect.razor
==========================================
Last Modified: 12/09/2024 16:21:09
Size: 2471 bytes
------------------------------------------

@using Bdziam.UI.Model.Enums
@using Bdziam.UI.Utilities
@using Microsoft.AspNetCore.Components.Web.Virtualization 
@namespace Bdziam.UI
@typeparam T
@inherits BInputField<T>
<div id="@Id">
    <BInputView @ref="InputView" InputId="@inputId"
                Class="@Class"
                Style="@Style"
                @bind-Label="@Label"
                @bind-Variant="@Variant"
                ErrorText="@ErrorText"
                IsError="@Error"
                @bind-IsFocused="DropdownVisible"
                IsFilled="@(!IsEmpty())"
                @bind-LeadingIcon="@LeadingIcon"
                @bind-SupportingText="@SupportingText"
                TrailingIcon="GoogleMaterialFilledIcon.ArrowDropDown"
                OnTrailingIconClick="ToggleDropdown"
                OnLeadingIconClick="@OnLeadingIconClick"
                @bind-FullWidth="@FullWidth"
                ShowClearButton="ShowClearButton"
                OnClear="@(() => { Value = default(T); })"
                @bind-Disabled="@Disabled">
        <div style="@InputContainerStyles" class="select-input" id="@inputId">
            <span>@SelectedText</span>
        </div>
    </BInputView>

    @if (DropdownVisible)
    {
    <BPopover @bind-IsOpen="DropdownVisible" TargetElementId="@InputView.FieldContainerId" MatchWidth="true" Position="Position.Bottom" Padding="Size.Small" Style="@DropdownStyle">
        <BStack Orientation="Orientation.Vertical" Padding="Size.None">
            @if (ShowSearch)
            {
            <div class="search-container">
                <BTextField Variant="FieldVariant.Outline" Label="Search..." @bind-Value="SearchQuery"></BTextField>
            </div>
            }

            <Virtualize ItemsProvider="LoadVirtualizedOptions" ItemSize="40">
                <ItemContent Context="Option">
                    <div class="dropdown-option"
                         style="@DropdownOptionStyles(Option)"
                         @onclick="() => OnOptionSelect(Option)">
                        @if (ShowOptionIcons && GetOptionIcon != null)
                        {
                        <BIcon Style="padding-left: 0.5rem" Icon="GetOptionIcon.Invoke(Option)"></BIcon>
                        }
                        @OptionToString(Option)
                    </div>
                </ItemContent>
            </Virtualize>
        </BStack>
    </BPopover>
    }
</div>



==========================================
FILE: Components\Inputs\Field\BSelect.razor.cs
==========================================
Last Modified: 12/09/2024 16:34:35
Size: 3848 bytes
------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web.Virtualization;

namespace Bdziam.UI;

public partial class BSelect<T> : BInputField<T>
{
    [Parameter] public IEnumerable<T>? Options { get; set; } = Enumerable.Empty<T>();
    [Parameter] public IQueryable<T>? VirtualOptions { get; set; }
    [Parameter] public Func<T, string>? DisplayProperty { get; set; }
    [Parameter] public EventCallback<T> OnSelect { get; set; }
    [Parameter] public bool ShowSearch { get; set; } = false;
    [Parameter] public int VisibleOptionsCount { get; set; } = 10;
    [Parameter] public bool ShowOptionIcons { get; set; } = false;
    [Parameter] public Func<T, SvgIcon>? GetOptionIcon { get; set; }

    private bool DropdownVisible { get; set; }
    private string? SearchQuery { get; set; }

    private IEnumerable<T> FilteredOptions => string.IsNullOrEmpty(SearchQuery)
        ? Options ?? Enumerable.Empty<T>()
        : (Options ?? Enumerable.Empty<T>()).Where(o => OptionToString(o).Contains(SearchQuery, StringComparison.OrdinalIgnoreCase));

    private string SelectedText => Value != null ? OptionToString(Value) : "";

    protected override bool IsEmpty() => Value is null;

    private void ToggleDropdown()
    {
        if (Disabled) return;
        DropdownVisible = !DropdownVisible;
    }

    private async Task OnOptionSelect(T option)
    {
        Value = option;
        DropdownVisible = false;
        await OnSelect.InvokeAsync(option);
        Validate();
    }

    private async ValueTask<ItemsProviderResult<T>> LoadVirtualizedOptions(ItemsProviderRequest request)
    {
        var query = VirtualOptions ?? FilteredOptions.AsQueryable();

        if (!string.IsNullOrEmpty(SearchQuery))
        {
            query = query.Where(o => OptionToString(o).Contains(SearchQuery, StringComparison.OrdinalIgnoreCase));
        }

        var totalItemCount = query.Count();
        var items = query.Skip(request.StartIndex).Take(request.Count).ToList();

        return new ItemsProviderResult<T>(items, totalItemCount);
    }

    private string OptionToString(T option) =>
        DisplayProperty != null ? DisplayProperty(option) : option?.ToString() ?? string.Empty;

    private string InputContainerStyles => new CssStyleBuilder()
        .AddStyle("display", "flex")
        .AddStyle("align-self", "center")
        .AddStyle("position", "relative")
        .AddStyle("font-size", "1rem")
        .AddStyle("font-weight", "400")
        .AddStyle("margin-top", "0.7rem", IsFocusedOrFilled && Variant == FieldVariant.Filled)
        .AddStyle("font-family", "Roboto")
        .AddStyle("color", ColorUtility.GetColorVariable(IsFocused ? MaterialColor.Primary : MaterialColor.OnSurfaceVariant))
        .AddStyle("width", FullWidth ? "100%" : "10rem")
        .Build();

    public BInputView InputView { get; set; }

    public string DropdownStyle => new CssStyleBuilder()
        .AddStyle("max-height", "10rem")
        .AddStyle("min-width", "10rem")
        .AddStyle("overflow-y", "auto")
        .Build();

    private string DropdownOptionStyles(T option) => new CssStyleBuilder()
        .AddStyle("padding", "0.5rem 1rem")
        .AddStyle("cursor", "pointer")
        .AddStyle("color", "var(--md-sys-color-on-surface)")
        .AddStyle("background-color", EqualityComparer<T>.Default.Equals(Value, option) ? "var(--md-sys-color-surface-variant)" : "transparent")
        .AddStyle("hover", "background: var(--md-sys-color-surface-container-high)")
        .Build();
}



==========================================
FILE: Components\Inputs\Field\BTextField.razor
==========================================
Last Modified: 12/06/2024 17:39:01
Size: 1206 bytes
------------------------------------------

@using Bdziam.UI.Model.Enums
@namespace Bdziam.UI
@inherits BInputField<string>

<BInputView InputId="@inputId" 
            Class="@Class" 
            Style="@Style" 
            @bind-Label="@Label" 
            @bind-Variant="@Variant" 
            ErrorText="@ErrorText" 
            IsError="@Error" 
            @bind-IsFocused="@IsFocused" 
            IsFilled="@(!IsEmpty())"
            @bind-LeadingIcon="@LeadingIcon" 
            @bind-SupportingText="@SupportingText" 
            @bind-TrailingIcon="@TrailingIcon" 
            OnTrailingIconClick="@OnTrailingIconClick" 
            OnLeadingIconClick="@OnLeadingIconClick" 
            @bind-FullWidth="@FullWidth" 
            @bind-Disabled="@Disabled"
            ShowClearButton="ShowClearButton"
            OnClear="@(() => Value = string.Empty)"
            Id="@Id">
    <input
        id="@inputId"
        type="@GetInputType()"
        @bind="Value"
        @onfocus="@OnFocus"
        @onblur="@OnBlur"
        @oninput="OnInput"
        placeholder=" "
        style="@InputStyles"
        disabled="@Disabled"
        maxlength="@MaxLength"
        readonly="@ReadOnly" />
</BInputView>


==========================================
FILE: Components\Inputs\Field\BTextField.razor.cs
==========================================
Last Modified: 12/06/2024 16:29:11
Size: 1761 bytes
------------------------------------------

using System.Diagnostics.Metrics;
using System.Drawing;
using System.Net.Mime;
using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public partial class BTextField : BInputField<string>
{
    public int? Counter { get; set; }
    [Parameter] public InputType InputType { get; set; }
    [Parameter] public int? MaxLength { get; set; }
    
    protected void OnInput(ChangeEventArgs e)
    {
        Value = e.Value?.ToString();
        Validate();
    }

    protected override bool IsEmpty()
    {
        return string.IsNullOrEmpty(Value);
    }

    protected string InputStyles => new CssStyleBuilder()
        
        .AddStyle("width", "100%")
        .AddStyle("height", "100%")
        .AddStyle("border", "none")
        .AddStyle("font-weight", "400")
        .AddStyle("outline", "none")
        .AddStyle("line-height",  "1.5rem")
        .AddStyle("background", "transparent")
        .AddStyle("padding", "1rem 0 1rem 0")
        .AddStyle("font-size", "1rem")
        .AddStyle("opacity", Disabled ? ColorUtility.DisabledOpacity : "1")
        .AddStyle("color", "var(--md-sys-color-on-surface)")
        .Build();

    
    
    private string GetCounterText() => Counter switch
    {
        null => string.Empty,
        0 => (string.IsNullOrEmpty(Value) ? "0" : $"{Value.Length}"),
        _ => (string.IsNullOrEmpty(Value) ? "0" : $"{Value.Length}") + $" / {MaxLength}"
    };
    
    protected string GetInputType()
    {
        return InputType.ToString().ToLowerInvariant().Replace("datetimeLocal", "datetime-local");
    }

}


==========================================
FILE: Components\Inputs\Field\InputFieldIcon.razor
==========================================
Last Modified: 12/05/2024 13:23:44
Size: 315 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BComponentBase

<div class="input-field-icon" style="@IconStyles" @onclick="HandleClick">
    <BIcon Icon="@Icon" Size="Size.Medium" Color="IsErrored ? MaterialColor.Error : MaterialColor.OnSurfaceVariant"/>
</div>


==========================================
FILE: Components\Inputs\Field\InputFieldIcon.razor.cs
==========================================
Last Modified: 12/05/2024 13:31:21
Size: 996 bytes
------------------------------------------

using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class InputFieldIcon
{
    [Parameter] public SvgIcon? Icon { get; set; }
    [Parameter] public bool IsErrored { get; set; }
    [Parameter] public bool IsTrailing { get; set; }
    [Parameter] public EventCallback OnClick { get; set; }

    protected string IconStyles => new CssStyleBuilder()
        .AddStyle("display", "flex")
        .AddStyle("align-items", "center")
        .AddStyle("padding-right: 0.75rem", IsTrailing)
        .AddStyle("padding-left: 0.75rem", !IsTrailing)
        .AddStyle("justify-content", "center")
        .AddStyle("cursor", OnClick.HasDelegate ? "pointer" : "default")
        .Build();

    protected string IconColor => IsErrored ? "MaterialColor.Error" : "MaterialColor.OnSurfaceVariant";

    private async Task HandleClick()
    {
        if (OnClick.HasDelegate) await OnClick.InvokeAsync();
    }
}


==========================================
FILE: Components\Inputs\BSwitch.razor
==========================================
Last Modified: 12/06/2024 08:57:11
Size: 867 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BInput<bool>

@code {
    protected override bool IsEmpty()
    {
        return Value == false;
    }
}

<div @onclick="ToggleSwitch" style="position: relative; display: inline-flex; align-items: center; gap: 0.5rem; cursor: pointer;" class="@Class" id="@Id">
    <!-- Track -->
    <div style="@TrackStyles">
        <!-- Thumb -->
        <div style="@ThumbStyles">
            @if (Value && Icon != null)
            {
                <BIcon Icon="Icon" Size="Size.Small" Color="MaterialColor.Primary"/>
            }
        </div>
    </div>
    <!-- Required Error -->
    @if (Required && Value == false)
    {
        <br/>
        <BText Typo="Typo.BodySmall" Color="MaterialColor.OnErrorContainer">@RequiredError</BText>
    }
</div>


==========================================
FILE: Components\Inputs\BSwitch.razor.cs
==========================================
Last Modified: 12/05/2024 13:40:29
Size: 2619 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public partial class BSwitch : BInput<bool>, IControlIcon
{
    [Parameter] public bool Ripple { get; set; } = true;

    /// <summary>
    ///     Styles for the track of the switch.
    /// </summary>
    protected string TrackStyles => new CssStyleBuilder()
        .AddStyle("width", "3.25rem")
        .AddStyle("height", "2rem")
        .AddStyle("border-radius", "1rem")
        .AddStyle("background-color",
            Value ? "var(--md-sys-color-primary)" : "var(--md-sys-color-surface-container-highest)")
        .AddStyle("border", Value ? "none" : "2px solid var(--md-sys-color-outline)")
        .AddStyle("transition",
            MotionUtility.ConstructTransition(Motion.EasingEmphasized, 0.3, "background-color", "border"))
        .AddStyle("cursor", Disabled ? "not-allowed" : "pointer")
        .AddStyle("position", "relative")
        .Build();

    /// <summary>
    ///     Styles for the thumb of the switch.
    /// </summary>
    protected string ThumbStyles => new CssStyleBuilder()
        .AddStyle("position", "absolute")
        .AddStyle("top", "50%")
        .AddStyle("left", "0.25rem")
        .AddStyle("transform", Value ? "translate(1.25rem, -50%)" : "translate(0, -50%)")
        .AddStyle("width", Value ? "1.5rem" : "1rem")
        .AddStyle("height", Value ? "1.5rem" : "1rem")
        .AddStyle("border-radius", "50%")
        .AddStyle("background-color", Value ? "var(--md-sys-color-on-primary)" : "var(--md-sys-color-outline)")
        .AddStyle("box-shadow", Value ? "0px 2px 4px rgba(0, 0, 0, 0.25)" : "0px 1px 2px rgba(0, 0, 0, 0.15)")
        .AddStyle("transition",
            MotionUtility.ConstructTransition(Motion.EasingEmphasized, 0.2, "transform", "width", "height",
                "background-color"))
        .AddStyle("display", "flex")
        .AddStyle("align-items", "center")
        .AddStyle("justify-content", "center")
        .AddStyle("cursor", Disabled ? "not-allowed" : "pointer")
        .Build();

    [Parameter] public SvgIcon? Icon { get; set; }

    /// <summary>
    ///     Handles the toggle behavior for the switch.
    /// </summary>
    private async Task ToggleSwitch(MouseEventArgs e)
    {
        if (!Disabled)
        {
            Value = !Value;
            await ValueChanged.InvokeAsync(Value);
            Validate();
        }
    }
}


==========================================
FILE: Components\Layout\BBody.razor
==========================================
Last Modified: 12/06/2024 13:40:48
Size: 352 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BComponentBase

<div id="@Id" style="@AppliedStyle">
    <BContainer BorderRadius="BorderRadius.Medium" SurfaceMaterialColor="MaterialColor.Surface" Style="width: 100%; height: 95vh"  Padding="Padding">
        @ChildContent
    </BContainer>
</div>


==========================================
FILE: Components\Layout\BBody.razor.cs
==========================================
Last Modified: 12/06/2024 13:33:29
Size: 728 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Model.Utility;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;
using Size = Bdziam.UI.Model.Enums.Size;

namespace Bdziam.UI;

public partial class BBody : BComponentBase
{
    [Parameter] public Size Padding { get; set; } = Size.Medium;
    [Parameter] public RenderFragment ChildContent { get; set; }
    
    [Parameter] public MaterialColor BackgroundColor { get; set; }

    public string AppliedStyle =>
        new CssStyleBuilder()
            .AddStyle("overflow-y", "auto")
            .AddStyle("background-color", ColorUtility.GetColorVariable(BackgroundColor))
            .Build(Style);
}


==========================================
FILE: Components\Layout\BCanonicalLayout.razor
==========================================
Last Modified: 12/06/2024 13:36:32
Size: 1600 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<main id="@Id" class="transition-all ease-in-out" style="overflow: hidden;">
    <BDrawer
        Elevation="@Elevation"
        IsOpen="@IsDrawerOpen"
        Position="DrawerPosition.Left"
        MaterialColor="MaterialColor.SurfaceContainer"
        Width="300">
        <ChildContent>
            <BDrawerMenu>
                <BDrawerMenuComposer></BDrawerMenuComposer>
            </BDrawerMenu>
        </ChildContent>
        <TopBar>
            <BTopBar  Style="margin-left: -2px" Color="MaterialColor.SurfaceContainer" Elevation="@Elevation" Size="Size.Large">
                <LeftContent>
                    <BToggleIconButton Style="margin-left: -0.75rem" CheckedIcon="GoogleMaterialFilledIcon.Menu" Color="MaterialColor.SurfaceContainer" HorizontalPadding="Size.None" Variant="ButtonVariant.Text" UncheckedIcon="GoogleMaterialFilledIcon.Menu" CheckedChanged="ToggleDrawer" Checked="IsDrawerOpen"></BToggleIconButton>
                    @LeftTopBarContent
                </LeftContent>
                <MiddleContent>
                    @MiddleTopBarContent
                </MiddleContent>
                <RightContent>
                    @RightTopBarContent
                </RightContent>
            </BTopBar>
        </TopBar>
        <MainContent>
            <BBody Padding="Size.Medium" BackgroundColor="MaterialColor.SurfaceContainer">
                @Body
            </BBody>
        </MainContent>
    </BDrawer>
</main>


==========================================
FILE: Components\Layout\BCanonicalLayout.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:32
Size: 743 bytes
------------------------------------------

using Microsoft.AspNetCore.Components;
using Color = System.Drawing.Color;

namespace Bdziam.UI;

public partial class BCanonicalLayout
{
    [Parameter] public RenderFragment? Body { get; set; }
    [Parameter] public int Elevation { get; set; } = 0;
    private bool IsDrawerOpen { get; set; } = false;
    [Parameter] public RenderFragment? DrawerMenuContent { get; set; }
    [Parameter] public RenderFragment? LeftTopBarContent { get; set; }
    [Parameter] public RenderFragment? RightTopBarContent { get; set; }

    private Color SeedColor { get; set; }
    [Parameter] public RenderFragment? MiddleTopBarContent { get; set; }

    private void ToggleDrawer()
    {
        IsDrawerOpen = !IsDrawerOpen;
    }
}


==========================================
FILE: Components\Layout\BContainer.razor
==========================================
Last Modified: 11/26/2024 14:28:13
Size: 172 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div id="@Id" style="@ContainerStyle" class="@ContainerClass">
    @ChildContent
</div>


==========================================
FILE: Components\Layout\BContainer.razor.cs
==========================================
Last Modified: 12/06/2024 09:09:41
Size: 1304 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Model.Utility;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BContainer : BComponentBase
{
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public int Elevation { get; set; } = 0;
    [Parameter] public MaterialColor SurfaceMaterialColor { get; set; } = MaterialColor.Surface;
    [Parameter] public BorderRadius BorderRadius { get; set; } = BorderRadius.Medium;
    [Parameter] public Size Padding { get; set; } = Size.Small;

    private string ContainerStyle =>
        new CssStyleBuilder()
            .AddStyle("background-color",
                SurfaceMaterialColor == MaterialColor.Surface
                    ? ColorUtility.GetSurfaceColorVariable(Elevation)
                    : ColorUtility.GetColorVariable(SurfaceMaterialColor))
            .AddStyle("color", ColorUtility.GetTextColorVariable(SurfaceMaterialColor))
            .AddStyle("padding", SizeUtility.GetPadding(Padding))
            .Build(Style);

    private string ContainerClass => new CssClassBuilder()
        .AddClass(StyleUtility.GetRadiusClass(BorderRadius))
        .AddClass(Class)
        .Build();
}


==========================================
FILE: Components\Layout\BMasonryGrid.razor
==========================================
Last Modified: 11/29/2024 10:57:32
Size: 319 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase

<div id="@Id" class="@ContainerClasses" style="@ContainerStyles">
    @foreach (var item in ChildContentRenderFragments)
    {
        <div class="@ItemClasses" style="@ItemStyles">
            @item
        </div>
    }
</div>


==========================================
FILE: Components\Layout\BMasonryGrid.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:52
Size: 1680 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BMasonryGrid : BComponentBase
{
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public int Columns { get; set; } = 3; // Default number of columns
    [Parameter] public Size Gap { get; set; } = Size.Medium; // Space between items
    [Parameter] public List<double> ColumnWidths { get; set; } = new(); // Custom column widths
    [Parameter] public bool IsResponsive { get; set; } = true; // Add responsiveness if required

    private string ContainerClasses => "masonry-grid";

    private string ContainerStyles => new CssStyleBuilder()
        .AddStyle("display", "grid")
        .AddStyle("grid-template-columns", GenerateColumnStyles())
        .AddStyle("gap", $"{(int)Gap}rem")
        .Build();

    private string ItemClasses => "masonry-item";

    private string ItemStyles => new CssStyleBuilder()
        .AddStyle("margin", $"{(int)Gap / 2}rem") // Optional item-specific styling
        .Build();

    private IEnumerable<RenderFragment> ChildContentRenderFragments
    {
        get
        {
            var fragments = new List<RenderFragment>();
            if (ChildContent != null) fragments.Add(ChildContent);
            return fragments;
        }
    }

    private string GenerateColumnStyles()
    {
        if (ColumnWidths != null && ColumnWidths.Count > 0)
            return string.Join(" ", ColumnWidths.Select(width => $"{width}fr"));
        return $"repeat({Columns}, 1fr)";
    }
}


==========================================
FILE: Components\Layout\BSpacer.razor
==========================================
Last Modified: 12/05/2024 13:22:46
Size: 117 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div class="@SpacerClasses"></div>


==========================================
FILE: Components\Layout\BSpacer.razor.cs
==========================================
Last Modified: 12/05/2024 13:23:20
Size: 430 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BSpacer : BComponentBase
{
    [Parameter] public Size Size { get; set; } = Size.Medium;

    private string SpacerClasses => Size switch
    {
        Size.Small => "w-2",
        Size.Medium => "w-4",
        Size.Large => "w-8",
        _ => "w-4"
    };
}


==========================================
FILE: Components\Layout\BStack.razor
==========================================
Last Modified: 11/29/2024 10:55:35
Size: 165 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div id="@Id" class="@ContainerClasses" style="@Style">
    @ChildContent
</div>


==========================================
FILE: Components\Layout\BStack.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:32
Size: 883 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BStack : BComponentBase
{
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public Orientation Orientation { get; set; } = Orientation.Vertical;
    [Parameter] public Size Spacing { get; set; } = Size.Medium;
    [Parameter] public Size Padding { get; set; } = Size.Medium;
    [Parameter] public Size ItemMargin { get; set; } = Size.None;

    private string ContainerClasses => Orientation switch
    {
        Orientation.Horizontal => $"flex flex-row space-x-{(int)Spacing} p-{(int)Padding}",
        _ => $"flex flex-col space-y-{(int)Spacing} p-{(int)Padding}"
    };

    private string ItemClasses => ItemMargin != Size.None ? $"m-{(int)ItemMargin}" : string.Empty;
}


==========================================
FILE: Components\Layout\BUniformGrid.razor
==========================================
Last Modified: 12/05/2024 13:22:29
Size: 177 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase

<div id="@Id" class="@ContainerClasses" style="@ContainerStyles">
    @ChildContent
</div>


==========================================
FILE: Components\Layout\BUniformGrid.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:32
Size: 945 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BUniformGrid : BComponentBase
{
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public int Columns { get; set; } = 2; // Default number of rows
    [Parameter] public Size Gap { get; set; } = Size.Medium; // Space between items
    [Parameter] public bool IsResponsive { get; set; } = true; // Add responsiveness if required

    private string ContainerClasses => "grid";

    private string ContainerStyles => new CssStyleBuilder()
        .AddStyle("display", "grid")
        .AddStyle("grid-template-columns", $"repeat({Columns}, {(int)Gap}fr)") // Fixed number of rows
        .AddStyle("gap", $"{(int)Gap}rem")
        .AddStyle("width", "100%")
        .AddStyle("height", "100%")
        .Build();
}


==========================================
FILE: Components\Navigation\Drawer\BDrawer.razor
==========================================
Last Modified: 12/05/2024 13:23:06
Size: 843 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div id="@Id" style="display: flex; height: 100vh@(Style != null ? $";{Style}" : string.Empty)" class="transition-all ease-in-out transition-colors @Class">
    <!-- Drawer -->
    <BContainer BorderRadius="BorderRadius.None" Padding="Size.None" Style="@DrawerStyle" SurfaceMaterialColor="MaterialColor" Elevation="@Elevation">
        @ChildContent
    </BContainer>
    <div style="@ContentStyle">
        @if (TopBar != null)
        {
            <!-- Optional TopBar Content -->
            <div style="@MainContentStyle">
                @TopBar
            </div>
        }

        <!-- Main Content -->
        <div style="@MainContentStyle">
            @MainContent
        </div>
    </div>

</div>


==========================================
FILE: Components\Navigation\Drawer\BDrawer.razor.cs
==========================================
Last Modified: 12/06/2024 13:38:23
Size: 3307 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BDrawer : BComponentBase
{
    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public RenderFragment? TopBar { get; set; } = null;

    [Parameter] public RenderFragment MainContent { get; set; }
    [Parameter] public bool IsOpen { get; set; } = true;
    [Parameter] public EventCallback<bool> IsOpenChanged { get; set; }
    [Parameter] public DrawerPosition Position { get; set; } = DrawerPosition.Left;
    [Parameter] public int Width { get; set; } = 300; // Default drawer width in pixels
    [Parameter] public MaterialColor MaterialColor { get; set; } = MaterialColor.Surface;
    [Parameter] public int Elevation { get; set; } = 0;

    private string DrawerStyle => new CssStyleBuilder()
        .AddStyle("width", $"{Width}px")
        .AddStyle("height", "100vh")
        .AddStyle("position", "fixed")
        .AddStyle(Position == DrawerPosition.Left ? "left" : "right", IsOpen ? "0" : $"-{Width}px")
        .AddStyle("top", "0")
        .AddStyle("overflow-y", "auto")
        .AddStyle("padding", "1rem")
        .AddStyle("transition",MotionUtility.ConstructTransition(Motion.EasingStandard, 0.3, "left", "right"))
        .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor))
        .AddStyle("z-index", "1000")
        .Build();

    private string DrawerContainerStyle => new CssStyleBuilder()
        .AddStyle("display", "flex")
        .AddStyle("flex-direction", "row")
        .AddStyle("height", "100vh")
        .Build();

    private string MainContentStyle => new CssStyleBuilder()
        .AddStyle("background-color",
            ColorUtility.GetColorVariable(MaterialColor.Background)) // Consistent background color
        // .AddStyle("box-shadow", "0px 4px 10px rgba(0,0,0,0.1)") // Optional: subtle shadow for depth
        .Build();

    private string TopBarStyle => new CssStyleBuilder()
        .AddStyle("flex-grow", "0")
        .AddStyle("background-color",
            ColorUtility.GetColorVariable(MaterialColor.Background)) // Consistent background color
        .Build();

    private string ContentStyle => new CssStyleBuilder()
        .AddStyle("display", "flex")
        .AddStyle("flex-direction", "column")
        .AddStyle("flex-grow", "1")
        .AddStyle("margin-left", IsOpen && Position == DrawerPosition.Left ? $"{Width}px" : "0px")
        .AddStyle("margin-right", IsOpen && Position == DrawerPosition.Right ? $"{Width}px" : "0px")
        .AddStyle("transition",
            MotionUtility.ConstructTransition(Motion.EasingStandard, 0.3, "margin-left", "margin-right"))
        .AddStyle("overflow-y", "auto") // Ensure content respects the rounded corners
        .AddStyle("background-color",
            ColorUtility.GetColorVariable(MaterialColor.Background)) // Consistent background color
        // .AddStyle("box-shadow", "0px 4px 10px rgba(0,0,0,0.1)") // Optional: subtle shadow for depth
        .Build();

    private async Task ToggleDrawer()
    {
        IsOpen = !IsOpen;
        await IsOpenChanged.InvokeAsync(IsOpen);
    }
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerHeader.razor
==========================================
Last Modified: 12/05/2024 13:23:18
Size: 332 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits BDrawerMenuItemBase
<div id="@Id" class="flex items-center justify-between p-4 @Class" style="@Style">
    <span class="font-bold">@Text</span>
    @if (Icon != null)
    {
        <Blazicon Svg="@(Icon.WithColor("var(--md-sys-color-on-primary)"))" Width="24px" Height="24px"/>
    }
</div>


==========================================
FILE: Components\Navigation\Drawer\BDrawerHeader.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:58
Size: 89 bytes
------------------------------------------

namespace Bdziam.UI;

public partial class BDrawerHeader : BDrawerMenuItemBase
{
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenu.razor
==========================================
Last Modified: 11/29/2024 17:09:41
Size: 353 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits BDrawerMenuBase

<div id="@Id" class="flex flex-col w-full @Class" style="@Style">
    <BStack Orientation="Orientation.Vertical" Spacing="Size.Medium">
        <CascadingValue Value="this" IsFixed="true">
            @ChildContent
        </CascadingValue>

    </BStack>
</div>


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenu.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:44
Size: 501 bytes
------------------------------------------

using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BDrawerMenu : BDrawerMenuBase
{
    [Inject] private NavigationManager NavigationManager { get; set; } = null!;
    public Action<string> NavigationChanged { get; set; } = null!;

    protected override void OnInitialized()
    {
        NavigationManager.RegisterLocationChangingHandler(async location =>
        {
            NavigationChanged?.Invoke(location.TargetLocation);
        });
    }
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenuBase.cs
==========================================
Last Modified: 12/05/2024 13:23:09
Size: 424 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public class BDrawerMenuBase : BComponentBase, IControlColor
{
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public Action<BDrawerMenuItemBase>? ActiveItemChanged { get; set; }
    [CascadingParameter] public MaterialColor Color { get; set; }
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenuComposer.razor
==========================================
Last Modified: 11/29/2024 15:32:30
Size: 166 bytes
------------------------------------------

@inject NavigationService NavigationService
@namespace Bdziam.UI
<div>
    @foreach (var item in MenuItems)
    {
        @RenderMenuItem(item)
    }
</div>


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenuComposer.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:52
Size: 1230 bytes
------------------------------------------

using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BDrawerMenuComposer : ComponentBase
{
    private IEnumerable<BDrawerMenuItemModel> MenuItems = Enumerable.Empty<BDrawerMenuItemModel>();

    [CascadingParameter] public BDrawerMenu DrawerMenu { get; set; }

    protected override async Task OnInitializedAsync()
    {
        MenuItems = NavigationService.GetMenuHierarchy();
    }

    private RenderFragment RenderMenuItem(BDrawerMenuItemModel item)
    {
        return builder =>
        {
            builder.OpenComponent<BDrawerMenuItem>(0);
            if (item.Uri != null) builder.AddAttribute(1, "Uri", item.Uri);
            builder.AddAttribute(2, "Text", item.Text);
            if (item.Icon != null) builder.AddAttribute(3, "Icon", item.Icon);
            builder.AddAttribute(4, "ComposedMenu", DrawerMenu);
            if (item.Children.Count > 0)
                builder.AddAttribute(5, "ChildContent", (RenderFragment)(childBuilder =>
                {
                    foreach (var child in item.Children) childBuilder.AddContent(6, RenderMenuItem(child));
                }));

            builder.CloseComponent();
        };
    }
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenuItem.razor
==========================================
Last Modified: 12/05/2024 13:23:08
Size: 1449 bytes
------------------------------------------

@using Bdziam.UI.Model.Enums
@using Bdziam.UI.Utilities
@inherits BDrawerMenuItemBase
@namespace Bdziam.UI

<div id="@Id" class="menu-item transition-all relative flex items-center gap-4 px-4 py-4 cursor-pointer @StyleUtility.GetRadiusClass(BorderRadius.Pill) @Class"
     style="@MenuItemStyles"
     @onclick="HandleClick">
    <BPillRipple @bind-IsActive="@IsActive" MaterialColor="MaterialColor.Secondary" Behind="true"></BPillRipple>
    @if (Icon != null)
    {
        <Blazicon Svg="Icon" Attributes="IconAttributes"/>
    }
    <BText Typo="Typo.LabelMedium" Style="font-weight: bold" Color="@(IsActive ? MaterialColor.Secondary : MaterialColor.SurfaceVariant)">@Text</BText>
    @if (BadgeText != null)
    {
        <div class="badge flex items-center justify-center rounded-full px-2 text-xs" style="background-color: var(--md-sys-color-secondary); color: var(--md-sys-color-on-secondary);">
            @BadgeText
        </div>
    }
    @if (HasChildren)
    {
        <div style="position: absolute; right: 15px;">
            <Blazicon Svg="GoogleMaterialFilledIcon.ChevronRight" Attributes="ArrowIconAttributes"/>
        </div>
    }
</div>

<div style="@ChildContentStyle">
    <BStack Id="@ChildContainerId" Orientation="Orientation.Vertical" Spacing="Size.Medium">
        <CascadingValue Value="this" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </BStack>
</div>


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenuItem.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:42
Size: 4371 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Interop;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public partial class BDrawerMenuItem : BDrawerMenuItemBase, IControlChildContent
{
    private double expandedHeight;
    [Parameter] public string? BadgeText { get; set; }

    [CascadingParameter] public BDrawerMenuItem? Parent { get; set; }

    [Parameter] public bool IsExpanded { get; set; }

    [Parameter] public string? Uri { get; set; }
    [Inject] private NavigationManager NavigationManager { get; set; }
    [Inject] private ElementSizeService ElementSizeService { get; set; }
    [Parameter] public BDrawerMenu? ComposedMenu { get; set; }
    private bool HasChildren => ChildContent != null;

    private Dictionary<string, object> IconAttributes => new()
    {
        ["style"] = new CssStyleBuilder()
            .AddStyle("width", "1.5rem")
            .AddStyle("height", "1.5rem")
            .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor.SurfaceVariant), !IsActive)
            .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor.Secondary), IsActive)
            .Build()
    };

    private Dictionary<string, object> ArrowIconAttributes => new()
    {
        ["style"] = new CssStyleBuilder()
            .AddStyle("width", "1.5rem")
            .AddStyle("height", "1.5rem")
            .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor.SurfaceVariant), !IsActive)
            .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor.Secondary), IsActive)
            .AddStyle("transform", IsExpanded ? "rotate(90deg)" : "rotate(0deg)")
            .AddStyle("transition", MotionUtility.ConstructTransition(Motion.EasingEmphasized, 0.2, "transform"))
            .Build()
    };

    private string MenuItemStyles => new CssStyleBuilder()
        .AddStyle("overflow: hidden")
        .AddStyle("background-color", "transparent")
        .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor.SurfaceVariant), !IsActive)
        .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor.Secondary), IsActive)
        .Build();

    private string ChildContentStyle => new CssStyleBuilder()
        .AddStyle("max-height", IsExpanded ? $"{ExpandedHeight}px" : "0px")
        .AddStyle("overflow", "hidden")
        .AddStyle("transition", MotionUtility.ConstructTransition(Motion.EasingEmphasized, 0.3, "max-height"))
        .Build();

    private string ChildContainerId { get; } = $"child-container-{Guid.NewGuid()}";

    public double ExpandedHeight
    {
        get => expandedHeight;
        set
        {
            expandedHeight = value;
            Parent?.Refresh(ExpandedHeight);
        }
    }

    public BPillRipple PillRipple { get; set; }

    [Parameter] public RenderFragment? ChildContent { get; set; }


    public void Refresh(double expandedHeight)
    {
        ExpandedHeight += expandedHeight;
        if (Parent != null) Parent.ExpandedHeight += ExpandedHeight;
        StateHasChanged();
    }

    protected override void OnInitialized()
    {
        IsActive = false;
        var menu = ComposedMenu ?? CascadedMenu;
        if (menu == null) return;
        menu.NavigationChanged += newUri =>
        {
            if (newUri == Uri)
            {
                IsActive = true;
                StateHasChanged();
                return;
            }

            IsActive = false;
            StateHasChanged();
        };
    }

    private async Task HandleClick(MouseEventArgs eventArgs)
    {
        if (HasChildren)
        {
            IsExpanded = !IsExpanded;

            if (IsExpanded)
            {
                // Measure the child container height when expanded
                var size = await ElementSizeService.GetElementSizeAsync(ChildContainerId);
                ExpandedHeight = size?.Height ?? 0;
            }
            else
            {
                ExpandedHeight = 0;
            }

            StateHasChanged();
            return;
        }

        if (!string.IsNullOrEmpty(Uri)) NavigationManager.NavigateTo(Uri);
    }
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenuItemBase.cs
==========================================
Last Modified: 12/05/2024 13:23:15
Size: 1117 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public abstract class BDrawerMenuItemBase : BComponentBase, IControlIcon
{
    /// <summary>
    ///     The text displayed on the menu item.
    /// </summary>
    [Parameter]
    public string? Text { get; set; }

    [Parameter] public bool IsActive { get; set; }

    /// <summary>
    ///     CSS classes built dynamically, including additional classes.
    /// </summary>
    protected string ItemClasses => new CssClassBuilder()
        .AddClass(Class)
        .Build();

    /// <summary>
    ///     CSS styles built dynamically, including additional styles.
    /// </summary>
    protected string ItemStyles => new CssStyleBuilder()
        .AddStyle("overflow", "hidden")
        .Build(Style);


    [CascadingParameter] public BDrawerMenu? CascadedMenu { get; set; }

    /// <summary>
    ///     The main icon displayed on the menu item.
    /// </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerMenuItemModel.cs
==========================================
Last Modified: 12/05/2024 13:23:06
Size: 311 bytes
------------------------------------------

using Blazicons;

namespace Bdziam.UI;

public class BDrawerMenuItemModel
{
    public string? Uri { get; set; }
    public string Text { get; set; }
    public SvgIcon? Icon { get; set; }
    public List<BDrawerMenuItemModel> Children { get; set; } = new();

    public int Order { get; set; }
}


==========================================
FILE: Components\Navigation\Drawer\BDrawerSeparator.razor
==========================================
Last Modified: 12/05/2024 13:22:42
Size: 215 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits BDrawerMenuItemBase
<div id="@Id" class="w-full my-2 @Class" style="height: 1px; background-color: var(--md-sys-color-surface)@(Style != null ? $";{Style}" : string.Empty)"></div>


==========================================
FILE: Components\Navigation\Drawer\BDrawerSeparator.razor.cs
==========================================
Last Modified: 12/05/2024 13:23:21
Size: 92 bytes
------------------------------------------

namespace Bdziam.UI;

public partial class BDrawerSeparator : BDrawerMenuItemBase
{
}


==========================================
FILE: Components\Navigation\Drawer\NavigationItemAttribute.cs
==========================================
Last Modified: 12/05/2024 13:22:58
Size: 1460 bytes
------------------------------------------

namespace Bdziam.UI;

[AttributeUsage(AttributeTargets.Class)]
public class NavigationItemAttribute : Attribute
{
    /// <summary>
    ///     Constructor for categories or items with no URI.
    /// </summary>
    public NavigationItemAttribute(string path, string? icon = null, int order = 0)
    {
        Path = path;
        IconString = icon;
    }

    /// <summary>
    ///     Constructor for items with a URI.
    /// </summary>
    public NavigationItemAttribute(string uri, string path, string? icon = null, int order = 0)
    {
        Uri = uri;
        Path = path;
        IconString = icon;
    }

    public int Order { get; set; } = 0;
    public string? Uri { get; }
    public string Path { get; }
    public string? IconString { get; }
    public string? SvgIconString => IsSvgIcon() ? ExtractSvgCode() : null;

    /// <summary>
    ///     Determines if the IconString is an SVG string.
    /// </summary>
    private bool IsSvgIcon()
    {
        return IconString?.StartsWith("svg(", StringComparison.OrdinalIgnoreCase) == true
               && IconString?.EndsWith(")") == true;
    }

    /// <summary>
    ///     Extracts the SVG code from the IconString if it represents an SVG.
    /// </summary>
    private string? ExtractSvgCode()
    {
        if (!IsSvgIcon()) return null;
        return IconString?.Substring(4, IconString.Length - 5); // Remove "svg(" and ")"
    }
}


==========================================
FILE: Components\Navigation\Drawer\NavigationService.cs
==========================================
Last Modified: 12/05/2024 13:22:44
Size: 2437 bytes
------------------------------------------

using System.Reflection;
using Bdziam.UI;
using Bdziam.UI.Extensions;

public class NavigationService
{
    public IEnumerable<BDrawerMenuItemModel> GetMenuHierarchy()
    {
        var menuItems = new List<BDrawerMenuItemModel>();

        // Find all classes with NavigationItemAttribute
        var navigationItems = AppDomain.CurrentDomain.GetAssemblies()
            .SelectMany(assembly => assembly.GetTypes())
            .Where(type => type.GetCustomAttribute<NavigationItemAttribute>() != null)
            .Select(attributeType => attributeType.GetCustomAttribute<NavigationItemAttribute>())
            .ToList(); // To avo


        return navigationItems
            .Where(item => !item.Path.Contains('/')) // Root-level items
            .Select(navigationItem =>
            {
                var resolvedIcon = SvgIconResolver.Resolve(navigationItem.IconString, navigationItem.SvgIconString);

                return new BDrawerMenuItemModel
                {
                    Text = navigationItem.Path,
                    Uri = navigationItem.Uri,
                    Icon = resolvedIcon,
                    Order = navigationItem.Order,
                    Children = GetChildren(navigationItem, navigationItems)
                };
            })
            .OrderBy(child => child.Order)
            .Reverse();
    }

    public List<BDrawerMenuItemModel> GetChildren(NavigationItemAttribute parent,
        List<NavigationItemAttribute> allItems)
    {
        var parentPath = parent.Path + "/";
        return allItems
            .Where(item => item.Path.StartsWith(parentPath) && item.Path != parent.Path) // Direct children
            .GroupBy(item => item.Path.Split('/')[parentPath.Split('/').Length - 1]) // Group by next path segment
            .Select(group =>
            {
                var firstItem = group.First();
                var resolvedIcon = SvgIconResolver.Resolve(firstItem.IconString, firstItem.SvgIconString);

                return new BDrawerMenuItemModel
                {
                    Text = group.Key,
                    Uri = firstItem.Uri,
                    Icon = resolvedIcon,
                    Order = firstItem.Order,
                    Children = GetChildren(firstItem, allItems)
                };
            })
            .OrderBy(child => child.Order)
            .ToList();
    }
}


==========================================
FILE: Components\Navigation\Tabs\BTab.razor
==========================================
Last Modified: 12/05/2024 13:23:13
Size: 81 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase


==========================================
FILE: Components\Navigation\Tabs\BTab.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:46
Size: 2104 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Blazicons;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BTab : BComponentBase
{
    [CascadingParameter] private BTabs? Parent { get; set; }

    [Parameter] public string Header { get; set; } = string.Empty;
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public SvgIcon? Icon { get; set; }
    [Parameter] public bool Disabled { get; set; } = false;

    private string textColor => Disabled ? ColorUtility.GetColorVariable(MaterialColor.TertiaryFixedDim) :
        IsActive ? ColorUtility.GetColorVariable(MaterialColor.Primary) :
        ColorUtility.GetTextColorVariable(MaterialColor.InverseOnSurface);

    public bool IsActive => Parent != null && Parent.ActiveTab == this;

    internal string TabStyles => new CssStyleBuilder()
        .AddStyle("display", "flex")
        .AddStyle("align-items", "center")
        .AddStyle("justify-content", "center")
        .AddStyle("padding", "0.5rem 1rem")
        .AddStyle("overflow", "hidden")
        .AddStyle("position", "relative")
        .AddStyle("color", textColor)
        .AddStyle("font-weight", Disabled ? "normal" : IsActive ? "semibold" : "normal")
        .AddStyle("border-radius", "0")
        .AddStyle("background-color", "transparent")
        .AddStyle("cursor", Disabled ? "not-allowed" : "pointer")
        .Build();

    public BRipple? Ripple { get; set; }
    public BPillRipple? PillRipple { get; set; }

    internal string TabTextStyle => new CssStyleBuilder()
        .AddStyle("color",
            IsActive ? "var(--md-sys-color-primary)" : "var(--md-sys-color-on-surface-variant)") // Updated text color
        .AddStyle("z-index", "3")
        .Build();

    protected override void OnInitialized()
    {
        Parent?.AddPage(this);
        base.OnInitialized();
    }

    private void HandleClick()
    {
        if (!Disabled && Parent != null) Parent.ActiveTab = this;
    }
}


==========================================
FILE: Components\Navigation\Tabs\BTabs.razor
==========================================
Last Modified: 12/06/2024 10:58:31
Size: 2427 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@using Bdziam.UI.Model.Utility
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<CascadingValue Value="this">
    @ChildContent
</CascadingValue>
<BContainer Id="@Id" SurfaceMaterialColor="MaterialColor.Surface" Padding="Size.None" BorderRadius="BorderRadius.None">
    <div id="@containerId" style="@GetTabsContainerStyles()">
        <div class="active-line" style="z-index: 999;position: absolute; bottom: 0; height: 3px; background-color: var(--md-sys-color-primary); transition: left 0.3s ease, width 0.3s ease;"></div>

        @foreach (var tab in Tabs)
        {
            <div style="@GetTabStyles(tab)" id="@GetTabId(tab)" @onclick="e => ActivateTab(tab, e)"         
                 draggable="true"
                 @ondragstart="e => OnDragStart(e, tab)"
                 @ondragover="OnDragOver"
                 @ondrop="e => OnDrop(e, tab)">
                @if (RippleVariant == RippleVariant.Surface)
                {
                    <BRipple @ref="@tab.Ripple"/>
                }

                <div class="@PillClass" style="@PillStyle">
                    @if (tab.Icon != null)
                    {
                        <Blazicon Svg="@tab.Icon" Attributes="@SizeUtility.GetIconSizeAttributes(TabIconSize, "z-index: 3")"/>
                    }
                    else
                    {
                        <div style="@($"width: {SizeUtility.GetIconSize(TabIconSize)}; height: {SizeUtility.GetIconSize(TabIconSize)};")"/>
                    }
                    <div class="@PillTextClass" style="@PillTextStyle">
                        @if (RippleVariant == RippleVariant.Pill)
                        {
                            <BPillRipple @ref="@tab.PillRipple" MaterialColor="MaterialColor.Primary" Scale="false" Behind="false" Style="@($"z-index: 1;width:{GetPillRipleWidth(tab)}px;top: -2%;opacity: 0.5;")" Hover="false"></BPillRipple>
                        }
                        <BText Typo="Typo.BodyMedium" Style="@tab.TabTextStyle">@tab.Header</BText>
                    </div>
                </div>
            </div>
        }
    </div>
    <BContainer SurfaceMaterialColor="MaterialColor.Surface" Padding="Size.Small">
        @if (ActiveTab != null)
        {
            @ActiveTab.ChildContent
        }
    </BContainer>

</BContainer>


==========================================
FILE: Components\Navigation\Tabs\BTabs.razor.cs
==========================================
Last Modified: 12/06/2024 10:59:10
Size: 6784 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Components.Tabs;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;

namespace Bdziam.UI;

public partial class BTabs : BComponentBase
{
    private readonly List<BTab> Tabs = new();

    private BTab? activeTab;
    private string containerId = $"tabs-container-{Guid.NewGuid().ToString()}";
    [Parameter] public RenderFragment ChildContent { get; set; } = default!;
    [Parameter] public TabVariant Variant { get; set; } = TabVariant.Primary;
    [Parameter] public Size TabIconSize { get; set; } = Size.Small;
    [Parameter] public bool DrawSeparator { get; set; } = false;
    [Parameter] public RippleVariant RippleVariant { get; set; } = RippleVariant.Pill;

    public BTab? ActiveTab
    {
        get => activeTab;
        set
        {
            if (activeTab != value)
            {
                activeTab = value;
                StateHasChanged();
            }
        }
    }
    private BTab? draggingTab; // Tracks the tab being dragged

    private void OnDragStart(DragEventArgs e, BTab tab)
    {
        draggingTab = tab;
        e.DataTransfer.DropEffect = "move";
    }

    private void OnDragOver(DragEventArgs e)
    {
        e.DataTransfer.DropEffect = "move";
    }

    private void OnDrop(DragEventArgs e, BTab targetTab)
    {
        if (draggingTab == null || draggingTab == targetTab) return;

        // Get current indexes of the dragged tab and target tab
        var draggingIndex = Tabs.IndexOf(draggingTab);
        var targetIndex = Tabs.IndexOf(targetTab);

        // Reorder the tabs
        if (draggingIndex != -1 && targetIndex != -1)
        {
            Tabs.RemoveAt(draggingIndex);
            Tabs.Insert(targetIndex, draggingTab);
        }

        // Reset dragging state
        draggingTab = null;

        StateHasChanged();
    }
    [Inject] private TabsService TabsService { get; set; } = default!;

    public string PillStyle => new CssStyleBuilder()
        .AddStyle("overflow", "hidden")
        .AddStyle("position", "relative")
        .AddStyle("display", "flex")
        .AddStyle("flex-direction", Variant == TabVariant.Primary ? "column" : "row")
        .AddStyle("border-radius", StyleUtility.GetRadiusStyle(BorderRadius.Pill))
        .Build();

    public string PillClass => new CssClassBuilder()
        .AddClass("pill px-4 py-1 items-center")
        .AddClass("gap-4", Variant == TabVariant.Secondary)
        .AddClass("gap-2", Variant == TabVariant.Primary)
        .Build();


    public string PillTextStyle => new CssStyleBuilder()
        .AddStyle("overflow", "hidden")
        .AddStyle("position", "relative")
        .AddStyle("display", "flex")
        .AddStyle("flex-direction", Variant == TabVariant.Primary ? "column" : "row")
        .AddStyle("border-radius", StyleUtility.GetRadiusStyle(BorderRadius.Pill))
        .Build();

    public string PillTextClass => new CssClassBuilder()
        .AddClass("pill px-4 items-center")
        .Build();

    internal void AddPage(BTab tab)
    {
        Tabs.Add(tab);
        if (Tabs.Count == 1)
            ActiveTab = tab;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Tabs.Count > 0)
            await ActivateTab(Tabs[0], new MouseEventArgs { ClientX = 50, ClientY = 50 });
    }

    private async Task ActivateTab(BTab tab, MouseEventArgs mouseEventArgs)
    {
        ActiveTab = tab;
        Tabs.ForEach(a =>
        {
            if (a.PillRipple != null) a.PillRipple.IsActive = false;
        });
        if (tab.Ripple != null) await tab.Ripple.CreateRipple(mouseEventArgs);
        if (tab.PillRipple != null) tab.PillRipple.Pulsate();

        // Update active line using TabsService
        var tabId = GetTabId(tab);

        await TabsService.UpdateActiveLineAsync(tabId, containerId, Variant == TabVariant.Primary);
        StateHasChanged();
    }

    private string GetTabId(BTab tab)
    {
        return $"tab-{Tabs.IndexOf(tab)}-{Id}";
    }

    private string GetTabStyles(BTab tab)
    {
        return new CssStyleBuilder()
            .AddStyle("flex-grow", "1")
            .AddStyle("flex-basis", "0")
            .AddStyle("text-align", "center")
            .AddStyle("padding", "0.5rem")
            .AddStyle("color",
                tab.IsActive
                    ? "var(--md-sys-color-primary)"
                    : "var(--md-sys-color-on-surface-variant)") // Updated icon color
            .Build(tab.TabStyles);
    }

    private string GetTabsContainerStyles()
    {
        return new CssStyleBuilder()
            .AddStyle("position", "relative")
            .AddStyle("display", "flex")
            .AddStyle("align-items", "stretch")
            .AddStyle("justify-content", "space-evenly")
            .AddStyle("gap", "0")
            .AddStyle("box-shadow", DrawSeparator ? "0px 1px 0px var(--md-sys-color-surface-variant)" : "none")
            .AddStyle("background-color", "var(--md-sys-color-surface)") // Updated background color
            .Build();
    }

    private string GetActiveLineStyles()
    {
        if (ActiveTab == null) return "width: 0; transform: scaleX(0);";

        var index = Tabs.IndexOf(ActiveTab);
        if (index == -1) return "width: 0; transform: scaleX(0);";

        // Calculate left offset and width based on the active tab
        var leftOffset = 0;
        for (var i = 0; i < index; i++) leftOffset += GetTabWidth(Tabs[i]);

        var activeWidth = GetTabWidth(ActiveTab);

        return new CssStyleBuilder()
            .AddStyle("left", $"{leftOffset}px")
            .AddStyle("width", $"{activeWidth}px")
            .AddStyle("transform", "scaleX(1)")
            .AddStyle("z-index", "222")
            .Build();
    }

    private int GetPillRipleWidth(BTab tab)
    {
        return tab.Icon != null ? GetTabWidth(tab) + 50 : GetTabWidth(tab) + 10;
    }

    private int GetPillRipleLeft(BTab tab)
    {
        return tab.Icon != null ? -GetPillRipleWidth(tab) / 10 : -GetPillRipleWidth(tab) / 5;
    }

    private int GetTabWidth(BTab tab)
    {
        // Calculate the width dynamically, e.g., using a measurement utility or predefined sizes.
        // Placeholder: adjust the width calculation to match actual tab measurements in pixels.
        var textLength = tab.Header?.Length ?? 0;
        return 8 * textLength + 16; // Example: 8px per character + 16px padding.
    }
}


==========================================
FILE: Components\Navigation\Tabs\TabsService.cs
==========================================
Last Modified: 12/05/2024 13:23:21
Size: 945 bytes
------------------------------------------

using Microsoft.JSInterop;

namespace Bdziam.UI.Components.Tabs;

public class TabsService : IAsyncDisposable
{
    private readonly IJSRuntime _jsRuntime;
    private IJSObjectReference? _module;

    public TabsService(IJSRuntime jsRuntime)
    {
        _jsRuntime = jsRuntime;
    }

    public async ValueTask DisposeAsync()
    {
        if (_module != null) await _module.DisposeAsync();
    }

    private async Task<IJSObjectReference> GetModuleAsync()
    {
        if (_module == null)
            _module = await _jsRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/Bdziam.UI/js/tabs.js");
        return _module;
    }

    public async Task UpdateActiveLineAsync(string tabId, string containerId, bool isPrimary = true)
    {
        var module = await GetModuleAsync();
        await module.InvokeVoidAsync("updateActiveLine", tabId, containerId, isPrimary);
    }
}


==========================================
FILE: Components\Navigation\BMenu.razor
==========================================
Last Modified: 11/26/2024 14:28:13
Size: 445 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div class="@MenuContainerClasses">
    <button id="@Id" class="@MenuButtonClasses" @onclick="ToggleMenu">
        @MenuButtonLabel
    </button>

    <BPopover IsOpen="@IsOpen" IsOpenChanged="@IsOpenChanged" TargetElementId="@Id">
        <div class="grid grid-cols-4 gap-4 p-4 bg-surface">
            @MenuItems
        </div>
    </BPopover>
</div>


==========================================
FILE: Components\Navigation\BMenu.razor.cs
==========================================
Last Modified: 12/05/2024 13:23:12
Size: 879 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BMenu : BComponentBase
{
    private string _menuButtonId = Guid.NewGuid().ToString();
    [Parameter] public string MenuButtonLabel { get; set; } = "Menu";
    [Parameter] public bool IsOpen { get; set; }
    [Parameter] public EventCallback<bool> IsOpenChanged { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public RenderFragment? MenuItems { get; set; }
    private string MenuButtonClasses => "bg-secondary text-secondary-text py-2 px-4 rounded cursor-pointer";
    private string MenuContainerClasses => "relative inline-block " + Class;

    private void ToggleMenu()
    {
        IsOpen = !IsOpen;
        IsOpenChanged.InvokeAsync(IsOpen);
        StateHasChanged();
    }
}


==========================================
FILE: Components\Navigation\BTopBar.razor
==========================================
Last Modified: 12/06/2024 13:29:19
Size: 677 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@using Bdziam.UI.Utilities
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<BContainer Padding="Size.None" BorderRadius="BorderRadius.None" Elevation="@Elevation" SurfaceMaterialColor="Color" Class="@("flex items-center justify-between color-primary-text transition-all ease-in-out transition-colors " + Class)" style="@ContainerStyles">
    <div class="flex items-left space-x-4">
        @LeftContent
    </div>
    <div class="flex items-center justify-center  space-x-4">
        @MiddleContent
    </div>
    <div class="flex items-right space-x-4">
        @RightContent
    </div>
</BContainer>


==========================================
FILE: Components\Navigation\BTopBar.razor.cs
==========================================
Last Modified: 12/06/2024 13:30:11
Size: 852 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BTopBar : BComponentBase, IControlColor
{
    [Parameter] public RenderFragment? LeftContent { get; set; }
    [Parameter] public RenderFragment? MiddleContent { get; set; }
    [Parameter] public RenderFragment? RightContent { get; set; }
    [Parameter] public Size Size { get; set; } = Size.Medium;
    [Parameter] public int Elevation { get; set; } = 0;

    private string ContainerStyles => new CssStyleBuilder()
        .AddStyle("padding", StyleUtility.GetPadding(Size))
        .AddStyle("height", StyleUtility.GetStaticHeight(Size))
        .Build(Style);

    [Parameter] public MaterialColor Color { get; set; } = MaterialColor.Primary;
}


==========================================
FILE: Components\Popover\BPopover.razor
==========================================
Last Modified: 11/26/2024 14:28:13
Size: 203 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
@if (IsOpen)
{
    <div id="@Id" class="@PopoverClasses" style="@PopoverStyles">
        @ChildContent
    </div>
}


==========================================
FILE: Components\Popover\BPopover.razor.cs
==========================================
Last Modified: 12/09/2024 15:51:02
Size: 4167 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Components.Popover;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Model.Utility;
using Bdziam.UI.Theming;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;
using Microsoft.JSInterop;

namespace Bdziam.UI;

public partial class BPopover : BComponentBase, IAsyncDisposable, IControlElevation
{
    private DotNetObjectReference<BPopover> _dotNetRef;
    private bool _isOpen;
    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public Size Padding { get; set; } = Size.Medium;
    [Parameter]
    public bool IsOpen
    {
        get => _isOpen;
        set
        {
            if (_isOpen != value)
            {
                _isOpen = value;
                IsOpenChanged.InvokeAsync(value);
                StateHasChanged();
            }
        }
    }

    [Parameter] public EventCallback<bool> IsOpenChanged { get; set; }
    [Parameter] public string TargetElementId { get; set; }
    [Parameter] public Position Position { get; set; } = Position.Bottom;
    [Parameter] public Size MarginSize { get; set; } = Size.None;
    [Parameter] public bool MatchWidth { get; set; } = false;
    [Inject] private PopoverService PopoverService { get; set; }
    [Inject] private ThemeService ThemeService { get; set; }

    private string PopoverClasses => new CssClassBuilder()
        .AddClass("bd-popover")
        .AddClass("transition-all ease-in-out")
        .AddClass("transition-opacity transform")
        .AddClass(IsOpen ? "opacity-100" : "opacity-0")
        .AddClass(Class)
        .Build();

    private string PopoverStyles => new CssStyleBuilder()
        .AddStyle("position", "absolute")
        .AddStyle("display", "inline-block")
        .AddStyle("z-index", "1000")
        .AddStyle("overflow", "hidden")
        .AddStyle("background-color", ColorUtility.GetSurfaceColorVariable(Elevation))
        .AddStyle("color", ColorUtility.GetTextColorVariable(MaterialColor.Surface))
        .AddStyle("box-shadow", "0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.06);") // Elevation
        .AddStyle("border-radius", "12px") // Rounded corners
        .AddStyle("padding", SizeUtility.GetPadding(Padding)) // Padding for content
        .AddStyle("transition", "opacity 0.2s ease, transform 0.2s ease") // Smooth transitions
        .AddStyle("opacity", IsOpen ? "1" : "0") // Show/Hide animation
        .AddStyle("transform", IsOpen ? "scale(1)" : "scale(0.95)") // Scale effect for open/close
        .Build() + ";" + Style;

    public async ValueTask DisposeAsync()
    {
        await PopoverService.ClosePopoverAsync(Id);

        if (_dotNetRef != null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }
    }

    [Parameter] public int Elevation { get; set; } = 0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsOpen)
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);
            await PopoverService.InitializePopoverAsync(Id, TargetElementId, GetOptions(), _dotNetRef, MatchWidth);
        }
        else
        {
            if (_dotNetRef != null)
            {
                _dotNetRef.Dispose();
                _dotNetRef = null;
            }

            await PopoverService.ClosePopoverAsync(Id);
        }
    }

    private object GetOptions()
    {
        return new
        {
            position = Position.ToString().ToLower(),
            margin = GetMarginValue(MarginSize)
        };
    }

    private double GetMarginValue(Size marginSize)
    {
        return marginSize switch
        {
            Size.None => 0,
            Size.Small => 4,
            Size.Medium => 8,
            Size.Large => 16,
            Size.ExtraLarge => 32,
            _ => 0
        };
    }

    [JSInvokable]
    public async Task OnOutsideClick()
    {
        IsOpen = false;
        await IsOpenChanged.InvokeAsync(IsOpen);
        await InvokeAsync(StateHasChanged);
    }
}


==========================================
FILE: Components\Popover\PopoverService.cs
==========================================
Last Modified: 12/06/2024 19:36:01
Size: 1296 bytes
------------------------------------------

using Microsoft.JSInterop;

namespace Bdziam.UI.Components.Popover;

public class PopoverService : IAsyncDisposable
{
    private readonly IJSRuntime _jsRuntime;
    private IJSObjectReference _module;

    public PopoverService(IJSRuntime jsRuntime)
    {
        _jsRuntime = jsRuntime;
    }

    public async ValueTask DisposeAsync()
    {
        if (_module != null)
        {
            await _module.InvokeVoidAsync("dispose");
            await _module.DisposeAsync();
        }
    }

    private async Task<IJSObjectReference> GetModuleAsync()
    {
        if (_module == null)
            _module = await _jsRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/Bdziam.UI/js/popover.js");
        return _module;
    }

    public async Task InitializePopoverAsync(string popoverId, string targetId, object options,
        DotNetObjectReference<BPopover> dotNetRef, bool matchWidth)
    {
        var module = await GetModuleAsync();
        await module.InvokeVoidAsync("initializePopover", popoverId, targetId, options, dotNetRef, matchWidth);
    }

    public async Task ClosePopoverAsync(string popoverId)
    {
        if (_module != null) await _module.InvokeVoidAsync("closePopover", popoverId);
    }
}


==========================================
FILE: Components\Progress\BProgress.razor
==========================================
Last Modified: 12/09/2024 18:20:57
Size: 739 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BComponentBase

@if (Variant == ProgressIndicatorVariant.Linear)
{
    <div id="@Id" class="progress" style="@ProgressContainerStyles">
        @if (Indeterminate)
        {
            <div class="indeterminate" style="@IndeterminateStyles"></div>
        }
        else
        {
            <div class="determinate" style="@DeterminateStyles"></div>
        }
    </div>
}
else if (Variant == ProgressIndicatorVariant.Circular)
{
    <svg class="circular" style="@CircularContainerStyles" viewBox="25 25 50 50">
        <circle class="path" cx="50" cy="50" r="20" fill="none" style="@CircularPathStyles" />
    </svg>
}


==========================================
FILE: Components\Progress\BProgress.razor.cs
==========================================
Last Modified: 12/09/2024 18:23:05
Size: 2551 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BProgress : BComponentBase
{
    [Parameter] public ProgressIndicatorVariant Variant { get; set; } = ProgressIndicatorVariant.Linear;
    [Parameter] public bool Indeterminate { get; set; } = false;
    [Parameter] public double Progress { get; set; } = 0; // For determinate progress
    [Parameter] public MaterialColor IndicatorColor { get; set; } = MaterialColor.Primary;

    // Styles
    protected string ProgressContainerStyles => new CssStyleBuilder()
        .AddStyle("height", Variant == ProgressIndicatorVariant.Linear ? "4px" : "100px")
        .AddStyle("width", "100%")
        .AddStyle("background-color", Variant == ProgressIndicatorVariant.Linear ? ColorUtility.GetColorVariable(MaterialColor.SecondaryContainer) : "transparent")
        .AddStyle("border-radius", "2px", Variant == ProgressIndicatorVariant.Linear)
        .Build();

    protected string DeterminateStyles => new CssStyleBuilder()
        .AddStyle("width", $"{Math.Clamp(Progress*100, 0, 100)}%")
        .AddStyle("height", "100%")
        .AddStyle("background-color", ColorUtility.GetColorVariable(IndicatorColor))
        .AddStyle("transition", "width 0.3s linear")
        .Build();

    protected string IndeterminateStyles => new CssStyleBuilder()
        .AddStyle("position", "absolute")
        .AddStyle("background-color", ColorUtility.GetColorVariable(IndicatorColor))
        .AddStyle("animation", "indeterminate 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite")
        .Build();

    protected string CircularContainerStyles => new CssStyleBuilder()
        .AddStyle("animation", Indeterminate ? "rotate 2s linear infinite" : "none")
        .AddStyle("width", "48px")
        .AddStyle("height", "48px")
        .Build();

    protected string CircularPathStyles => new CssStyleBuilder()
        .AddStyle("stroke", ColorUtility.GetColorVariable(IndicatorColor))
        .AddStyle("stroke-dasharray", Indeterminate ? "1, 200" : $"{Math.PI * 2 * 20}, 200") // Progress in determinate mode
        .AddStyle("stroke-dashoffset", Indeterminate ? "0" : $"{Math.Clamp(1 - Progress / 100, 0, 1) * Math.PI * 2 * 20}")
        .AddStyle("stroke-width", "3")
        .AddStyle("stroke-linecap", "round")
        .AddStyle("animation", Indeterminate ? "dash 1.5s ease-in-out infinite" : "none")
        .Build();
}



==========================================
FILE: Components\Tooltip\BTooltip.razor
==========================================
Last Modified: 12/05/2024 13:23:16
Size: 480 bytes
------------------------------------------

@namespace Bdziam.UI
@using Bdziam.UI.Model.Enums
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<div>
    <div id="@TooltipTargetId" @onmouseover="ShowTooltip" @onmouseout="HideTooltip" style="display: inline-block;">
        @ChildContent
    </div>

    <BPopover TargetElementId="@TooltipTargetId" IsOpen="@IsTooltipVisible" Position="@Position" MarginSize="Size.Small">
        <BText Typo="Typo.LabelSmall">@TooltipText</BText>
    </BPopover>
</div>


==========================================
FILE: Components\Tooltip\BTooltip.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:51
Size: 1504 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BTooltip : BComponentBase, IControlChildContent, IControlColor
{
    [Parameter] public string TooltipText { get; set; } = string.Empty;
    [Parameter] public Position Position { get; set; } = Position.Bottom;
    private string TooltipTargetId { get; } = $"tooltip-target-{Guid.NewGuid()}";
    private bool IsTooltipVisible { get; set; }

    private string TooltipStyles => new CssStyleBuilder()
        .AddStyle("padding", "8px")
        .AddStyle("font-size", "0.875rem")
        .AddStyle("line-height", "1.25rem")
        .AddStyle("color", ColorUtility.GetTextColorVariable(Color))
        .AddStyle("background-color", ColorUtility.GetContainerColorVariable(Color))
        .AddStyle("border-radius", "4px")
        .AddStyle("box-shadow", "0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.06);")
        .Build();

    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public MaterialColor Color { get; set; }


    private void ShowTooltip()
    {
        if (string.IsNullOrEmpty(TooltipText)) return;
        IsTooltipVisible = true;
        StateHasChanged();
    }

    private void HideTooltip()
    {
        if (string.IsNullOrEmpty(TooltipText)) return;
        IsTooltipVisible = false;
        StateHasChanged();
    }
}


==========================================
FILE: Components\Typography\BMarkdown.razor
==========================================
Last Modified: 12/09/2024 17:40:49
Size: 311 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase

<div id="@Id" class="@Class" style="@Style">
    @if (RenderedMarkdownLines != null)
    {
        @foreach (var (line, typo) in RenderedMarkdownLines)
        {
            @((MarkupString)line)
        }
    }
</div>


==========================================
FILE: Components\Typography\BMarkdown.razor.cs
==========================================
Last Modified: 12/09/2024 17:30:56
Size: 3537 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Markdig;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.AspNetCore.Components.RenderTree;

namespace Bdziam.UI;

public partial class BMarkdown : BComponentBase
{
    private static readonly MarkdownPipeline Pipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();

    private List<(string Line, Typo Typo)>? RenderedMarkdownLines;

    [Parameter] public RenderFragment? ChildContent { get; set; }

    private string? MarkdownContent { get; set; }

    protected override void OnParametersSet()
    {
        if (ChildContent != null)
        {
            // Render the child content into a string
            using var writer = new StringWriter();
            var renderer = new RenderTreeBuilder();
            ChildContent(renderer);
            var renderedTree = renderer.GetFrames();
            foreach (var frame in renderedTree.Array)
            {
                if (frame.FrameType == RenderTreeFrameType.Markup)
                {
                    MarkdownContent += frame.TextContent.Replace("\r", "")[1..];
                }
            }
        }

        // Parse Markdown if content is provided
        if (!string.IsNullOrWhiteSpace(MarkdownContent))
        {
            var renderedMarkdown = Markdown.ToHtml(MarkdownContent, Pipeline);
            RenderedMarkdownLines = ParseMarkdown(renderedMarkdown);
        }
    }

    private List<(string Line, Typo Typo)> ParseMarkdown(string renderedMarkdown)
    {
        var lines = renderedMarkdown.Split('\n');
        var parsedLines = new List<(string Line, Typo Typo)>();

        foreach (var line in lines)
        {
            var trimmedLine = line.Trim();
            if (string.IsNullOrWhiteSpace(trimmedLine)) continue;

            // Use regex to detect heading tags with or without attributes
            if (Regex.IsMatch(trimmedLine, @"^<h1.*?>"))
                parsedLines.Add((ExtractContent(trimmedLine, "h1"), Typo.DisplayLarge));
            else if (Regex.IsMatch(trimmedLine, @"^<h2.*?>"))
                parsedLines.Add((ExtractContent(trimmedLine, "h2"), Typo.DisplayMedium));
            else if (Regex.IsMatch(trimmedLine, @"^<h3.*?>"))
                parsedLines.Add((ExtractContent(trimmedLine, "h3"), Typo.DisplaySmall));
            else if (Regex.IsMatch(trimmedLine, @"^<h4.*?>"))
                parsedLines.Add((ExtractContent(trimmedLine, "h4"), Typo.HeadlineLarge));
            else if (Regex.IsMatch(trimmedLine, @"^<h5.*?>"))
                parsedLines.Add((ExtractContent(trimmedLine, "h5"), Typo.HeadlineMedium));
            else if (Regex.IsMatch(trimmedLine, @"^<h6.*?>"))
                parsedLines.Add((ExtractContent(trimmedLine, "h6"), Typo.HeadlineSmall));
            else
                // Default for non-headings
                parsedLines.Add((trimmedLine, Typo.BodyMedium));
        }

        return parsedLines;
    }

    private string ExtractContent(string htmlLine, string tag)
    {
        // Use regex to extract content between opening and closing tags
        var regex = new Regex($"<{tag}.*?>(.*?)</{tag}>", RegexOptions.Singleline);
        var match = regex.Match(htmlLine);

        return match.Success ? match.Groups[1].Value : htmlLine;
    }
}



==========================================
FILE: Components\Typography\BText.razor
==========================================
Last Modified: 12/05/2024 08:34:23
Size: 160 bytes
------------------------------------------

@namespace Bdziam.UI
@inherits Bdziam.UI.Components.CommonBase.BComponentBase
<p id="@Id" class="@Class" style="@TypographyStyle">
    @ChildContent
</p>


==========================================
FILE: Components\Typography\BText.razor.cs
==========================================
Last Modified: 12/06/2024 08:58:27
Size: 3306 bytes
------------------------------------------

using Bdziam.UI.Components.CommonBase;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BText : BComponentBase, IControlColor, IControlElevation
{
    [Parameter] public Typo Typo { get; set; } = Typo.BodyMedium;
    [Parameter] public bool IsSurface { get; set; } = true;
    [Parameter] public RenderFragment? ChildContent { get; set; }

    private string TypographyStyle => new CssStyleBuilder()
        .AddStyle(GetTypographyBaseStyles())
        .AddStyle("color", IsSurface ? ColorUtility.GetTextColorVariable(Color) : ColorUtility.GetColorVariable(Color))
        .Build(Style);

    [Parameter] public MaterialColor Color { get; set; } = MaterialColor.Background;
    [Parameter] public int Elevation { get; set; }

    private string GetTypographyBaseStyles()
    {
        return Typo switch
        {
            Typo.DisplayLarge =>
                "font-family: Roboto; font-weight: 400; font-size: 57pt; letter-spacing: -0.25pt; line-height: 64pt;",
            Typo.DisplayMedium =>
                "font-family: Roboto; font-weight: 400; font-size: 45pt; letter-spacing: 0pt; line-height: 52pt;",
            Typo.DisplaySmall =>
                "font-family: Roboto; font-weight: 400; font-size: 36pt; letter-spacing: 0pt; line-height: 44pt;",
            Typo.HeadlineLarge =>
                "font-family: Roboto; font-weight: 400; font-size: 32pt; letter-spacing: 0pt; line-height: 40pt;",
            Typo.HeadlineMedium =>
                "font-family: Roboto; font-weight: 400; font-size: 28pt; letter-spacing: 0pt; line-height: 36pt;",
            Typo.HeadlineSmall =>
                "font-family: Roboto; font-weight: 400; font-size: 24pt; letter-spacing: 0pt; line-height: 32pt;",
            Typo.TitleLarge =>
                "font-family: Roboto; font-weight: 400; font-size: 22pt; letter-spacing: 0pt; line-height: 28pt;",
            Typo.TitleMedium =>
                "font-family: Roboto; font-weight: 500; font-size: 16pt; letter-spacing: 0.15pt; line-height: 24pt;",
            Typo.TitleSmall =>
                "font-family: Roboto; font-weight: 500; font-size: 14pt; letter-spacing: 0.1pt; line-height: 20pt;",
            Typo.BodyLarge =>
                "font-family: Roboto; font-weight: 400; font-size: 16pt; letter-spacing: 0.5pt; line-height: 24pt;",
            Typo.BodyMedium =>
                "font-family: Roboto; font-weight: 400; font-size: 14pt; letter-spacing: 0.25pt; line-height: 20pt;",
            Typo.BodySmall =>
                "font-family: Roboto; font-weight: 400; font-size: 12pt; letter-spacing: 0.4pt; line-height: 16pt;",
            Typo.LabelLarge =>
                "font-family: Roboto; font-weight: 500; font-size: 14pt; letter-spacing: 0.1pt; line-height: 20pt;",
            Typo.LabelMedium =>
                "font-family: Roboto; font-weight: 500; font-size: 12pt; letter-spacing: 0.5pt; line-height: 16pt;",
            Typo.LabelSmall =>
                "font-family: Roboto; font-weight: 500; font-size: 11pt; letter-spacing: 0.5pt; line-height: 16pt;",
            _ => "font-family: Roboto; font-weight: 400; font-size: 14pt; line-height: 20pt;"
        };
    }
}


==========================================
FILE: Enums\BorderRadius.cs
==========================================
Last Modified: 11/26/2024 14:28:13
Size: 127 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum BorderRadius
{
    None,
    Small,
    Medium,
    Large,
    Pill
}


==========================================
FILE: Enums\ButtonVariant.cs
==========================================
Last Modified: 11/26/2024 14:28:13
Size: 122 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum ButtonVariant
{
    Normal,
    Gradient,
    Outline,
    Text
}


==========================================
FILE: Enums\DrawerMode.cs
==========================================
Last Modified: 11/26/2024 14:28:13
Size: 93 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum DrawerMode
{
    Overlap,
    Shrink
}


==========================================
FILE: Enums\DrawerPosition.cs
==========================================
Last Modified: 11/26/2024 14:28:13
Size: 93 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum DrawerPosition
{
    Left,
    Right
}


==========================================
FILE: Enums\FieldVariant.cs
==========================================
Last Modified: 12/05/2024 08:34:23
Size: 95 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum FieldVariant
{
    Filled,
    Outline
}


==========================================
FILE: Enums\IControlElevation.cs
==========================================
Last Modified: 11/30/2024 10:54:18
Size: 119 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public interface IControlElevation
{
    public int Elevation { get; set; }
}


==========================================
FILE: Enums\InputType.cs
==========================================
Last Modified: 12/06/2024 07:41:00
Size: 213 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum InputType
{
    Text,
    Color,
    Date,
    DatetimeLocal,
    Email,
    Month,
    Number,
    Password,
    Tel,
    Time,
    Url,
    Week
}


==========================================
FILE: Enums\MaterialColor.cs
==========================================
Last Modified: 12/05/2024 13:23:18
Size: 2048 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum MaterialColor
{
    // Palette key colors
    PrimaryPaletteKeyColor,
    SecondaryPaletteKeyColor,
    TertiaryPaletteKeyColor,
    NeutralPaletteKeyColor,
    NeutralVariantPaletteKeyColor,

    // Background, surface, and container colors
    Background,
    OnBackground,
    Surface,
    SurfaceDim,
    SurfaceBright,
    SurfaceContainerLowest,
    SurfaceContainerLow,
    SurfaceContainer,
    SurfaceContainerHigh,
    SurfaceContainerHighest,
    OnSurface,
    SurfaceVariant,
    OnSurfaceVariant,
    InverseSurface,
    InverseOnSurface,

    // Outline, shadow, and tint colors
    Outline,
    OutlineVariant,
    Shadow,
    Scrim,
    SurfaceTint,

    // Primary colors
    Primary,
    OnPrimary,
    PrimaryContainer,
    OnPrimaryContainer,
    InversePrimary,

    // Secondary colors
    Secondary,
    OnSecondary,
    SecondaryContainer,
    OnSecondaryContainer,

    // Tertiary colors
    Tertiary,
    OnTertiary,
    TertiaryContainer,
    OnTertiaryContainer,

    // Error colors
    Error,
    OnError,
    ErrorContainer,
    OnErrorContainer,

    // Warning colors
    Warning,
    OnWarning,
    WarningContainer,
    OnWarningContainer,

    // Info colors
    Info,
    OnInfo,
    InfoContainer,
    OnInfoContainer,

    // Success colors
    Success,
    OnSuccess,
    SuccessContainer,
    OnSuccessContainer,

    // Fixed colors
    PrimaryFixed,
    PrimaryFixedDim,
    OnPrimaryFixed,
    OnPrimaryFixedVariant,
    SecondaryFixed,
    SecondaryFixedDim,
    OnSecondaryFixed,
    OnSecondaryFixedVariant,
    TertiaryFixed,
    TertiaryFixedDim,
    OnTertiaryFixed,
    OnTertiaryFixedVariant,

    // Controls and text
    ControlActivated,
    ControlNormal,
    ControlHighlight,
    TextPrimaryInverse,
    TextSecondaryAndTertiaryInverse,
    TextPrimaryInverseDisableOnly,
    TextSecondaryAndTertiaryInverseDisabled,
    TextHintInverse
}


==========================================
FILE: Enums\Motion.cs
==========================================
Last Modified: 12/05/2024 13:23:04
Size: 330 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum Motion
{
    EasingEmphasized,
    EasingEmphasizedAccelerate,
    EasingEmphasizedDecelerate,
    EasingLegacy,
    EasingLegacyAccelerate,
    EasingLegacyDecelerate,
    EasingLinear,
    EasingStandard,
    EasingStandardAccelerate,
    EasingStandardDecelerate
}


==========================================
FILE: Enums\Orientation.cs
==========================================
Last Modified: 12/05/2024 13:22:32
Size: 99 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum Orientation
{
    Vertical,
    Horizontal
}


==========================================
FILE: Enums\Position.cs
==========================================
Last Modified: 12/05/2024 13:22:29
Size: 110 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum Position
{
    Top,
    Bottom,
    Left,
    Right
}


==========================================
FILE: Enums\ProgressIndicatorVariant.cs
==========================================
Last Modified: 12/09/2024 16:40:18
Size: 110 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum ProgressIndicatorVariant
{
    Circular,
    Linear
}



==========================================
FILE: Enums\RippleVariant.cs
==========================================
Last Modified: 11/29/2024 07:52:37
Size: 94 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum RippleVariant
{
    Surface,
    Pill
}


==========================================
FILE: Enums\SpacingSize.cs
==========================================
Last Modified: 12/05/2024 13:23:17
Size: 145 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum Size
{
    None = 0,
    Small = 1,
    Medium = 2,
    Large = 4,
    ExtraLarge = 8
}


==========================================
FILE: Enums\TabVariant.cs
==========================================
Last Modified: 11/28/2024 13:54:08
Size: 96 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

public enum TabVariant
{
    Primary,
    Secondary
}


==========================================
FILE: Enums\Typo.cs
==========================================
Last Modified: 12/05/2024 13:22:58
Size: 1843 bytes
------------------------------------------

namespace Bdziam.UI.Model.Enums;

/// <summary>
///     Represents typography styles with corresponding font sizes and weights.
/// </summary>
public enum Typo
{
    // Display Styles
    /// <summary>Display Large: Font Size 57pt, Font Weight 400 (Normal).</summary>
    DisplayLarge,

    /// <summary>Display Medium: Font Size 45pt, Font Weight 400 (Normal).</summary>
    DisplayMedium,

    /// <summary>Display Small: Font Size 36pt, Font Weight 400 (Normal).</summary>
    DisplaySmall,

    // Headline Styles
    /// <summary>Headline Large: Font Size 32pt, Font Weight 400 (Normal).</summary>
    HeadlineLarge,

    /// <summary>Headline Medium: Font Size 28pt, Font Weight 400 (Normal).</summary>
    HeadlineMedium,

    /// <summary>Headline Small: Font Size 24pt, Font Weight 400 (Normal).</summary>
    HeadlineSmall,

    // Title Styles
    /// <summary>Title Large: Font Size 22pt, Font Weight 400 (Normal).</summary>
    TitleLarge,

    /// <summary>Title Medium: Font Size 16pt, Font Weight 500 (Medium).</summary>
    TitleMedium,

    /// <summary>Title Small: Font Size 14pt, Font Weight 500 (Medium).</summary>
    TitleSmall,

    // Body Styles
    /// <summary>Body Large: Font Size 16pt, Font Weight 400 (Normal).</summary>
    BodyLarge,

    /// <summary>Body Medium: Font Size 14pt, Font Weight 400 (Normal).</summary>
    BodyMedium,

    /// <summary>Body Small: Font Size 12pt, Font Weight 400 (Normal).</summary>
    BodySmall,

    // Label Styles
    /// <summary>Label Large: Font Size 14pt, Font Weight 500 (Medium).</summary>
    LabelLarge,

    /// <summary>Label Medium: Font Size 12pt, Font Weight 500 (Medium).</summary>
    LabelMedium,

    /// <summary>Label Small: Font Size 11pt, Font Weight 500 (Medium).</summary>
    LabelSmall
}


==========================================
FILE: Extensions\BdziamExtensions.cs
==========================================
Last Modified: 12/05/2024 13:22:24
Size: 675 bytes
------------------------------------------

using Bdziam.UI.Components.Popover;
using Bdziam.UI.Components.Tabs;
using Bdziam.UI.Interop;
using Bdziam.UI.Services;
using Bdziam.UI.Theming;
using Blazored.LocalStorage;
using Microsoft.Extensions.DependencyInjection;

namespace Bdziam.UI.Extensions;

public static class BdziamExtensions
{
    public static IServiceCollection AddBdziamUiServices(this IServiceCollection services)
    {
        return services.AddScoped<ThemeService>().AddScoped<PopoverService>().AddScoped<TabsService>()
            .AddScoped<ElementSizeService>().AddScoped<NavigationService>().AddScoped<BackgroundColorService>()
            .AddBlazoredLocalStorage();
    }
}


==========================================
FILE: Extensions\SvgIconExtensions.cs
==========================================
Last Modified: 12/05/2024 13:23:16
Size: 1616 bytes
------------------------------------------

using System.Reflection;
using Blazicons;

namespace Bdziam.UI.Extensions;

public static class SvgIconResolver
{
    /// <summary>
    ///     Resolves an icon name to either GoogleMaterialFilledIcon or MdiIcon.
    /// </summary>
    /// <param name="iconName">The name of the icon (e.g., "Home", "DotsGrid").</param>
    /// <returns>The resolved SvgIcon, or null if not found.</returns>
    public static SvgIcon? Resolve(string? iconName, string? svgIconContent = null)
    {
        if (svgIconContent != null) return SvgIcon.FromContent(svgIconContent);

        if (string.IsNullOrWhiteSpace(iconName))
            return null;

        // Try to resolve from GoogleMaterialFilledIcon
        var googleIcon = ResolveFromNamespace(typeof(GoogleMaterialFilledIcon), iconName);
        if (googleIcon != null)
            return googleIcon;

        // Fallback to MdiIcon
        return ResolveFromNamespace(typeof(MdiIcon), iconName);
    }

    /// <summary>
    ///     Resolves an icon from a specific namespace.
    /// </summary>
    /// <param name="namespaceName">The namespace to search (e.g., "Blazicons.GoogleMaterialFilledIcon").</param>
    /// <param name="iconName">The name of the icon.</param>
    /// <returns>The resolved SvgIcon, or null if not found.</returns>
    private static SvgIcon? ResolveFromNamespace(Type type, string iconName)
    {
        if (type == null)
            return null;

        var field = type.GetProperty(iconName, BindingFlags.Public | BindingFlags.Static);
        return field?.GetValue(null) as SvgIcon;
    }
}


==========================================
FILE: Interop\BackgroundColorService.cs
==========================================
Last Modified: 12/05/2024 13:23:17
Size: 1008 bytes
------------------------------------------

using Microsoft.JSInterop;

namespace Bdziam.UI.Services;

public class BackgroundColorService : IAsyncDisposable
{
    private readonly IJSRuntime _jsRuntime;
    private IJSObjectReference? _module;

    public BackgroundColorService(IJSRuntime jsRuntime)
    {
        _jsRuntime = jsRuntime;
    }

    // Dispose the JS module
    public async ValueTask DisposeAsync()
    {
        if (_module != null) await _module.DisposeAsync();
    }

    // Load the JS module
    private async Task<IJSObjectReference> GetModuleAsync()
    {
        if (_module == null)
            _module = await _jsRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/Bdziam.UI/js/background-color.js");
        return _module;
    }

    public async Task<string> GetBackgroundColorFromPointAsync(double x, double y)
    {
        var module = await GetModuleAsync();
        return await module.InvokeAsync<string>("getBackgroundColorFromPoint", x, y);
    }
}


==========================================
FILE: Interop\DOMRect.cs
==========================================
Last Modified: 12/05/2024 13:23:01
Size: 1818 bytes
------------------------------------------

namespace Bdziam.UI.Interop;

/// <summary>
///     Represents a rectangle with position and size in the DOM.
/// </summary>
public class DOMRect
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DOMRect" /> class.
    /// </summary>
    public DOMRect()
    {
    }

    /// <summary>
    ///     Initializes a new instance of the <see cref="DOMRect" /> class with specified properties.
    /// </summary>
    public DOMRect(double x, double y, double width, double height, double right, double bottom)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
        Right = right;
        Bottom = bottom;
    }

    /// <summary>
    ///     The x-coordinate of the rectangle's origin (left side).
    /// </summary>
    public double X { get; set; }

    /// <summary>
    ///     The y-coordinate of the rectangle's origin (top side).
    /// </summary>
    public double Y { get; set; }

    /// <summary>
    ///     The width of the rectangle.
    /// </summary>
    public double Width { get; set; }

    /// <summary>
    ///     The height of the rectangle.
    /// </summary>
    public double Height { get; set; }

    /// <summary>
    ///     The x-coordinate of the rectangle's right edge (X + Width).
    /// </summary>
    public double Right { get; set; }

    /// <summary>
    ///     The y-coordinate of the rectangle's bottom edge (Y + Height).
    /// </summary>
    public double Bottom { get; set; }

    /// <summary>
    ///     Returns a string representation of the DOMRect instance.
    /// </summary>
    public override string ToString()
    {
        return $"DOMRect (X: {X}, Y: {Y}, Width: {Width}, Height: {Height}, Right: {Right}, Bottom: {Bottom})";
    }
}


==========================================
FILE: Interop\ElementPosition.cs
==========================================
Last Modified: 12/05/2024 13:22:52
Size: 223 bytes
------------------------------------------

namespace Bdziam.UI.Interop;

public class ElementPosition
{
    public double Top { get; set; }
    public double Left { get; set; }
    public double Width { get; set; }
    public double Height { get; set; }
}


==========================================
FILE: Interop\ElementSize.cs
==========================================
Last Modified: 12/05/2024 13:23:20
Size: 144 bytes
------------------------------------------

namespace Bdziam.UI.Interop;

public class ElementSize
{
    public double Width { get; set; }
    public double Height { get; set; }
}


==========================================
FILE: Interop\ElementSizeService.cs
==========================================
Last Modified: 12/05/2024 13:23:13
Size: 1435 bytes
------------------------------------------

using Microsoft.JSInterop;

namespace Bdziam.UI.Interop;

public class ElementSizeService : IAsyncDisposable
{
    private readonly IJSRuntime _jsRuntime;
    private IJSObjectReference? _module;

    public ElementSizeService(IJSRuntime jsRuntime)
    {
        _jsRuntime = jsRuntime;
    }

    public async ValueTask DisposeAsync()
    {
        if (_module != null) await _module.DisposeAsync();
    }

    private async Task<IJSObjectReference> GetModuleAsync()
    {
        if (_module == null)
            _module = await _jsRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/Bdziam.UI/js/element-size.js");
        return _module;
    }

    /// <summary>
    ///     Gets the size of an HTML element by its ID.
    /// </summary>
    /// <param name="elementId">The ID of the HTML element.</param>
    /// <returns>A tuple containing the width and height of the element, or null if not found.</returns>
    public async Task<DOMRect?> GetElementSizeAsync(string elementId)
    {
        try
        {
            var module = await GetModuleAsync();
            var size = await module.InvokeAsync<DOMRect>("getElementSize", elementId);
            return size;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting size for element '{elementId}': {ex.Message}");
            return null;
        }
    }
}


==========================================
FILE: Interop\InteropService.cs
==========================================
Last Modified: 12/05/2024 13:22:30
Size: 1557 bytes
------------------------------------------

using Microsoft.JSInterop;

namespace Bdziam.UI.Interop;

public class InteropService : IAsyncDisposable
{
    private readonly Lazy<Task<IJSObjectReference>> moduleTask;

    public InteropService(IJSRuntime jsRuntime)
    {
        moduleTask = new Lazy<Task<IJSObjectReference>>(() => jsRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./_content/Bdziam.UI/js/bdziamui.js").AsTask());
    }

    public async ValueTask DisposeAsync()
    {
        if (moduleTask.IsValueCreated)
        {
            var module = await moduleTask.Value;
            await module.DisposeAsync();
        }
    }

    public async Task<ElementPosition> GetElementPosition(string elementId)
    {
        var module = await moduleTask.Value;
        return await module.InvokeAsync<ElementPosition>("getElementPosition", elementId);
    }

    public async Task<ElementSize> GetElementSize(string elementId)
    {
        var module = await moduleTask.Value;
        return await module.InvokeAsync<ElementSize>("getElementSize", elementId);
    }

    public async Task AddOutsideClickListener(string elementId, DotNetObjectReference<object> dotNetHelper)
    {
        var module = await moduleTask.Value;
        await module.InvokeVoidAsync("addOutsideClickListener", elementId, dotNetHelper);
    }

    public async Task RemoveOutsideClickListener(string elementId)
    {
        var module = await moduleTask.Value;
        await module.InvokeVoidAsync("removeOutsideClickListener", elementId);
    }
}


==========================================
FILE: obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
==========================================
Last Modified: 11/18/2024 22:07:47
Size: 198 bytes
------------------------------------------

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]



==========================================
FILE: obj\Debug\net8.0\Bdziam.UI.AssemblyInfo.cs
==========================================
Last Modified: 12/05/2024 08:34:45
Size: 1001 bytes
------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Bdziam.UI")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0e3a84fdd5b20f898ae4699032d42c489fde35be")]
[assembly: System.Reflection.AssemblyProductAttribute("Bdziam.UI")]
[assembly: System.Reflection.AssemblyTitleAttribute("Bdziam.UI")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.




==========================================
FILE: obj\Debug\net8.0\Bdziam.UI.GlobalUsings.g.cs
==========================================
Last Modified: 11/18/2024 22:07:47
Size: 295 bytes
------------------------------------------

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;



==========================================
FILE: Theming\MaterialColors\Blend\Blend.cs
==========================================
Last Modified: 12/05/2024 13:22:25
Size: 3955 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.Blend;

/// <summary>
///     Functions for blending in HCT and CAM16.
/// </summary>
public static class Blender
{
    /// <summary>
    ///     Blend the design color's HCT hue towards the key color's HCT hue, in a way that leaves the
    ///     original color recognizable and recognizably shifted towards the key color.
    /// </summary>
    /// <param name="designColor">ARGB representation of an arbitrary color.</param>
    /// <param name="sourceColor">ARGB representation of the main theme color.</param>
    /// <returns>
    ///     The design color with a hue shifted towards the system's color, a slightly
    ///     warmer/cooler variant of the design color's hue.
    /// </returns>
    public static uint Harmonize(uint designColor, uint sourceColor)
    {
        var fromHct = Hct.FromInt(designColor);
        var toHct = Hct.FromInt(sourceColor);
        var differenceDegrees = MathUtils.DifferenceDegrees(fromHct.Hue, toHct.Hue);
        var rotationDegrees = Math.Min(differenceDegrees * 0.5, 15.0);
        var outputHue =
            MathUtils.SanitizeDegreesDouble(
                fromHct.Hue
                + rotationDegrees * MathUtils.RotationDirection(fromHct.Hue, toHct.Hue));
        return Hct.From(outputHue, fromHct.Chroma, fromHct.Tone).ToInt();
    }

    /// <summary>
    ///     Blends hue from one color into another. The chroma and tone of the original color are
    ///     maintained.
    /// </summary>
    /// <param name="from">ARGB representation of color</param>
    /// <param name="to">ARGB representation of color</param>
    /// <param name="amount">How much blending to perform; Between 0.0 and 1.0</param>
    /// <returns><paramref name="from" />, with a hue blended towards <paramref name="to" />. Chroma and tone are constant.</returns>
    public static uint HctHue(uint from, uint to, double amount)
    {
        var ucs = Cam16Ucs(from, to, amount);
        var ucsCam = Cam16.FromInt(ucs);
        var fromCam = Cam16.FromInt(from);
        return Hct.From(ucsCam.Hue, fromCam.Chroma, ColorUtils.LStarFromArgb(from)).ToInt();
    }

    /// <summary>
    ///     Blend in CAM16-UCS space.
    /// </summary>
    /// <param name="from">ARGB representation of color</param>
    /// <param name="to">ARGB representation of color</param>
    /// <param name="amount">How much blending to perform; between 0.0 and 1.0</param>
    /// <returns><paramref name="from" />, blended towards <paramref name="to" />. Hue, chroma, and tone will change.</returns>
    public static uint Cam16Ucs(uint from, uint to, double amount)
    {
        var fromCam = Cam16.FromInt(from);
        var toCam = Cam16.FromInt(to);
        var fromJ = fromCam.Jstar;
        var fromA = fromCam.Astar;
        var fromB = fromCam.Bstar;
        var toJ = toCam.Jstar;
        var toA = toCam.Astar;
        var toB = toCam.Bstar;
        var jstar = fromJ + (toJ - fromJ) * amount;
        var astar = fromA + (toA - fromA) * amount;
        var bstar = fromB + (toB - fromB) * amount;
        return Cam16.FromUcs(jstar, astar, bstar).ToInt();
    }
}


==========================================
FILE: Theming\MaterialColors\ColorSpace\Cam16.cs
==========================================
Last Modified: 12/05/2024 13:22:54
Size: 16446 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.ColorSpace;

/// <summary>
///     CAM16, a color appearance model. Colors are not just defined by their hex code,
///     but rather, a hex code and viewing conditions.
/// </summary>
/// <remarks>
///     CAM16 instances also have coordinates in the CAM16-UCS space, called J*, a*, b*, or jstar,
///     astar, bstar in code. CAM16-UCS is included in the CAM16 specification, and should be used when
///     measuring distances between colors.
///     In traditional color spaces, a color can be identified solely by the observer's measurement of
///     the color. Color appearance models such as CAM16 also use information about the environment where
///     the color was observed, known as the viewing conditions.
///     For example, white under the traditional assumption of a midday sun white point is accurately
///     measured as a slightly chromatic blue by CAM16. (roughly, hue 203, chroma 3, lightness 100)
/// </remarks>
public class Cam16
{
    // Transforms XYZ color space coordinates to 'cone'/'RGB' responses in CAM16.
    internal static readonly double[][] XyzToCam16Rgb =
    {
        new[] { 0.401288, 0.650173, -0.051461 },
        new[] { -0.250268, 1.204414, 0.045854 },
        new[] { -0.002079, 0.048952, 0.953127 }
    };

    // Transforms 'cone'/'RGB' responses in CAM16 to XYZ color space coordinates.
    internal static readonly double[][] Cam16RgbToXyz =
    {
        new[] { 1.8620678, -1.0112547, 0.14918678 },
        new[] { 0.38752654, 0.62144744, -0.00897398 },
        new[] { -0.01584150, -0.03412294, 1.0499644 }
    };

    /// <summary>
    ///     All of the CAM16 dimensions can be calculated from 3 of the dimensions, in the following
    ///     combinations: - {j or q} and {c, m, or s} and hue - jstar, astar, bstar.
    ///     Prefer using a static
    ///     method that constructs from 3 of those dimensions. This constructor is intended for those
    ///     methods to use to return all possible dimensions.
    /// </summary>
    /// <param name="hue">for example, red, orange, yellow, green, etc.</param>
    /// <param name="chroma">
    ///     informally, colorfulness / color intensity. like saturation in HSL, except
    ///     perceptually accurate.
    /// </param>
    /// <param name="j">lightness</param>
    /// <param name="q">brightness; ratio of lightness to white point's lightness</param>
    /// <param name="m">colorfulness</param>
    /// <param name="s">saturation; ratio of chroma to white point's chroma</param>
    /// <param name="jStar">CAM16-UCS J* coordinate</param>
    /// <param name="aStar">CAM16-UCS a* coordinate</param>
    /// <param name="bStar">CAM16-UCS b* coordinate</param>
    private Cam16(double hue, double chroma, double j, double q, double m, double s, double jStar, double aStar,
        double bStar)
    {
        Hue = hue;
        Chroma = chroma;
        J = j;
        Q = q;
        M = m;
        S = s;
        Jstar = jStar;
        Astar = aStar;
        Bstar = bStar;
    }

    /// <summary>Hue in CAM16</summary>
    public double Hue { get; set; }

    /// <summary>Chroma in CAM16</summary>
    public double Chroma { get; set; }

    /// <summary>Lightness in CAM16</summary>
    public double J { get; set; }

    /// <summary>Brightness in CAM16.</summary>
    /// <remarks>
    ///     Prefer lightness, brightness is an absolute quantity. For example, a sheet of white paper is
    ///     much brighter viewed in sunlight than in indoor light, but it is the lightest object under any
    ///     lighting.
    /// </remarks>
    public double Q { get; set; }

    /// <summary>Colorfulness in CAM16.</summary>
    /// <remarks>
    ///     Prefer chroma, colorfulness is an absolute quantity. For example, a yellow toy car is much
    ///     more colorful outside than inside, but it has the same chroma in both environments.
    /// </remarks>
    public double M { get; set; }

    /// <summary>Saturation in CAM16.</summary>
    /// <remarks>
    ///     Colorfulness in proportion to brightness. Prefer chroma, saturation measures colorfulness
    ///     relative to the color's own brightness, where chroma is colorfulness relative to white.
    /// </remarks>
    public double S { get; set; }

    /// <summary>Lightness coordinate in CAM16-UCS</summary>
    public double Jstar { get; set; }

    /// <summary>a* coordinate in CAM16-UCS</summary>
    public double Astar { get; set; }

    /// <summary>b* coordinate in CAM16-UCS</summary>
    public double Bstar { get; set; }

    /// <summary>
    ///     CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
    ///     a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
    ///     specification, and should be used when measuring distances between colors.
    /// </summary>
    public double Distance(Cam16 other)
    {
        var dJ = Jstar - other.Jstar;
        var dA = Astar - other.Astar;
        var dB = Bstar - other.Bstar;
        var dEPrime = Math.Sqrt(dJ * dJ + dA * dA + dB * dB);
        var dE = 1.41 * Math.Pow(dEPrime, .63);
        return dE;
    }

    /// <summary>
    ///     Create a CAM16 color from a color, assuming the color was viewed in default viewing conditions.
    /// </summary>
    /// <param name="argb">ARGB representation of a color.</param>
    public static Cam16 FromInt(uint argb)
    {
        return FromIntInViewingConditions(argb, ViewingConditions.Default);
    }

    /// <summary>
    ///     Create a CAM16 color from a color in defined viewing conditions.
    /// </summary>
    /// <param name="argb">ARGB representation of a color.</param>
    /// <param name="viewingConditions">Information about the environment where the color was observed.</param>
    public static Cam16 FromIntInViewingConditions(uint argb, ViewingConditions viewingConditions)
    {
        // Transform ARGB int to XYZ
        var red = (argb & 0x00ff0000) >> 16;
        var green = (argb & 0x0000ff00) >> 8;
        var blue = argb & 0x000000ff;
        var redL = ColorUtils.Linearized(red);
        var greenL = ColorUtils.Linearized(green);
        var blueL = ColorUtils.Linearized(blue);
        var x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
        var y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
        var z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;

        // Transform XYZ to 'cone'/'rgb' responses
        var matrix = XyzToCam16Rgb;
        var rT = x * matrix[0][0] + y * matrix[0][1] + z * matrix[0][2];
        var gT = x * matrix[1][0] + y * matrix[1][1] + z * matrix[1][2];
        var bT = x * matrix[2][0] + y * matrix[2][1] + z * matrix[2][2];

        // Discount illuminant
        var rD = viewingConditions.RgbD[0] * rT;
        var gD = viewingConditions.RgbD[1] * gT;
        var bD = viewingConditions.RgbD[2] * bT;

        // Chromatic adaptation
        var rAF = Math.Pow(viewingConditions.Fl * Math.Abs(rD) / 100.0, 0.42);
        var gAF = Math.Pow(viewingConditions.Fl * Math.Abs(gD) / 100.0, 0.42);
        var bAF = Math.Pow(viewingConditions.Fl * Math.Abs(bD) / 100.0, 0.42);
        var rA = Math.Sign(rD) * 400.0 * rAF / (rAF + 27.13);
        var gA = Math.Sign(gD) * 400.0 * gAF / (gAF + 27.13);
        var bA = Math.Sign(bD) * 400.0 * bAF / (bAF + 27.13);

        // redness-greenness
        var a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
        // yellowness-blueness
        var b = (rA + gA - 2.0 * bA) / 9.0;

        // auxiliary components
        var u = (20.0 * rA + 20.0 * gA + 21.0 * bA) / 20.0;
        var p2 = (40.0 * rA + 20.0 * gA + bA) / 20.0;

        // hue
        var atan2 = Math.Atan2(b, a);
        var atanDegrees = atan2 * 180.0 / Math.PI;
        var hue =
            atanDegrees < 0
                ? atanDegrees + 360.0
                : atanDegrees >= 360
                    ? atanDegrees - 360.0
                    : atanDegrees;
        var hueRadians = hue * Math.PI / 180.0;

        // achromatic response to color
        var ac = p2 * viewingConditions.Nbb;

        // CAM16 lightness and brightness
        var j = 100.0 * Math.Pow(
            ac / viewingConditions.Aw,
            viewingConditions.C * viewingConditions.Z);
        var q = 4.0
                / viewingConditions.C
                * Math.Sqrt(j / 100.0)
                * (viewingConditions.Aw + 4.0)
                * viewingConditions.FlRoot;

        // CAM16 chroma, colorfulness, and saturation.
        var huePrime = hue < 20.14 ? hue + 360 : hue;
        var eHue = 0.25 * (Math.Cos(MathUtils.ToRadians(huePrime) + 2.0) + 3.8);
        var p1 = 50000.0 / 13.0 * eHue * viewingConditions.Nc * viewingConditions.Ncb;
        var t = p1 * MathUtils.Hypot(a, b) / (u + 0.305);
        var alpha = Math.Pow(1.64 - Math.Pow(0.29, viewingConditions.N), 0.73)
                    * Math.Pow(t, 0.9);

        // CAM16 chroma, colorfulness, saturation
        var c = alpha * Math.Sqrt(j / 100.0);
        var m = c * viewingConditions.FlRoot;
        var s =
            50.0 * Math.Sqrt(alpha * viewingConditions.C / (viewingConditions.Aw + 4.0));

        // CAM16-UCS components
        var jstar = (1.0 + 100.0 * 0.007) * j / (1.0 + 0.007 * j);
        var mstar = 1.0 / 0.0228 * MathUtils.Log1p(0.0228 * m);
        var astar = mstar * Math.Cos(hueRadians);
        var bstar = mstar * Math.Sin(hueRadians);

        return new Cam16(hue, c, j, q, m, s, jstar, astar, bstar);
    }

    /// <param name="j">lightness</param>
    /// <param name="c">chroma</param>
    /// <param name="h">hue</param>
    public static Cam16 FromJch(double j, double c, double h)
    {
        return FromJchInViewingConditions(j, c, h, ViewingConditions.Default);
    }

    /// <param name="j">lightness</param>
    /// <param name="c">chroma</param>
    /// <param name="h">hue</param>
    /// <param name="viewingConditions">Information about the environment where the color was observed.</param>
    public static Cam16 FromJchInViewingConditions(
        double j, double c, double h, ViewingConditions viewingConditions)
    {
        var q =
            4.0
            / viewingConditions.C
            * Math.Sqrt(j / 100.0)
            * (viewingConditions.Aw + 4.0)
            * viewingConditions.FlRoot;
        var m = c * viewingConditions.FlRoot;
        var alpha = c / Math.Sqrt(j / 100.0);
        var s =
            50.0 * Math.Sqrt(alpha * viewingConditions.C / (viewingConditions.Aw + 4.0));

        var hueRadians = h * Math.PI / 180.0;
        var jstar = (1.0 + 100.0 * 0.007) * j / (1.0 + 0.007 * j);
        var mstar = 1.0 / 0.0228 * MathUtils.Log1p(0.0228 * m);
        var astar = mstar * Math.Cos(hueRadians);
        var bstar = mstar * Math.Sin(hueRadians);
        return new Cam16(h, c, j, q, m, s, jstar, astar, bstar);
    }

    /// <summary>
    ///     Create a CAM16 color from CAM16-UCS coordinates.
    /// </summary>
    /// <param name="jstar">CAM16-UCS lightness.</param>
    /// <param name="astar">CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian coordinate on the Y axis.</param>
    /// <param name="bstar">CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian coordinate on the X axis.</param>
    public static Cam16 FromUcs(double jstar, double astar, double bstar)
    {
        return FromUcsInViewingConditions(jstar, astar, bstar, ViewingConditions.Default);
    }

    /// <summary>
    ///     Create a CAM16 color from CAM16-UCS coordinates in defined viewing conditions.
    /// </summary>
    /// <param name="jstar">CAM16-UCS lightness.</param>
    /// <param name="astar">CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian coordinate on the Y axis.</param>
    /// <param name="bstar">CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian coordinate on the X axis.</param>
    /// <param name="viewingConditions">Information about the environment where the color was observed.</param>
    public static Cam16 FromUcsInViewingConditions(
        double jstar, double astar, double bstar, ViewingConditions viewingConditions)
    {
        var m = MathUtils.Hypot(astar, bstar);
        var m2 = MathUtils.Expm1(m * 0.0228) / 0.0228;
        var c = m2 / viewingConditions.FlRoot;
        var h = Math.Atan2(bstar, astar) * (180.0 / Math.PI);
        if (h < 0.0) h += 360.0;
        var j = jstar / (1 - (jstar - 100) * 0.007);
        return FromJchInViewingConditions(j, c, h, viewingConditions);
    }

    /// <summary>
    ///     ARGB representation of the color. Assumes the color was viewed in default viewing conditions,
    ///     which are near-identical to the default viewing conditions for sRGB.
    /// </summary>
    /// <returns></returns>
    public uint ToInt()
    {
        return Viewed(ViewingConditions.Default);
    }

    /// <summary>
    ///     ARGB representation of the color, in defined viewing conditions.
    /// </summary>
    /// <param name="viewingConditions">Information about the environment where the color will be viewed.</param>
    /// <returns>ARGB representation of color</returns>
    public uint Viewed(ViewingConditions viewingConditions)
    {
        var alpha =
            Chroma == 0.0 || J == 0.0
                ? 0.0
                : Chroma / Math.Sqrt(J / 100.0);

        var t =
            Math.Pow(
                alpha / Math.Pow(1.64 - Math.Pow(0.29, viewingConditions.N), 0.73), 1.0 / 0.9);
        var hRad = Hue * Math.PI / 180.0;

        var eHue = 0.25 * (Math.Cos(hRad + 2.0) + 3.8);
        var ac =
            viewingConditions.Aw
            *
            Math.Pow(J / 100.0, 1.0 / viewingConditions.C / viewingConditions.Z);
        var p1 = eHue * (50000.0 / 13.0) * viewingConditions.Nc * viewingConditions.Ncb;
        var p2 = ac / viewingConditions.Nbb;

        var hSin = Math.Sin(hRad);
        var hCos = Math.Cos(hRad);

        var gamma = 23.0 * (p2 + 0.305) * t / (23.0 * p1 + 11.0 * t * hCos + 108.0 * t * hSin);
        var a = gamma * hCos;
        var b = gamma * hSin;
        var rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
        var gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
        var bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;

        var rCBase = Math.Max(0, 27.13 * Math.Abs(rA) / (400.0 - Math.Abs(rA)));
        var rC =
            Math.Sign(rA)
            * (100.0 / viewingConditions.Fl)
            * Math.Pow(rCBase, 1.0 / 0.42);
        var gCBase = Math.Max(0, 27.13 * Math.Abs(gA) / (400.0 - Math.Abs(gA)));
        var gC =
            Math.Sign(gA)
            * (100.0 / viewingConditions.Fl)
            * Math.Pow(gCBase, 1.0 / 0.42);
        var bCBase = Math.Max(0, 27.13 * Math.Abs(bA) / (400.0 - Math.Abs(bA)));
        var bC =
            Math.Sign(bA)
            * (100.0 / viewingConditions.Fl)
            * Math.Pow(bCBase, 1.0 / 0.42);
        var rF = rC / viewingConditions.RgbD[0];
        var gF = gC / viewingConditions.RgbD[1];
        var bF = bC / viewingConditions.RgbD[2];

        var matrix = Cam16RgbToXyz;
        var x = rF * matrix[0][0] + gF * matrix[0][1] + bF * matrix[0][2];
        var y = rF * matrix[1][0] + gF * matrix[1][1] + bF * matrix[1][2];
        var z = rF * matrix[2][0] + gF * matrix[2][1] + bF * matrix[2][2];

        return ColorUtils.ArgbFromXyz(x, y, z);
    }
}


==========================================
FILE: Theming\MaterialColors\ColorSpace\Hct.cs
==========================================
Last Modified: 12/05/2024 13:23:21
Size: 4448 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.ColorSpace;

/// <summary>
///     HCT: hue, chroma, and tone. A color system that provides a perceptually
///     accurate color measurement system that can also accurately render what
///     colors will appear as in different lighting environments.
/// </summary>
public class Hct
{
    private uint argb;
    private double chroma;
    private double hue;
    private uint tone;

    private Hct(uint argb)
    {
        SetInternalState(argb);
    }

    /// <summary>
    ///     The hue of this color.
    /// </summary>
    /// <remarks>
    ///     0 ≤ Hue &lt; 360; invalid values are corrected.<br />
    ///     After setting hue, the color is mapped from HCT to the more
    ///     limited sRGB gamut for display. This will change its ARGB/integer
    ///     representation. If the HCT color is outside of the sRGB gamut, chroma
    ///     will decrease until it is inside the gamut.
    /// </remarks>
    public double Hue
    {
        get => hue;
        set => SetInternalState(HctSolver.SolveToInt(value, chroma, tone));
    }

    /// <summary>
    ///     The chroma of this color.
    /// </summary>
    /// <remarks>
    ///     0 ≤ chroma &lt; ?<br />
    ///     After setting chroma, the color is mapped from HCT to the more
    ///     limited sRGB gamut for display. This will change its ARGB/integer
    ///     representation. If the HCT color is outside of the sRGB gamut, chroma
    ///     will decrease until it is inside the gamut.
    /// </remarks>
    public double Chroma
    {
        get => chroma;
        set => SetInternalState(HctSolver.SolveToInt(hue, value, tone));
    }

    /// <summary>
    ///     Lightness. Ranges from 0 to 100.
    /// </summary>
    /// <remarks>
    ///     0 ≤ tone ≤ 100; invalid values are corrected.<br />
    ///     After setting tone, the color is mapped from HCT to the more
    ///     limited sRGB gamut for display. This will change its ARGB/integer
    ///     representation. If the HCT color is outside of the sRGB gamut, chroma
    ///     will decrease until it is inside the gamut.
    /// </remarks>
    public uint Tone
    {
        get => tone;
        set => SetInternalState(HctSolver.SolveToInt(hue, chroma, value));
    }

    /// <summary>
    ///     Create an HCT color from hue, chroma, and tone.
    /// </summary>
    /// <param name="hue">0 ≤ hue &lt; 360; invalid values are corrected.</param>
    /// <param name="chroma">
    ///     0 ≤ chroma &lt; ?; Informally, colorfulness. The color returned may be lower than
    ///     the requested chroma. Chroma has a different maximum for any given hue and tone.
    /// </param>
    /// <param name="tone">0 ≤ tone ≤ 100; invalid values are corrected.</param>
    /// <returns>HCT representation of a color in default viewing conditions.</returns>
    public static Hct From(double hue, double chroma, double tone)
    {
        var argb = HctSolver.SolveToInt(hue, chroma, tone);
        return new Hct(argb);
    }

    /// <summary>
    ///     Create an HCT color from a color.
    /// </summary>
    /// <param name="argb">ARGB representation of a color</param>
    /// <returns>HCT representation of a color in default viewing conditions</returns>
    public static Hct FromInt(uint argb)
    {
        return new Hct(argb);
    }

    public uint ToInt()
    {
        return argb;
    }

    private void SetInternalState(uint argb)
    {
        this.argb = argb;
        var cam = Cam16.FromInt(argb);
        hue = cam.Hue;
        chroma = cam.Chroma;
        tone = (uint)ColorUtils.LStarFromArgb(argb);
    }
}


==========================================
FILE: Theming\MaterialColors\ColorSpace\HctSolver.cs
==========================================
Last Modified: 12/05/2024 13:22:55
Size: 23742 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.ColorSpace;

/// <summary>
///     A class that solves the HCT equation.
/// </summary>
public static class HctSolver
{
    private static readonly double[][] ScaledDiscountFromLinrgb =
    {
        new[] { 0.001200833568784504, 0.002389694492170889, 0.0002795742885861124 },
        new[] { 0.0005891086651375999, 0.0029785502573438758, 0.0003270666104008398 },
        new[] { 0.00010146692491640572, 0.0005364214359186694, 0.0032979401770712076 }
    };

    private static readonly double[][] LinrgbFromScaledDiscount =
    {
        new[] { 1373.2198709594231, -1100.4251190754821, -7.278681089101213 },
        new[] { -271.815969077903, 559.6580465940733, -32.46047482791194 },
        new[] { 1.9622899599665666, -57.173814538844006, 308.7233197812385 }
    };

    private static readonly double[] YFromLinrgb = { 0.2126, 0.7152, 0.0722 };

    private static readonly double[] CriticalPlanes =
    {
        0.015176349177441876,
        0.045529047532325624,
        0.07588174588720938,
        0.10623444424209313,
        0.13658714259697685,
        0.16693984095186062,
        0.19729253930674434,
        0.2276452376616281,
        0.2579979360165119,
        0.28835063437139563,
        0.3188300904430532,
        0.350925934958123,
        0.3848314933096426,
        0.42057480301049466,
        0.458183274052838,
        0.4976837250274023,
        0.5391024159806381,
        0.5824650784040898,
        0.6277969426914107,
        0.6751227633498623,
        0.7244668422128921,
        0.775853049866786,
        0.829304845476233,
        0.8848452951698498,
        0.942497089126609,
        1.0022825574869039,
        1.0642236851973577,
        1.1283421258858297,
        1.1946592148522128,
        1.2631959812511864,
        1.3339731595349034,
        1.407011200216447,
        1.4823302800086415,
        1.5599503113873272,
        1.6398909516233677,
        1.7221716113234105,
        1.8068114625156377,
        1.8938294463134073,
        1.9832442801866852,
        2.075074464868551,
        2.1693382909216234,
        2.2660538449872063,
        2.36523901573795,
        2.4669114995532007,
        2.5710888059345764,
        2.6777882626779785,
        2.7870270208169257,
        2.898822059350997,
        3.0131901897720907,
        3.1301480604002863,
        3.2497121605402226,
        3.3718988244681087,
        3.4967242352587946,
        3.624204428461639,
        3.754355295633311,
        3.887192587735158,
        4.022731918402185,
        4.160988767090289,
        4.301978482107941,
        4.445716283538092,
        4.592217266055746,
        4.741496401646282,
        4.893568542229298,
        5.048448422192488,
        5.20615066083972,
        5.3666897647573375,
        5.5300801301023865,
        5.696336044816294,
        5.865471690767354,
        6.037501145825082,
        6.212438385869475,
        6.390297286737924,
        6.571091626112461,
        6.7548350853498045,
        6.941541251256611,
        7.131223617812143,
        7.323895587840543,
        7.5195704746346665,
        7.7182615035334345,
        7.919981813454504,
        8.124744458384042,
        8.332562408825165,
        8.543448553206703,
        8.757415699253682,
        8.974476575321063,
        9.194643831691977,
        9.417930041841839,
        9.644347703669503,
        9.873909240696694,
        10.106627003236781,
        10.342513269534024,
        10.58158024687427,
        10.8238400726681,
        11.069304815507364,
        11.317986476196008,
        11.569896988756009,
        11.825048221409341,
        12.083451977536606,
        12.345119996613247,
        12.610063955123938,
        12.878295467455942,
        13.149826086772048,
        13.42466730586372,
        13.702830557985108,
        13.984327217668513,
        14.269168601521828,
        14.55736596900856,
        14.848930523210871,
        15.143873411576273,
        15.44220572664832,
        15.743938506781891,
        16.04908273684337,
        16.35764934889634,
        16.66964922287304,
        16.985093187232053,
        17.30399201960269,
        17.62635644741625,
        17.95219714852476,
        18.281524751807332,
        18.614349837764564,
        18.95068293910138,
        19.290534541298456,
        19.633915083172692,
        19.98083495742689,
        20.331304511189067,
        20.685334046541502,
        21.042933821039977,
        21.404114048223256,
        21.76888489811322,
        22.137256497705877,
        22.50923893145328,
        22.884842241736916,
        23.264076429332462,
        23.6469514538663,
        24.033477234264016,
        24.42366364919083,
        24.817520537484558,
        25.21505769858089,
        25.61628489293138,
        26.021211842414342,
        26.429848230738664,
        26.842203703840827,
        27.258287870275353,
        27.678110301598522,
        28.10168053274597,
        28.529008062403893,
        28.96010235337422,
        29.39497283293396,
        29.83362889318845,
        30.276079891419332,
        30.722335150426627,
        31.172403958865512,
        31.62629557157785,
        32.08401920991837,
        32.54558406207592,
        33.010999283389665,
        33.4802739966603,
        33.953417292456834,
        34.430438229418264,
        34.911345834551085,
        35.39614910352207,
        35.88485700094671,
        36.37747846067349,
        36.87402238606382,
        37.37449765026789,
        37.87891309649659,
        38.38727753828926,
        38.89959975977785,
        39.41588851594697,
        39.93615253289054,
        40.460400508064545,
        40.98864111053629,
        41.520882981230194,
        42.05713473317016,
        42.597404951718396,
        43.141702194811224,
        43.6900349931913,
        44.24241185063697,
        44.798841244188324,
        45.35933162437017,
        45.92389141541209,
        46.49252901546552,
        47.065252796817916,
        47.64207110610409,
        48.22299226451468,
        48.808024568002054,
        49.3971762874833,
        49.9904556690408,
        50.587870934119984,
        51.189430279724725,
        51.79514187861014,
        52.40501387947288,
        53.0190544071392,
        53.637271562750364,
        54.259673423945976,
        54.88626804504493,
        55.517063457223934,
        56.15206766869424,
        56.79128866487574,
        57.43473440856916,
        58.08241284012621,
        58.734331877617365,
        59.39049941699807,
        60.05092333227251,
        60.715611475655585,
        61.38457167773311,
        62.057811747619894,
        62.7353394731159,
        63.417162620860914,
        64.10328893648692,
        64.79372614476921,
        65.48848194977529,
        66.18756403501224,
        66.89098006357258,
        67.59873767827808,
        68.31084450182222,
        69.02730813691093,
        69.74813616640164,
        70.47333615344107,
        71.20291564160104,
        71.93688215501312,
        72.67524319850172,
        73.41800625771542,
        74.16517879925733,
        74.9167682708136,
        75.67278210128072,
        76.43322770089146,
        77.1981124613393,
        77.96744375590167,
        78.74122893956174,
        79.51947534912904,
        80.30219030335869,
        81.08938110306934,
        81.88105503125999,
        82.67721935322541,
        83.4778813166706,
        84.28304815182372,
        85.09272707154808,
        85.90692527145302,
        86.72564993000343,
        87.54890820862819,
        88.3767072518277,
        89.2090541872801,
        90.04595612594655,
        90.88742016217518,
        91.73345337380438,
        92.58406282226491,
        93.43925555268066,
        94.29903859396902,
        95.16341895893969,
        96.03240364439274,
        96.9059996312159,
        97.78421388448044,
        98.6670533535366,
        99.55452497210776
    };

    /// <summary>Sanitizes a small enough angle in radians.</summary>
    /// <param name="angle">An angle in radians; must not deviate too much from 0.</param>
    /// <returns>A coterminal angle between 0 and 2pi.</returns>
    private static double SanitizeRadians(double angle)
    {
        return (angle + Math.PI * 8) % (Math.PI * 2);
    }

    /// <summary>Delinearizes an RGB component, returning a floating-point number.</summary>
    /// <param name="rgbComponent">0.0 &lt;= rgb_component &gt;= 100.0, represents linear R/G/B channel</param>
    /// <returns>0.0 &lt;= output &lt;= 255.0, color channel converted to regular RGB space</returns>
    private static double TrueDelinearized(double rgbComponent)
    {
        var normalized = rgbComponent / 100.0;
        double delinearized;
        if (normalized <= 0.0031308)
            delinearized = normalized * 12.92;
        else
            delinearized = 1.055 * Math.Pow(normalized, 1.0 / 2.4) - 0.055;
        return delinearized * 255.0;
    }

    private static double ChromaticAdaptation(double component)
    {
        var af = Math.Pow(Math.Abs(component), 0.42);
        return Math.Sign(component) * 400.0 * af / (af + 27.13);
    }

    /// <summary>Returns the hue of a linear RGB color in CAM16.</summary>
    /// <param name="linrgb">The linear RGB coordinates of a color.</param>
    /// <returns>The hue of the color in CAM16, in radians.</returns>
    private static double HueOf(double[] linrgb)
    {
        var scaledDiscount = MathUtils.MatrixMultiply(linrgb, ScaledDiscountFromLinrgb);
        var rA = ChromaticAdaptation(scaledDiscount[0]);
        var gA = ChromaticAdaptation(scaledDiscount[1]);
        var bA = ChromaticAdaptation(scaledDiscount[2]);
        // redness-greenness
        var a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
        // yellowness-blueness
        var b = (rA + gA - 2.0 * bA) / 9.0;
        return Math.Atan2(b, a);
    }

    private static bool AreInCyclicOrder(double a, double b, double c)
    {
        var deltaAB = SanitizeRadians(b - a);
        var deltaAC = SanitizeRadians(c - a);
        return deltaAB < deltaAC;
    }

    /// <summary>Solves the lerp equation.</summary>
    /// <param name="source">The starting number.</param>
    /// <param name="mid">The number in the middle.</param>
    /// <param name="target">The ending number.</param>
    /// <returns>A number t such that lerp(source, target, t) = mid.</returns>
    private static double Intercept(double source, double mid, double target)
    {
        return (mid - source) / (target - source);
    }

    private static double[] LerpPoint(double[] source, double t, double[] target)
    {
        return new[]
        {
            source[0] + (target[0] - source[0]) * t,
            source[1] + (target[1] - source[1]) * t,
            source[2] + (target[2] - source[2]) * t
        };
    }

    /// <summary>Intersects a segment with a plane.</summary>
    /// <param name="source">The coordinates of point A.</param>
    /// <param name="coordinate">The R-, G-, or B-coordinate of the plane.</param>
    /// <param name="target">The coordinates of point B.</param>
    /// <param name="axis">The axis the plane is perpendicular with. (0: R, 1: G, 2: B)</param>
    /// <returns>The intersection point of the segment AB with the plane R=coordinate, G=coordinate, or
    private static double[] SetCoordinate(double[] source, double coordinate, double[] target, int axis)
    {
        var t = Intercept(source[axis], coordinate, target[axis]);
        return LerpPoint(source, t, target);
    }

    private static bool IsBounded(double x)
    {
        return 0.0 <= x && x <= 100.0;
    }

    /// <summary>Returns the intersections of the plane of constant y with the RGB cube.</summary>
    /// <param name="y">The Y value of the plane.</param>
    /// <returns>
    ///     A list of points where the plane intersects with the edges of the RGB cube, in linear
    ///     RGB coordinates.
    /// </returns>
    private static List<double[]> EdgePoints(double y)
    {
        var kR = YFromLinrgb[0];
        var kG = YFromLinrgb[1];
        var kB = YFromLinrgb[2];
        double[][] points =
        {
            new[] { y / kR, 0.0, 0.0 },
            new[] { (y - 100 * kB) / kR, 0.0, 100.0 },
            new[] { (y - 100 * kG) / kR, 100.0, 0.0 },
            new[] { (y - 100 * kB - 100 * kG) / kR, 100.0, 100.0 },
            new[] { 0.0, y / kG, 0.0 },
            new[] { 100.0, (y - 100 * kR) / kG, 0.0 },
            new[] { 0.0, (y - 100 * kB) / kG, 100.0 },
            new[] { 100.0, (y - 100 * kR - 100 * kB) / kG, 100.0 },
            new[] { 0.0, 0.0, y / kB },
            new[] { 100.0, 0.0, (y - 100 * kR) / kB },
            new[] { 0.0, 100.0, (y - 100 * kG) / kB },
            new[] { 100.0, 100.0, (y - 100 * kR - 100 * kG) / kB }
        };
        List<double[]> ans = new();
        foreach (var point in points)
            if (IsBounded(point[0]) && IsBounded(point[1]) && IsBounded(point[2]))
                ans.Add(point);
        return ans;
    }

    /// <summary>Finds the segment containing the desired color.</summary>
    /// <param name="y">The Y value of the color.</param>
    /// <param name="targetHue">The hue of the color.</param>
    /// <returns>
    ///     A list of two sets of linear RGB coordinates, each corresponding to an endpoint of the
    ///     segment containing the desired color.
    /// </returns>
    private static double[][] BisectToSegment(double y, double targetHue)
    {
        var vertices = EdgePoints(y);
        var left = vertices[0];
        var right = left;
        var leftHue = HueOf(left);
        var rightHue = leftHue;
        var uncut = true;
        for (var i = 1; i < vertices.Count; i++)
        {
            var mid = vertices[i];
            var midHue = HueOf(mid);
            if (uncut || AreInCyclicOrder(leftHue, midHue, rightHue))
            {
                uncut = false;
                if (AreInCyclicOrder(leftHue, targetHue, midHue))
                {
                    right = mid;
                    rightHue = midHue;
                }
                else
                {
                    left = mid;
                    leftHue = midHue;
                }
            }
        }

        return new[] { left, right };
    }

    private static double[] Midpoint(double[] a, double[] b)
    {
        return new[]
        {
            (a[0] + b[0]) / 2, (a[1] + b[1]) / 2, (a[2] + b[2]) / 2
        };
    }

    private static int CriticalPlaneBelow(double x)
    {
        return (int)Math.Floor(x - 0.5);
    }

    private static int CriticalPlaneAbove(double x)
    {
        return (int)Math.Ceiling(x - 0.5);
    }

    /// <summary>Finds a color with the given Y and hue on the boundary of the cube.</summary>
    /// <param name="y">The Y value of the color.</param>
    /// <param name="targetHue">The hue of the color.</param>
    /// <returns>The desired color, in linear RGB coordinates.</returns>
    private static double[] BisectToLimit(double y, double targetHue)
    {
        var segment = BisectToSegment(y, targetHue);
        var left = segment[0];
        var leftHue = HueOf(left);
        var right = segment[1];
        for (var axis = 0; axis < 3; axis++)
            if (left[axis] != right[axis])
            {
                int lPlane;
                int rPlane;
                if (left[axis] < right[axis])
                {
                    lPlane = CriticalPlaneBelow(TrueDelinearized(left[axis]));
                    rPlane = CriticalPlaneAbove(TrueDelinearized(right[axis]));
                }
                else
                {
                    lPlane = CriticalPlaneAbove(TrueDelinearized(left[axis]));
                    rPlane = CriticalPlaneBelow(TrueDelinearized(right[axis]));
                }

                for (var i = 0; i < 8; i++)
                    if (Math.Abs(rPlane - lPlane) <= 1)
                    {
                        break;
                    }
                    else
                    {
                        var mPlane = (lPlane + rPlane) / 2;
                        var midPlaneCoordinate = CriticalPlanes[mPlane];
                        var mid = SetCoordinate(left, midPlaneCoordinate, right, axis);
                        var midHue = HueOf(mid);
                        if (AreInCyclicOrder(leftHue, targetHue, midHue))
                        {
                            right = mid;
                            rPlane = mPlane;
                        }
                        else
                        {
                            left = mid;
                            leftHue = midHue;
                            lPlane = mPlane;
                        }
                    }
            }

        return Midpoint(left, right);
    }

    private static double InverseChromaticAdaptation(double adapted)
    {
        var adaptedAbs = Math.Abs(adapted);
        var @base = Math.Max(0, 27.13 * adaptedAbs / (400.0 - adaptedAbs));
        return Math.Sign(adapted) * Math.Pow(@base, 1.0 / 0.42);
    }

    /// <summary>Finds a color with the given hue, chroma, and Y.</summary>
    /// <param name="hueRadians">The desired hue in radians.</param>
    /// <param name="chroma">The desired chroma.</param>
    /// <param name="y">The desired Y.</param>
    /// <returns>The desired color as a hexadecimal integer, if found; 0 otherwise.</returns>
    private static uint FindResultByJ(double hueRadians, double chroma, double y)
    {
        // Initial estimate of j.
        var j = Math.Sqrt(y) * 11.0;
        // ===========================================================
        // Operations inlined from Cam16 to avoid repeated calculation
        // ===========================================================
        var viewingConditions = ViewingConditions.Default;
        var tInnerCoeff = 1 / Math.Pow(1.64 - Math.Pow(0.29, viewingConditions.N), 0.73);
        var eHue = 0.25 * (Math.Cos(hueRadians + 2.0) + 3.8);
        var p1 = eHue * (50000.0 / 13.0) * viewingConditions.Nc * viewingConditions.Ncb;
        var hSin = Math.Sin(hueRadians);
        var hCos = Math.Cos(hueRadians);
        for (var iterationRound = 0; iterationRound < 5; iterationRound++)
        {
            // ===========================================================
            // Operations inlined from Cam16 to avoid repeated calculation
            // ===========================================================
            var jNormalized = j / 100.0;
            var alpha = chroma == 0.0 || j == 0.0 ? 0.0 : chroma / Math.Sqrt(jNormalized);
            var t = Math.Pow(alpha * tInnerCoeff, 1.0 / 0.9);
            var ac =
                viewingConditions.Aw
                * Math.Pow(jNormalized, 1.0 / viewingConditions.C / viewingConditions.Z);
            var p2 = ac / viewingConditions.Nbb;
            var gamma = 23.0 * (p2 + 0.305) * t / (23.0 * p1 + 11 * t * hCos + 108.0 * t * hSin);
            var a = gamma * hCos;
            var b = gamma * hSin;
            var rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
            var gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
            var bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
            var rCScaled = InverseChromaticAdaptation(rA);
            var gCScaled = InverseChromaticAdaptation(gA);
            var bCScaled = InverseChromaticAdaptation(bA);
            var linrgb =
                MathUtils.MatrixMultiply(
                    new[] { rCScaled, gCScaled, bCScaled }, LinrgbFromScaledDiscount);
            // ===========================================================
            // Operations inlined from Cam16 to avoid repeated calculation
            // ===========================================================
            if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) return 0;
            var kR = YFromLinrgb[0];
            var kG = YFromLinrgb[1];
            var kB = YFromLinrgb[2];
            var fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
            if (fnj <= 0) return 0;
            if (iterationRound == 4 || Math.Abs(fnj - y) < 0.002)
            {
                if (linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01) return 0;
                return ColorUtils.ArgbFromLinrgb(linrgb);
            }

            // Iterates with Newton method,
            // Using 2 * fn(j) / j as the approximation of fn'(j)
            j -= (fnj - y) * j / (2 * fnj);
        }

        return 0;
    }

    /// <summary>Finds an sRGB color with the given hue, chroma, and L*.</summary>
    /// <param name="hueDegrees">The desired hue, in degrees.</param>
    /// <param name="chroma">The desired chroma.</param>
    /// <param name="lstar">The desired L*.</param>
    /// <returns>
    ///     A hexadecimal representing the sRGB color. The color has sufficiently close hue,
    ///     chroma, and L* to the desired values, if possible; otherwise, the hue and L* will be
    ///     sufficiently close, and chroma will be maximized.
    /// </returns>
    public static uint SolveToInt(double hueDegrees, double chroma, double lstar)
    {
        if (chroma < 0.0001 || lstar < 0.0001 || lstar > 99.9999) return ColorUtils.ArgbFromLstar(lstar);
        hueDegrees = MathUtils.SanitizeDegreesDouble(hueDegrees);
        var hueRadians = MathUtils.ToRadians(hueDegrees);
        var y = ColorUtils.YFromLstar(lstar);
        var exactAnswer = FindResultByJ(hueRadians, chroma, y);
        if (exactAnswer != 0) return exactAnswer;
        var linrgb = BisectToLimit(y, hueRadians);
        return ColorUtils.ArgbFromLinrgb(linrgb);
    }

    /// <summary>Finds an sRGB color with the given hue, chroma, and L*.</summary>
    /// <param name="hueDegrees">The desired hue, in degrees.</param>
    /// <param name="chroma">The desired chroma.</param>
    /// <param name="lstar">The desired L*.</param>
    /// <returns>
    ///     An CAM16 object representing the sRGB color. The color has sufficiently close hue,
    ///     chroma, and L* to the desired values, if possible; otherwise, the hue and L* will be
    ///     sufficiently close, and chroma will be maximized.
    /// </returns>
    public static Cam16 SolveToCam(double hueDegrees, double chroma, double lstar)
    {
        return Cam16.FromInt(SolveToInt(hueDegrees, chroma, lstar));
    }
}


==========================================
FILE: Theming\MaterialColors\ColorSpace\ViewingConditions.cs
==========================================
Last Modified: 12/05/2024 13:23:15
Size: 5421 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.ColorSpace;

/// <summary>
///     In traditional color spaces, a color can be identified solely by the observer's measurement of
///     the color. Color appearance models such as CAM16 also use information about the environment
///     where the color was observed, known as the viewing conditions.
/// </summary>
/// <remarks>
///     For example, white under the traditional assumption of a midday sun white point is accurately
///     measured as a slightly chromatic blue by CAM16. (roughly, hue 203, chroma 3, lightness 100)
///     <para />
///     This class caches intermediate values of the CAM16 conversion process that depend only on
///     viewing conditions, enabling speed ups.
/// </remarks>
public class ViewingConditions
{
    /// <summary>
    ///     Parameters are intermediate values of the CAM16 conversion process.
    ///     Their names are shorthand for technical color science terminology,
    ///     this class would not benefit from documenting them individually.
    ///     A brief overview is available in the CAM16 specification,
    ///     and a complete overview requires a color science textbook,
    ///     osuch as Fairchild's Color Appearance Models.
    /// </summary>
    public ViewingConditions(
        double n,
        double aw,
        double nbb,
        double ncb,
        double c,
        double nc,
        double[] rgbD,
        double fl,
        double flRoot,
        double z)
    {
        N = n;
        Aw = aw;
        Nbb = nbb;
        Ncb = ncb;
        C = c;
        Nc = nc;
        RgbD = rgbD;
        Fl = fl;
        FlRoot = flRoot;
        Z = z;
    }

    /// <summary>
    ///     sRGB-like viewing conditions.
    /// </summary>
    public static ViewingConditions Default { get; } = Make(
        new[]
        {
            ColorUtils.WhitePointD65[0],
            ColorUtils.WhitePointD65[1],
            ColorUtils.WhitePointD65[2]
        },
        200.0 / Math.PI * ColorUtils.YFromLstar(50.0) / 100.0,
        50.0,
        2.0,
        false);

    public double N { get; }
    public double Aw { get; }
    public double Nbb { get; }
    public double Ncb { get; }
    public double C { get; }
    public double Nc { get; }
    public double[] RgbD { get; }
    public double Fl { get; }
    public double FlRoot { get; }
    public double Z { get; }

    public static ViewingConditions Make(
        double[] whitePoint,
        double adaptingLuminance,
        double backgroundLstar,
        double surround,
        bool discountingIlluminant)
    {
        // Transform white point XYZ to 'cone'/'rgb' responses
        var matrix = Cam16.XyzToCam16Rgb;
        var xyz = whitePoint;
        var rW = xyz[0] * matrix[0][0] + xyz[1] * matrix[0][1] + xyz[2] * matrix[0][2];
        var gW = xyz[0] * matrix[1][0] + xyz[1] * matrix[1][1] + xyz[2] * matrix[1][2];
        var bW = xyz[0] * matrix[2][0] + xyz[1] * matrix[2][1] + xyz[2] * matrix[2][2];
        var f = 0.8 + surround / 10.0;
        var c =
            f >= 0.9
                ? MathUtils.Lerp(0.59, 0.69, (f - 0.9) * 10.0)
                : MathUtils.Lerp(0.525, 0.59, (f - 0.8) * 10.0);
        var d =
            discountingIlluminant
                ? 1.0
                : f * (1.0 - 1.0 / 3.6 * Math.Exp((-adaptingLuminance - 42.0) / 92.0));
        d = d > 1.0 ? 1.0 : d < 0.0 ? 0.0 : d;
        var nc = f;
        double[] rgbD =
        {
            d * (100.0 / rW) + 1.0 - d, d * (100.0 / gW) + 1.0 - d, d * (100.0 / bW) + 1.0 - d
        };
        var k = 1.0 / (5.0 * adaptingLuminance + 1.0);
        var k4 = k * k * k * k;
        var k4F = 1.0 - k4;
        var fl =
            k4 * adaptingLuminance + 0.1 * k4F * k4F * Math.Pow(5.0 * adaptingLuminance, 1.0 / 3.0);
        var n = ColorUtils.YFromLstar(backgroundLstar) / whitePoint[1];
        var z = 1.48 + Math.Sqrt(n);
        var nbb = 0.725 / Math.Pow(n, 0.2);
        var ncb = nbb;
        double[] rgbAFactors =
        {
            Math.Pow(fl * rgbD[0] * rW / 100.0, 0.42),
            Math.Pow(fl * rgbD[1] * gW / 100.0, 0.42),
            Math.Pow(fl * rgbD[2] * bW / 100.0, 0.42)
        };

        double[] rgbA =
        {
            400.0 * rgbAFactors[0] / (rgbAFactors[0] + 27.13),
            400.0 * rgbAFactors[1] / (rgbAFactors[1] + 27.13),
            400.0 * rgbAFactors[2] / (rgbAFactors[2] + 27.13)
        };

        var aw = (2.0 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
        return new ViewingConditions(n, aw, nbb, ncb, c, nc, rgbD, fl, Math.Pow(fl, 0.25), z);
    }
}


==========================================
FILE: Theming\MaterialColors\Dislike\DislikeAnalyzer.cs
==========================================
Last Modified: 12/05/2024 13:22:39
Size: 1843 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;

namespace Bdziam.UI.Theming.MaterialColors.Dislike;

/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check and/or fix universally disliked colors.
 * <p>
 *     Color science studies of color preference indicate universal distaste for dark yellow-greens,
 *     and also show this is correlated to distate for biological waste and rotting food.
 *     <p>
 *         See Palmer and Schloss, 2010 or Schloss and Palmer's Chapter 21 in Handbook of Color
 *         Psychology (2015).
 */
public static class DislikeAnalyzer
{
    /**
     * Returns true if color is disliked.
     * <p>Disliked is defined as a dark yellow-green that is not neutral.
     */
    public static bool isDisliked(Hct hct)
    {
        var huePasses = Math.Round(hct.Hue) >= 90.0 && Math.Round(hct.Hue) <= 111.0;
        var chromaPasses = Math.Round(hct.Chroma) > 16.0;
        var tonePasses = hct.Tone < 65;

        return huePasses && chromaPasses && tonePasses;
    }

    /**
     * If color is disliked, lighten it to make it likable.
     */
    public static Hct FixIfDisliked(Hct hct)
    {
        if (isDisliked(hct)) return Hct.From(hct.Hue, hct.Chroma, 70.0);

        return hct;
    }
}


==========================================
FILE: Theming\MaterialColors\DynamicColor\ContrastCurve.cs
==========================================
Last Modified: 12/05/2024 13:22:39
Size: 2296 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.DynamicColor;

/// <summary>
///     A class containing a value that changes with the contrast level.
///     Usually represents the contrast requirements for a dynamic color on its background. The four
///     values correspond to values for contrast levels -1.0, 0.0, 0.5, and 1.0, respectively.
/// </summary>
public sealed class ContrastCurve
{
    /// <summary>
    ///     Value for contrast level 1.0
    /// </summary>
    private readonly double high;

    /// <summary>
    ///     Value for contrast level -1.0
    /// </summary>
    private readonly double low;

    /// <summary>
    ///     Value for contrast level 0.5
    /// </summary>
    private readonly double medium;

    /// <summary>
    ///     Value for contrast level 0.0
    /// </summary>
    private readonly double normal;

    /// <summary>
    ///     Creates a <see cref="ContrastCurve" /> object.
    /// </summary>
    /// <param name="low">Value for contrast level -1.0</param>
    /// <param name="normal">Value for contrast level 0.0</param>
    /// <param name="medium">Value for contrast level 0.5</param>
    /// <param name="high">Value for contrast level 1.0</param>
    public ContrastCurve(double low, double normal, double medium, double high)
    {
        this.low = low;
        this.normal = normal;
        this.medium = medium;
        this.high = high;
    }

    /// <summary>
    ///     Returns the value at a given contrast level.
    /// </summary>
    /// <param name="contrastLevel">The contrast level. 0.0 is the default (normal); -1.0 is the lowest; 1.0 is the highest.</param>
    /// <returns>The value. For contrast ratios, a number between 1.0 and 21.0.</returns>
    public double Get(double contrastLevel)
    {
        if (contrastLevel <= -1.0)
            return low;
        if (contrastLevel < 0.0)
            return MathUtils.Lerp(low, normal, (contrastLevel + 1) / 1);
        if (contrastLevel < 0.5)
            return MathUtils.Lerp(normal, medium, contrastLevel / 0.5);
        if (contrastLevel < 1.0)
            return MathUtils.Lerp(medium, high, (contrastLevel - 0.5) / 0.5);
        return high;
    }
}


==========================================
FILE: Theming\MaterialColors\DynamicColor\DynamicColor.cs
==========================================
Last Modified: 12/05/2024 13:23:44
Size: 9653 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.DynamicColor;

/// <summary>
///     A color that adjusts itself based on UI state, represented by DynamicScheme.
/// </summary>
public sealed class DynamicColor
{
    public DynamicColor(
        string name,
        Func<DynamicScheme, TonalPalette> palette,
        Func<DynamicScheme, double> tone,
        bool isBackground,
        Func<DynamicScheme, DynamicColor>? background = null,
        Func<DynamicScheme, DynamicColor>? secondBackground = null,
        ContrastCurve? contrastCurve = null,
        Func<DynamicScheme, ToneDeltaPair>? toneDeltaPair = null,
        Func<DynamicScheme, double>? opacity = null)
    {
        Name = name;
        Palette = palette;
        Tone = tone;
        IsBackground = isBackground;
        Background = background;
        SecondBackground = secondBackground;
        ContrastCurve = contrastCurve;
        ToneDeltaPair = toneDeltaPair;
        Opacity = opacity;
    }

    public string Name { get; }
    public Func<DynamicScheme, TonalPalette> Palette { get; }
    public Func<DynamicScheme, double> Tone { get; }
    public bool IsBackground { get; }
    public Func<DynamicScheme, DynamicColor>? Background { get; }
    public Func<DynamicScheme, DynamicColor>? SecondBackground { get; }
    public ContrastCurve? ContrastCurve { get; }
    public Func<DynamicScheme, ToneDeltaPair>? ToneDeltaPair { get; }
    public Func<DynamicScheme, double>? Opacity { get; }

    public static DynamicColor FromPalette(
        string name,
        Func<DynamicScheme, TonalPalette> palette,
        Func<DynamicScheme, double> tone,
        bool isBackground = false)
    {
        return new DynamicColor(name, palette, tone, isBackground);
    }

    public static DynamicColor FromArgb(string name, uint argb)
    {
        var hct = Hct.FromInt(argb);
        var palette = TonalPalette.FromInt(argb);
        return FromPalette(name, _ => palette, _ => hct.Tone);
    }

    public uint GetArgb(DynamicScheme scheme)
    {
        var argb = GetHct(scheme).ToInt();
        if (Opacity == null) return argb;

        var percentage = Opacity(scheme);
        var alpha = MathUtils.ClampInt(0, 255, (uint)Math.Round(percentage * 255));
        return (argb & 0x00FFFFFF) | (alpha << 24);
    }

    public Hct GetHct(DynamicScheme scheme)
    {
        var tone = GetTone(scheme);
        var result = Hct.FromInt(Palette(scheme).Tone((uint)tone));
        return result;
    }

    public double GetTone(DynamicScheme scheme)
    {
        var decreasingContrast = scheme.ContrastLevel < 0;

        // Case 1: dual foreground, pair of colors with delta constraint.
        if (ToneDeltaPair != null)
        {
            var toneDeltaPair = ToneDeltaPair(scheme);
            var roleA = toneDeltaPair.RoleA;
            var roleB = toneDeltaPair.RoleB;
            var delta = toneDeltaPair.Delta;
            var polarity = toneDeltaPair.Polarity;
            var stayTogether = toneDeltaPair.StayTogether;

            var bg = Background(scheme);
            var bgTone = bg.GetTone(scheme);

            var aIsNearer =
                polarity == TonePolarity.Nearer ||
                (polarity == TonePolarity.Lighter && !scheme.IsDark) ||
                (polarity == TonePolarity.Darker && scheme.IsDark);

            var nearer = aIsNearer ? roleA : roleB;
            var farther = aIsNearer ? roleB : roleA;
            var amNearer = Name.Equals(nearer.Name, StringComparison.Ordinal);
            double expansionDir = scheme.IsDark ? 1 : -1;

            // 1st round: solve to min, each
            var nContrast = nearer.ContrastCurve.Get(scheme.ContrastLevel);
            var fContrast = farther.ContrastCurve.Get(scheme.ContrastLevel);

            // Initial and adjusted tones for `nearer`
            var nInitialTone = nearer.Tone(scheme);
            var nTone = Contrast.RatioOfTones(bgTone, nInitialTone) >= nContrast
                ? nInitialTone
                : ForegroundTone(bgTone, nContrast);

            // Initial and adjusted tones for `farther`
            var fInitialTone = farther.Tone(scheme);
            var fTone = Contrast.RatioOfTones(bgTone, fInitialTone) >= fContrast
                ? fInitialTone
                : ForegroundTone(bgTone, fContrast);

            if (decreasingContrast)
            {
                nTone = ForegroundTone(bgTone, nContrast);
                fTone = ForegroundTone(bgTone, fContrast);
            }

            // If constraint is not satisfied, try another round.
            if ((fTone - nTone) * expansionDir < delta)
            {
                fTone = Math.Clamp(nTone + delta * expansionDir, 0, 100);
                if ((fTone - nTone) * expansionDir < delta) nTone = Math.Clamp(fTone - delta * expansionDir, 0, 100);
            }

            // Avoid the 50-59 awkward zone.
            if (50 <= nTone && nTone < 60)
            {
                if (expansionDir > 0)
                {
                    nTone = 60;
                    fTone = Math.Max(fTone, nTone + delta * expansionDir);
                }
                else
                {
                    nTone = 49;
                    fTone = Math.Min(fTone, nTone + delta * expansionDir);
                }
            }
            else if (50 <= fTone && fTone < 60)
            {
                if (stayTogether)
                {
                    if (expansionDir > 0)
                    {
                        nTone = 60;
                        fTone = Math.Max(fTone, nTone + delta * expansionDir);
                    }
                    else
                    {
                        nTone = 49;
                        fTone = Math.Min(fTone, nTone + delta * expansionDir);
                    }
                }
                else
                {
                    if (expansionDir > 0)
                        fTone = 60;
                    else
                        fTone = 49;
                }
            }

            return amNearer ? nTone : fTone;
        }
        else
        {
            // Case 2: No contrast pair; just solve for itself.
            var answer = Tone(scheme);

            if (Background == null) return answer; // No adjustment for colors with no background.

            var bgTone = Background(scheme).GetTone(scheme);
            var desiredRatio = ContrastCurve.Get(scheme.ContrastLevel);

            if (Contrast.RatioOfTones(bgTone, answer) >= desiredRatio)
            {
                // Do nothing; it's good enough.
            }
            else
            {
                answer = ForegroundTone(bgTone, desiredRatio);
            }

            if (decreasingContrast) answer = ForegroundTone(bgTone, desiredRatio);

            if (IsBackground && 50 <= answer && answer < 60)
                answer = Contrast.RatioOfTones(49, bgTone) >= desiredRatio ? 49 : 60;

            if (SecondBackground != null)
            {
                // Case 3: Adjust for dual backgrounds.
                var bgTone1 = Background(scheme).GetTone(scheme);
                var bgTone2 = SecondBackground(scheme).GetTone(scheme);

                var upper = Math.Max(bgTone1, bgTone2);
                var lower = Math.Min(bgTone1, bgTone2);

                if (Contrast.RatioOfTones(upper, answer) >= desiredRatio &&
                    Contrast.RatioOfTones(lower, answer) >= desiredRatio)
                    return answer;

                var lightOption = Contrast.Lighter(upper, desiredRatio);
                var darkOption = Contrast.Darker(lower, desiredRatio);

                var availables = new List<double>();
                if (lightOption != -1) availables.Add(lightOption);

                if (darkOption != -1) availables.Add(darkOption);

                var prefersLight = TonePrefersLightForeground(bgTone1) ||
                                   TonePrefersLightForeground(bgTone2);

                if (prefersLight) return lightOption == -1 ? 100 : lightOption;

                if (availables.Count == 1) return availables[0];

                return darkOption == -1 ? 0 : darkOption;
            }

            return answer;
        }
    }

    public static double ForegroundTone(double bgTone, double ratio)
    {
        var lighterTone = Contrast.LighterUnsafe(bgTone, ratio);
        var darkerTone = Contrast.DarkerUnsafe(bgTone, ratio);
        var lighterRatio = Contrast.RatioOfTones(lighterTone, bgTone);
        var darkerRatio = Contrast.RatioOfTones(darkerTone, bgTone);

        return TonePrefersLightForeground(bgTone)
            ? lighterRatio >= ratio || lighterRatio >= darkerRatio ? lighterTone : darkerTone
            : darkerRatio >= ratio || darkerRatio >= lighterRatio
                ? darkerTone
                : lighterTone;
    }

    public static bool TonePrefersLightForeground(double tone)
    {
        return Math.Round(tone) < 60;
    }

    public static bool ToneAllowsLightForeground(double tone)
    {
        return Math.Round(tone) <= 49;
    }

    public static double EnableLightForeground(double tone)
    {
        return TonePrefersLightForeground(tone) && !ToneAllowsLightForeground(tone) ? 49.0 : tone;
    }
}


==========================================
FILE: Theming\MaterialColors\DynamicColor\DynamicScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:50
Size: 10120 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.DynamicColor;

public class DynamicScheme
{
    public DynamicScheme(
        Hct sourceColorHct,
        DynamicSchemeVariant variant,
        bool isDark,
        double contrastLevel,
        TonalPalette primaryPalette,
        TonalPalette secondaryPalette,
        TonalPalette tertiaryPalette,
        TonalPalette neutralPalette,
        TonalPalette neutralVariantPalette)
        : this(sourceColorHct, variant, isDark, contrastLevel, primaryPalette, secondaryPalette, tertiaryPalette,
            neutralPalette, neutralVariantPalette, null, null, null, null)
    {
    }

    public DynamicScheme(
        Hct sourceColorHct,
        DynamicSchemeVariant variant,
        bool isDark,
        double contrastLevel,
        TonalPalette primaryPalette,
        TonalPalette secondaryPalette,
        TonalPalette tertiaryPalette,
        TonalPalette neutralPalette,
        TonalPalette neutralVariantPalette,
        TonalPalette? errorPalette,
        TonalPalette? warningPalette,
        TonalPalette? infoPalette,
        TonalPalette? successPalette)
    {
        SourceColorArgb = sourceColorHct.ToInt();
        SourceColorHct = sourceColorHct;
        Variant = variant;
        IsDark = isDark;
        ContrastLevel = contrastLevel;

        PrimaryPalette = primaryPalette;
        SecondaryPalette = secondaryPalette;
        TertiaryPalette = tertiaryPalette;
        NeutralPalette = neutralPalette;
        NeutralVariantPalette = neutralVariantPalette;
        ErrorPalette = errorPalette ?? TonalPalette.FromHueAndChroma(25.0, 84.0);
        InfoPalette = infoPalette ?? TonalPalette.FromHueAndChroma(282, 80);
        WarningPalette = warningPalette ?? TonalPalette.FromHueAndChroma(59.0, 63.0);
        ;
        SuccessPalette = successPalette ?? TonalPalette.FromHueAndChroma(139, 89.0);
        ;
    }

    public uint SourceColorArgb { get; }
    public Hct SourceColorHct { get; }
    public DynamicSchemeVariant Variant { get; }
    public bool IsDark { get; }
    public double ContrastLevel { get; }

    public TonalPalette PrimaryPalette { get; }
    public TonalPalette SecondaryPalette { get; }
    public TonalPalette TertiaryPalette { get; }
    public TonalPalette NeutralPalette { get; }
    public TonalPalette NeutralVariantPalette { get; }
    public TonalPalette ErrorPalette { get; }
    public TonalPalette SuccessPalette { get; }

    public TonalPalette InfoPalette { get; }
    public TonalPalette WarningPalette { get; }

    // Properties for key colors
    public uint PrimaryPaletteKeyColor => GetArgb(MaterialDynamicColors.PrimaryPaletteKeyColor());
    public uint SecondaryPaletteKeyColor => GetArgb(MaterialDynamicColors.SecondaryPaletteKeyColor());
    public uint TertiaryPaletteKeyColor => GetArgb(MaterialDynamicColors.TertiaryPaletteKeyColor());
    public uint NeutralPaletteKeyColor => GetArgb(MaterialDynamicColors.NeutralPaletteKeyColor());
    public uint NeutralVariantPaletteKeyColor => GetArgb(MaterialDynamicColors.NeutralVariantPaletteKeyColor());

    // Properties for colors
    public uint Background => GetArgb(MaterialDynamicColors.Background());
    public uint OnBackground => GetArgb(MaterialDynamicColors.OnBackground());
    public uint Surface => GetArgb(MaterialDynamicColors.Surface());
    public uint SurfaceDim => GetArgb(MaterialDynamicColors.SurfaceDim());
    public uint SurfaceBright => GetArgb(MaterialDynamicColors.SurfaceBright());
    public uint SurfaceContainerLowest => GetArgb(MaterialDynamicColors.SurfaceContainerLowest());
    public uint SurfaceContainerLow => GetArgb(MaterialDynamicColors.SurfaceContainerLow());
    public uint SurfaceContainer => GetArgb(MaterialDynamicColors.SurfaceContainer());
    public uint SurfaceContainerHigh => GetArgb(MaterialDynamicColors.SurfaceContainerHigh());
    public uint SurfaceContainerHighest => GetArgb(MaterialDynamicColors.SurfaceContainerHighest());
    public uint OnSurface => GetArgb(MaterialDynamicColors.OnSurface());
    public uint SurfaceVariant => GetArgb(MaterialDynamicColors.SurfaceVariant());
    public uint OnSurfaceVariant => GetArgb(MaterialDynamicColors.OnSurfaceVariant());
    public uint InverseSurface => GetArgb(MaterialDynamicColors.InverseSurface());
    public uint InverseOnSurface => GetArgb(MaterialDynamicColors.InverseOnSurface());
    public uint Outline => GetArgb(MaterialDynamicColors.Outline());
    public uint OutlineVariant => GetArgb(MaterialDynamicColors.OutlineVariant());
    public uint Shadow => GetArgb(MaterialDynamicColors.Shadow());
    public uint Scrim => GetArgb(MaterialDynamicColors.Scrim());
    public uint SurfaceTint => GetArgb(MaterialDynamicColors.SurfaceTint());
    public uint Primary => GetArgb(MaterialDynamicColors.Primary());
    public uint OnPrimary => GetArgb(MaterialDynamicColors.OnPrimary());
    public uint PrimaryContainer => GetArgb(MaterialDynamicColors.PrimaryContainer());
    public uint OnPrimaryContainer => GetArgb(MaterialDynamicColors.OnPrimaryContainer());
    public uint InversePrimary => GetArgb(MaterialDynamicColors.InversePrimary());
    public uint Secondary => GetArgb(MaterialDynamicColors.Secondary());
    public uint OnSecondary => GetArgb(MaterialDynamicColors.OnSecondary());
    public uint SecondaryContainer => GetArgb(MaterialDynamicColors.SecondaryContainer());
    public uint OnSecondaryContainer => GetArgb(MaterialDynamicColors.OnSecondaryContainer());
    public uint Tertiary => GetArgb(MaterialDynamicColors.Tertiary());
    public uint OnTertiary => GetArgb(MaterialDynamicColors.OnTertiary());
    public uint TertiaryContainer => GetArgb(MaterialDynamicColors.TertiaryContainer());
    public uint OnTertiaryContainer => GetArgb(MaterialDynamicColors.OnTertiaryContainer());
    public uint Error => GetArgb(MaterialDynamicColors.Error());
    public uint OnError => GetArgb(MaterialDynamicColors.OnError());
    public uint ErrorContainer => GetArgb(MaterialDynamicColors.ErrorContainer());
    public uint OnErrorContainer => GetArgb(MaterialDynamicColors.OnErrorContainer());
    public uint Warning => GetArgb(MaterialDynamicColors.Warning());
    public uint OnWarning => GetArgb(MaterialDynamicColors.OnWarning());
    public uint WarningContainer => GetArgb(MaterialDynamicColors.WarningContainer());
    public uint OnWarningContainer => GetArgb(MaterialDynamicColors.OnWarningContainer());
    public uint Info => GetArgb(MaterialDynamicColors.Info());
    public uint OnInfo => GetArgb(MaterialDynamicColors.OnInfo());
    public uint InfoContainer => GetArgb(MaterialDynamicColors.InfoContainer());
    public uint OnInfoContainer => GetArgb(MaterialDynamicColors.OnInfoContainer());
    public uint Success => GetArgb(MaterialDynamicColors.Success());
    public uint OnSuccess => GetArgb(MaterialDynamicColors.OnSuccess());
    public uint SuccessContainer => GetArgb(MaterialDynamicColors.SuccessContainer());

    public uint OnSuccessContainer => GetArgb(MaterialDynamicColors.OnSuccessContainer());

    // Properties for fixed colors
    public uint PrimaryFixed => GetArgb(MaterialDynamicColors.PrimaryFixed());
    public uint PrimaryFixedDim => GetArgb(MaterialDynamicColors.PrimaryFixedDim());
    public uint OnPrimaryFixed => GetArgb(MaterialDynamicColors.OnPrimaryFixed());
    public uint OnPrimaryFixedVariant => GetArgb(MaterialDynamicColors.OnPrimaryFixedVariant());
    public uint SecondaryFixed => GetArgb(MaterialDynamicColors.SecondaryFixed());
    public uint SecondaryFixedDim => GetArgb(MaterialDynamicColors.SecondaryFixedDim());
    public uint OnSecondaryFixed => GetArgb(MaterialDynamicColors.OnSecondaryFixed());
    public uint OnSecondaryFixedVariant => GetArgb(MaterialDynamicColors.OnSecondaryFixedVariant());
    public uint TertiaryFixed => GetArgb(MaterialDynamicColors.TertiaryFixed());
    public uint TertiaryFixedDim => GetArgb(MaterialDynamicColors.TertiaryFixedDim());
    public uint OnTertiaryFixed => GetArgb(MaterialDynamicColors.OnTertiaryFixed());
    public uint OnTertiaryFixedVariant => GetArgb(MaterialDynamicColors.OnTertiaryFixedVariant());

    // Properties for controls and text
    public uint ControlActivated => GetArgb(MaterialDynamicColors.ControlActivated());
    public uint ControlNormal => GetArgb(MaterialDynamicColors.ControlNormal());
    public uint ControlHighlight => GetArgb(MaterialDynamicColors.ControlHighlight());
    public uint TextPrimaryInverse => GetArgb(MaterialDynamicColors.TextPrimaryInverse());
    public uint TextSecondaryAndTertiaryInverse => GetArgb(MaterialDynamicColors.TextSecondaryAndTertiaryInverse());
    public uint TextPrimaryInverseDisableOnly => GetArgb(MaterialDynamicColors.TextPrimaryInverseDisableOnly());

    public uint TextSecondaryAndTertiaryInverseDisabled =>
        GetArgb(MaterialDynamicColors.TextSecondaryAndTertiaryInverseDisabled());

    public uint TextHintInverse => GetArgb(MaterialDynamicColors.TextHintInverse());

    public static double GetRotatedHue(Hct sourceColorHct, double[] hues, double[] rotations)
    {
        var sourceHue = sourceColorHct.Hue;
        if (rotations.Length == 1) return MathUtils.SanitizeDegreesDouble(sourceHue + rotations[0]);

        for (var i = 0; i < hues.Length - 1; i++)
        {
            var thisHue = hues[i];
            var nextHue = hues[i + 1];
            if (thisHue < sourceHue && sourceHue < nextHue)
                return MathUtils.SanitizeDegreesDouble(sourceHue + rotations[i]);
        }

        return sourceHue;
    }

    public Hct GetHct(DynamicColor dynamicColor)
    {
        return dynamicColor.GetHct(this);
    }

    public uint GetArgb(DynamicColor dynamicColor)
    {
        var hct = dynamicColor.GetHct(this);
        return hct.ToInt();
    }
}


==========================================
FILE: Theming\MaterialColors\DynamicColor\DynamicSchemeVariant.cs
==========================================
Last Modified: 12/02/2024 16:21:49
Size: 238 bytes
------------------------------------------

namespace Bdziam.UI.Theming.MaterialColors.DynamicColor;

public enum DynamicSchemeVariant
{
    Monochrome,
    Neutral,
    TonalSpot,
    Vibrant,
    Expressive,
    Fidelity,
    Content,
    Rainbow,
    FruitSalad
}


==========================================
FILE: Theming\MaterialColors\DynamicColor\MaterialDynamicColors.cs
==========================================
Last Modified: 12/05/2024 13:23:00
Size: 30697 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Dislike;

namespace Bdziam.UI.Theming.MaterialColors.DynamicColor;

public static class MaterialDynamicColors
{
    public static bool IsExtendedFidelity { get; }

    public static DynamicColor HighestSurface(DynamicScheme s)
    {
        return s.IsDark ? SurfaceBright() : SurfaceDim();
    }

    public static DynamicColor PrimaryPaletteKeyColor()
    {
        return DynamicColor.FromPalette(
            "primary_palette_key_color",
            s => s.PrimaryPalette,
            s => s.PrimaryPalette.KeyColor.Tone
        );
    }

    public static DynamicColor SecondaryPaletteKeyColor()
    {
        return DynamicColor.FromPalette(
            "secondary_palette_key_color",
            s => s.SecondaryPalette,
            s => s.SecondaryPalette.KeyColor.Tone
        );
    }

    public static DynamicColor TertiaryPaletteKeyColor()
    {
        return DynamicColor.FromPalette(
            "tertiary_palette_key_color",
            s => s.TertiaryPalette,
            s => s.TertiaryPalette.KeyColor.Tone
        );
    }

    public static DynamicColor NeutralPaletteKeyColor()
    {
        return DynamicColor.FromPalette(
            "neutral_palette_key_color",
            s => s.NeutralPalette,
            s => s.NeutralPalette.KeyColor.Tone
        );
    }

    public static DynamicColor NeutralVariantPaletteKeyColor()
    {
        return DynamicColor.FromPalette(
            "neutral_variant_palette_key_color",
            s => s.NeutralVariantPalette,
            s => s.NeutralVariantPalette.KeyColor.Tone
        );
    }

    public static DynamicColor Background()
    {
        return new DynamicColor(
            "background",
            s => s.NeutralPalette,
            s => s.IsDark ? 6.0 : 98.0,
            true
        );
    }

    public static DynamicColor OnBackground()
    {
        return new DynamicColor(
            "on_background",
            s => s.NeutralPalette,
            s => s.IsDark ? 90.0 : 10.0,
            false,
            s => Background(),
            null,
            new ContrastCurve(3.0, 3.0, 4.5, 7.0)
        );
    }

    public static DynamicColor Surface()
    {
        return new DynamicColor(
            "surface",
            s => s.NeutralPalette,
            s => s.IsDark ? 6.0 : 98.0,
            true
        );
    }

    public static DynamicColor SurfaceDim()
    {
        return new DynamicColor(
            "surface_dim",
            s => s.NeutralPalette,
            s => s.IsDark ? 6.0 : new ContrastCurve(87.0, 87.0, 80.0, 75.0).Get(s.ContrastLevel),
            true
        );
    }

    public static DynamicColor SurfaceBright()
    {
        return new DynamicColor(
            "surface_bright",
            s => s.NeutralPalette,
            s => s.IsDark ? new ContrastCurve(24.0, 24.0, 29.0, 34.0).Get(s.ContrastLevel) : 98.0,
            true
        );
    }

    public static DynamicColor SurfaceContainerLowest()
    {
        return new DynamicColor(
            "surface_container_lowest",
            s => s.NeutralPalette,
            s => s.IsDark ? new ContrastCurve(4.0, 4.0, 2.0, 0.0).Get(s.ContrastLevel) : 100.0,
            true
        );
    }

    public static DynamicColor SurfaceContainerLow()
    {
        return new DynamicColor(
            "surface_container_low",
            s => s.NeutralPalette,
            s =>
                s.IsDark
                    ? new ContrastCurve(10.0, 10.0, 11.0, 12.0).Get(s.ContrastLevel)
                    : new ContrastCurve(96.0, 96.0, 96.0, 95.0).Get(s.ContrastLevel),
            true
        );
    }

    public static DynamicColor SurfaceContainer()
    {
        return new DynamicColor(
            "surface_container",
            s => s.NeutralPalette,
            s =>
                s.IsDark
                    ? new ContrastCurve(12.0, 12.0, 16.0, 20.0).Get(s.ContrastLevel)
                    : new ContrastCurve(94.0, 94.0, 92.0, 90.0).Get(s.ContrastLevel),
            true
        );
    }

    public static DynamicColor SurfaceContainerHigh()
    {
        return new DynamicColor(
            "surface_container_high",
            s => s.NeutralPalette,
            s =>
                s.IsDark
                    ? new ContrastCurve(17.0, 17.0, 21.0, 25.0).Get(s.ContrastLevel)
                    : new ContrastCurve(92.0, 92.0, 88.0, 85.0).Get(s.ContrastLevel),
            true
        );
    }

    public static DynamicColor SurfaceContainerHighest()
    {
        return new DynamicColor(
            "surface_container_highest",
            s => s.NeutralPalette,
            s =>
                s.IsDark
                    ? new ContrastCurve(22.0, 22.0, 26.0, 30.0).Get(s.ContrastLevel)
                    : new ContrastCurve(90.0, 90.0, 84.0, 80.0).Get(s.ContrastLevel),
            true
        );
    }

    public static DynamicColor OnSurface()
    {
        return new DynamicColor(
            "on_surface",
            s => s.NeutralPalette,
            s => s.IsDark ? 90.0 : 10.0,
            false,
            s => HighestSurface(s),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor SurfaceVariant()
    {
        return new DynamicColor(
            "surface_variant",
            s => s.NeutralVariantPalette,
            s => s.IsDark ? 30.0 : 90.0,
            true
        );
    }

    public static DynamicColor OnSurfaceVariant()
    {
        return new DynamicColor(
            "on_surface_variant",
            s => s.NeutralVariantPalette,
            s => s.IsDark ? 80.0 : 30.0,
            false,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor InverseSurface()
    {
        return new DynamicColor(
            "inverse_surface",
            s => s.NeutralPalette,
            s => s.IsDark ? 90.0 : 20.0,
            false
        );
    }

    public static DynamicColor InverseOnSurface()
    {
        return new DynamicColor(
            "inverse_on_surface",
            s => s.NeutralPalette,
            s => s.IsDark ? 20.0 : 95.0,
            false,
            s => InverseSurface(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor Outline()
    {
        return new DynamicColor(
            "outline",
            s => s.NeutralVariantPalette,
            s => s.IsDark ? 60.0 : 50.0,
            false,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.5, 3.0, 4.5, 7.0)
        );
    }

    public static DynamicColor OutlineVariant()
    {
        return new DynamicColor(
            "outline_variant",
            s => s.NeutralVariantPalette,
            s => s.IsDark ? 30.0 : 80.0,
            false,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5)
        );
    }

    public static DynamicColor Shadow()
    {
        return new DynamicColor(
            "shadow",
            s => s.NeutralPalette,
            s => 0.0,
            false
        );
    }

    public static DynamicColor Scrim()
    {
        return new DynamicColor(
            "scrim",
            s => s.NeutralPalette,
            s => 0.0,
            false
        );
    }

    public static DynamicColor SurfaceTint()
    {
        return new DynamicColor(
            "surface_tint",
            s => s.PrimaryPalette,
            s => s.IsDark ? 80.0 : 40.0,
            true
        );
    }

    public static DynamicColor Primary()
    {
        return new DynamicColor(
            "primary",
            s => s.PrimaryPalette,
            s => IsMonochrome(s) ? s.IsDark ? 100.0 : 0.0 : s.IsDark ? 80.0 : 40.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0),
            s => new ToneDeltaPair(PrimaryContainer(), Primary(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnPrimary()
    {
        return new DynamicColor(
            "on_primary",
            s => s.PrimaryPalette,
            s => IsMonochrome(s) ? s.IsDark ? 10.0 : 90.0 : s.IsDark ? 20.0 : 100.0,
            false,
            s => Primary(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor PrimaryContainer()
    {
        return new DynamicColor(
            "primary_container",
            s => s.PrimaryPalette,
            s =>
            {
                if (IsFidelity(s)) return s.SourceColorHct.Tone;

                if (IsMonochrome(s)) return s.IsDark ? 85.0 : 25.0;

                return s.IsDark ? 30.0 : 90.0;
            },
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(PrimaryContainer(), Primary(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnPrimaryContainer()
    {
        return new DynamicColor(
            "on_primary_container",
            s => s.PrimaryPalette,
            s =>
            {
                if (IsFidelity(s)) return DynamicColor.ForegroundTone(PrimaryContainer().Tone(s), 4.5);

                if (IsMonochrome(s)) return s.IsDark ? 0.0 : 100.0;

                return s.IsDark ? 90.0 : 30.0;
            },
            false,
            s => PrimaryContainer(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor InversePrimary()
    {
        return new DynamicColor(
            "inverse_primary",
            s => s.PrimaryPalette,
            s => s.IsDark ? 40.0 : 80.0,
            false,
            s => InverseSurface(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0)
        );
    }

    public static DynamicColor Secondary()
    {
        return new DynamicColor(
            "secondary",
            s => s.SecondaryPalette,
            s => s.IsDark ? 80.0 : 40.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0),
            s =>
                new ToneDeltaPair(SecondaryContainer(), Secondary(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnSecondary()
    {
        return new DynamicColor(
            "on_secondary",
            s => s.SecondaryPalette,
            s =>
            {
                if (IsMonochrome(s))
                    return s.IsDark ? 10.0 : 100.0;
                return s.IsDark ? 20.0 : 100.0;
            },
            false,
            s => Secondary(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor SecondaryContainer()
    {
        return new DynamicColor(
            "secondary_container",
            s => s.SecondaryPalette,
            s =>
            {
                var initialTone = s.IsDark ? 30.0 : 90.0;
                if (IsMonochrome(s)) return s.IsDark ? 30.0 : 85.0;

                if (!IsFidelity(s)) return initialTone;

                return FindDesiredChromaByTone(
                    s.SecondaryPalette.Hue, s.SecondaryPalette.Chroma, initialTone, !s.IsDark
                );
            },
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(SecondaryContainer(), Secondary(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnSecondaryContainer()
    {
        return new DynamicColor(
            "on_secondary_container",
            s => s.SecondaryPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 90.0 : 10.0;

                if (!IsFidelity(s)) return s.IsDark ? 90.0 : 30.0;

                return DynamicColor.ForegroundTone(SecondaryContainer().Tone(s), 4.5);
            },
            false,
            s => SecondaryContainer(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor Tertiary()
    {
        return new DynamicColor(
            "tertiary",
            s => s.TertiaryPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 90.0 : 25.0;

                return s.IsDark ? 80.0 : 40.0;
            },
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0),
            s => new ToneDeltaPair(TertiaryContainer(), Tertiary(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnTertiary()
    {
        return new DynamicColor(
            "on_tertiary",
            s => s.TertiaryPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 10.0 : 90.0;

                return s.IsDark ? 20.0 : 100.0;
            },
            false,
            s => Tertiary(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor TertiaryContainer()
    {
        return new DynamicColor(
            "tertiary_container",
            s => s.TertiaryPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 60.0 : 49.0;

                if (!IsFidelity(s)) return s.IsDark ? 30.0 : 90.0;

                var proposedHct = s.TertiaryPalette[s.SourceColorHct.Tone];
                return DislikeAnalyzer.FixIfDisliked(Hct.FromInt(proposedHct)).Tone;
            },
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(TertiaryContainer(), Tertiary(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnTertiaryContainer()
    {
        return new DynamicColor(
            "on_tertiary_container",
            s => s.TertiaryPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 0.0 : 100.0;

                if (!IsFidelity(s)) return s.IsDark ? 90.0 : 30.0;

                return DynamicColor.ForegroundTone(TertiaryContainer().Tone(s), 4.5);
            },
            false,
            s => TertiaryContainer(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor Error()
    {
        return new DynamicColor(
            "error",
            s => s.ErrorPalette,
            s => s.IsDark ? 80.0 : 40.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0),
            s => new ToneDeltaPair(ErrorContainer(), Error(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor ErrorContainer()
    {
        return new DynamicColor(
            "error_container",
            s => s.ErrorPalette,
            s => s.IsDark ? 30.0 : 90.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(ErrorContainer(), Error(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnErrorContainer()
    {
        return new DynamicColor(
            "on_error_container",
            s => s.ErrorPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 90.0 : 10.0;

                return s.IsDark ? 90.0 : 30.0;
            },
            false,
            s => ErrorContainer(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor OnError()
    {
        return new DynamicColor(
            "on_error",
            s => s.ErrorPalette,
            s => s.IsDark ? 20.0 : 100.0,
            false,
            s => Error(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor Success()
    {
        return new DynamicColor(
            "success",
            s => s.SuccessPalette,
            s => s.IsDark ? 80.0 : 40.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0),
            s => new ToneDeltaPair(SuccessContainer(), Success(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor SuccessContainer()
    {
        return new DynamicColor(
            "success_container",
            s => s.SuccessPalette,
            s => s.IsDark ? 30.0 : 90.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(SuccessContainer(), Success(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnSuccessContainer()
    {
        return new DynamicColor(
            "on_success_container",
            s => s.ErrorPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 90.0 : 10.0;

                return s.IsDark ? 90.0 : 30.0;
            },
            false,
            s => SuccessContainer(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor OnSuccess()
    {
        return new DynamicColor(
            "on_success",
            s => s.SuccessPalette,
            s => s.IsDark ? 20.0 : 100.0,
            false,
            s => Success(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor Info()
    {
        return new DynamicColor(
            "info",
            s => s.InfoPalette,
            s => s.IsDark ? 80.0 : 40.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0),
            s => new ToneDeltaPair(InfoContainer(), Info(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor InfoContainer()
    {
        return new DynamicColor(
            "info_container",
            s => s.InfoPalette,
            s => s.IsDark ? 30.0 : 90.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(InfoContainer(), Info(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnInfoContainer()
    {
        return new DynamicColor(
            "on_info_container",
            s => s.InfoPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 90.0 : 10.0;

                return s.IsDark ? 90.0 : 30.0;
            },
            false,
            s => InfoContainer(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor OnInfo()
    {
        return new DynamicColor(
            "on_info",
            s => s.InfoPalette,
            s => s.IsDark ? 20.0 : 100.0,
            false,
            s => Info(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor Warning()
    {
        return new DynamicColor(
            "warning",
            s => s.WarningPalette,
            s => s.IsDark ? 80.0 : 40.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 7.0),
            s => new ToneDeltaPair(WarningContainer(), Warning(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor WarningContainer()
    {
        return new DynamicColor(
            "warning_container",
            s => s.WarningPalette,
            s => s.IsDark ? 30.0 : 90.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(WarningContainer(), Warning(), 10.0, TonePolarity.Nearer, false)
        );
    }

    public static DynamicColor OnWarningContainer()
    {
        return new DynamicColor(
            "on_warning_container",
            s => s.WarningPalette,
            s =>
            {
                if (IsMonochrome(s)) return s.IsDark ? 90.0 : 10.0;

                return s.IsDark ? 90.0 : 30.0;
            },
            false,
            s => WarningContainer(),
            null,
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor OnWarning()
    {
        return new DynamicColor(
            "on_warning",
            s => s.WarningPalette,
            s => s.IsDark ? 20.0 : 100.0,
            false,
            s => Warning(),
            null,
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor PrimaryFixed()
    {
        return new DynamicColor(
            "primary_fixed",
            s => s.PrimaryPalette,
            s => IsMonochrome(s) ? 40.0 : 90.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(PrimaryFixed(), PrimaryFixedDim(), 10.0, TonePolarity.Lighter, true)
        );
    }

    public static DynamicColor PrimaryFixedDim()
    {
        return new DynamicColor(
            "primary_fixed_dim",
            s => s.PrimaryPalette,
            s => IsMonochrome(s) ? 30.0 : 80.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s => new ToneDeltaPair(PrimaryFixed(), PrimaryFixedDim(), 10.0, TonePolarity.Lighter, true)
        );
    }

    public static DynamicColor OnPrimaryFixed()
    {
        return new DynamicColor(
            "on_primary_fixed",
            s => s.PrimaryPalette,
            s => IsMonochrome(s) ? 100.0 : 10.0,
            false,
            s => PrimaryFixedDim(),
            s => PrimaryFixed(),
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor OnPrimaryFixedVariant()
    {
        return new DynamicColor(
            "on_primary_fixed_variant",
            s => s.PrimaryPalette,
            s => IsMonochrome(s) ? 90.0 : 30.0,
            false,
            s => PrimaryFixedDim(),
            s => PrimaryFixed(),
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor SecondaryFixed()
    {
        return new DynamicColor(
            "secondary_fixed",
            s => s.SecondaryPalette,
            s => IsMonochrome(s) ? 80.0 : 90.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s =>
                new ToneDeltaPair(SecondaryFixed(), SecondaryFixedDim(), 10.0, TonePolarity.Lighter, true)
        );
    }

    public static DynamicColor SecondaryFixedDim()
    {
        return new DynamicColor(
            "secondary_fixed_dim",
            s => s.SecondaryPalette,
            s => IsMonochrome(s) ? 70.0 : 80.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s =>
                new ToneDeltaPair(SecondaryFixed(), SecondaryFixedDim(), 10.0, TonePolarity.Lighter, true)
        );
    }

    public static DynamicColor OnSecondaryFixed()
    {
        return new DynamicColor(
            "on_secondary_fixed",
            s => s.SecondaryPalette,
            s => 10.0,
            false,
            s => SecondaryFixedDim(),
            s => SecondaryFixed(),
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor OnSecondaryFixedVariant()
    {
        return new DynamicColor(
            "on_secondary_fixed_variant",
            s => s.SecondaryPalette,
            s => IsMonochrome(s) ? 25.0 : 30.0,
            false,
            s => SecondaryFixedDim(),
            s => SecondaryFixed(),
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor TertiaryFixed()
    {
        return new DynamicColor(
            "tertiary_fixed",
            s => s.TertiaryPalette,
            s => IsMonochrome(s) ? 40.0 : 90.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s =>
                new ToneDeltaPair(TertiaryFixed(), TertiaryFixedDim(), 10.0, TonePolarity.Lighter, true)
        );
    }

    public static DynamicColor TertiaryFixedDim()
    {
        return new DynamicColor(
            "tertiary_fixed_dim",
            s => s.TertiaryPalette,
            s => IsMonochrome(s) ? 30.0 : 80.0,
            true,
            s => HighestSurface(s),
            null,
            new ContrastCurve(1.0, 1.0, 3.0, 4.5),
            s =>
                new ToneDeltaPair(TertiaryFixed(), TertiaryFixedDim(), 10.0, TonePolarity.Lighter, true)
        );
    }

    public static DynamicColor OnTertiaryFixed()
    {
        return new DynamicColor(
            "on_tertiary_fixed",
            s => s.TertiaryPalette,
            s => IsMonochrome(s) ? 100.0 : 10.0,
            false,
            s => TertiaryFixedDim(),
            s => TertiaryFixed(),
            new ContrastCurve(4.5, 7.0, 11.0, 21.0)
        );
    }

    public static DynamicColor OnTertiaryFixedVariant()
    {
        return new DynamicColor(
            "on_tertiary_fixed_variant",
            s => s.TertiaryPalette,
            s => IsMonochrome(s) ? 90.0 : 30.0,
            false,
            s => TertiaryFixedDim(),
            s => TertiaryFixed(),
            new ContrastCurve(3.0, 4.5, 7.0, 11.0)
        );
    }

    public static DynamicColor ControlActivated()
    {
        return DynamicColor.FromPalette(
            "control_activated", s => s.PrimaryPalette, s => s.IsDark ? 30.0 : 90.0
        );
    }

    public static DynamicColor ControlNormal()
    {
        return DynamicColor.FromPalette(
            "control_normal", s => s.NeutralVariantPalette, s => s.IsDark ? 80.0 : 30.0
        );
    }

    public static DynamicColor ControlHighlight()
    {
        return new DynamicColor(
            "control_highlight",
            s => s.NeutralPalette,
            s => s.IsDark ? 100.0 : 0.0,
            false,
            null,
            null,
            null,
            null,
            s => s.IsDark ? 0.20 : 0.12
        );
    }

    public static DynamicColor TextPrimaryInverse()
    {
        return DynamicColor.FromPalette(
            "text_primary_inverse",
            s => s.NeutralPalette,
            s => s.IsDark ? 10.0 : 90.0
        );
    }

    public static DynamicColor TextSecondaryAndTertiaryInverse()
    {
        return DynamicColor.FromPalette(
            "text_secondary_and_tertiary_inverse",
            s => s.NeutralVariantPalette,
            s => s.IsDark ? 30.0 : 80.0
        );
    }

    public static DynamicColor TextPrimaryInverseDisableOnly()
    {
        return DynamicColor.FromPalette(
            "text_primary_inverse_disable_only",
            s => s.NeutralPalette,
            s => s.IsDark ? 10.0 : 90.0
        );
    }

    public static DynamicColor TextSecondaryAndTertiaryInverseDisabled()
    {
        return DynamicColor.FromPalette(
            "text_secondary_and_tertiary_inverse_disabled",
            s => s.NeutralPalette,
            s => s.IsDark ? 10.0 : 90.0
        );
    }

    public static DynamicColor TextHintInverse()
    {
        return DynamicColor.FromPalette(
            "text_hint_inverse",
            s => s.NeutralPalette,
            s => s.IsDark ? 10.0 : 90.0
        );
    }

    private static bool IsFidelity(DynamicScheme scheme)
    {
        if (IsExtendedFidelity &&
            scheme.Variant != DynamicSchemeVariant.Monochrome &&
            scheme.Variant != DynamicSchemeVariant.Neutral)
            return true;

        return scheme.Variant == DynamicSchemeVariant.Fidelity || scheme.Variant == DynamicSchemeVariant.Content;
    }

    private static bool IsMonochrome(DynamicScheme scheme)
    {
        return scheme.Variant == DynamicSchemeVariant.Monochrome;
    }

    public static double FindDesiredChromaByTone(double hue, double chroma, double tone, bool byDecreasingTone)
    {
        var answer = tone;

        var closestToChroma = Hct.From(hue, chroma, tone);
        if (closestToChroma.Chroma < chroma)
        {
            var chromaPeak = closestToChroma.Chroma;
            while (closestToChroma.Chroma < chroma)
            {
                answer += byDecreasingTone ? -1.0 : 1.0;
                var potentialSolution = Hct.From(hue, chroma, answer);
                if (chromaPeak > potentialSolution.Chroma) break;

                if (Math.Abs(potentialSolution.Chroma - chroma) < 0.4) break;

                var potentialDelta = Math.Abs(potentialSolution.Chroma - chroma);
                var currentDelta = Math.Abs(closestToChroma.Chroma - chroma);
                if (potentialDelta < currentDelta) closestToChroma = potentialSolution;

                chromaPeak = Math.Max(chromaPeak, potentialSolution.Chroma);
            }
        }

        return answer;
    }
}


==========================================
FILE: Theming\MaterialColors\DynamicColor\ToneDeltaPair.cs
==========================================
Last Modified: 12/05/2024 13:23:11
Size: 2021 bytes
------------------------------------------

namespace Bdziam.UI.Theming.MaterialColors.DynamicColor;

/// <summary>
///     Documents a constraint between two DynamicColors, in which their tones must have a certain distance from each
///     other.
/// </summary>
public sealed class ToneDeltaPair
{
    /// <summary>
    ///     Documents a constraint in tone distance between two DynamicColors.
    /// </summary>
    /// <param name="roleA">The first role in a pair.</param>
    /// <param name="roleB">The second role in a pair.</param>
    /// <param name="delta">Required difference between tones. Absolute value, negative values have undefined behavior.</param>
    /// <param name="polarity">The relative relation between tones of RoleA and RoleB, as described above.</param>
    /// <param name="stayTogether">Whether these two roles should stay on the same side of the "awkward zone" (T50-59).</param>
    public ToneDeltaPair(DynamicColor roleA, DynamicColor roleB, double delta, TonePolarity polarity, bool stayTogether)
    {
        RoleA = roleA;
        RoleB = roleB;
        Delta = delta;
        Polarity = polarity;
        StayTogether = stayTogether;
    }

    /// <summary>
    ///     The first role in a pair.
    /// </summary>
    public DynamicColor RoleA { get; }

    /// <summary>
    ///     The second role in a pair.
    /// </summary>
    public DynamicColor RoleB { get; }

    /// <summary>
    ///     Required difference between tones. Absolute value, negative values have undefined behavior.
    /// </summary>
    public double Delta { get; }

    /// <summary>
    ///     The relative relation between tones of RoleA and RoleB, as described above.
    /// </summary>
    public TonePolarity Polarity { get; }

    /// <summary>
    ///     Whether these two roles should stay on the same side of the "awkward zone" (T50-59).
    ///     This is necessary for certain cases where one role has two backgrounds.
    /// </summary>
    public bool StayTogether { get; }
}


==========================================
FILE: Theming\MaterialColors\DynamicColor\TonePolarity.cs
==========================================
Last Modified: 12/02/2024 16:21:49
Size: 146 bytes
------------------------------------------

namespace Bdziam.UI.Theming.MaterialColors.DynamicColor;

public enum TonePolarity
{
    Darker,
    Lighter,
    Nearer,
    Farther
}


==========================================
FILE: Theming\MaterialColors\Palettes\KeyColor.cs
==========================================
Last Modified: 12/05/2024 13:22:31
Size: 3204 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;

namespace Bdziam.UI.Theming.MaterialColors.Palettes;

/**
 * Key color is a color that represents the hue and chroma of a tonal palette.
 */
public sealed class KeyColor
{
    private const double MAX_CHROMA_VALUE = 200.0;

    // Cache that maps tone to max chroma to avoid duplicated HCT calculation.
    private readonly Dictionary<uint, double> chromaCache = new();

    /**
     * Key color is a color that represents the hue and chroma of a tonal palette
     */
    public KeyColor(double hue, double requestedChroma)
    {
        Hue = hue;
        RequestedChroma = requestedChroma;
    }

    public double Hue { get; }
    private double RequestedChroma { get; }

    /**
     * Creates a key color from a [hue] and a [chroma]. The key color is the first tone, starting
     * from T50, matching the given hue and chroma.
     * 
     * @return Key color [Hct]
     */
    public Hct Create()
    {
        // Pivot around T50 because T50 has the most chroma available, on
        // average. Thus it is most likely to have a direct answer.
        uint pivotTone = 50;
        uint toneStepSize = 1;
        // Epsilon to accept values slightly higher than the requested chroma.
        var epsilon = 0.01;

        // Binary search to find the tone that can provide a chroma that is closest
        // to the requested chroma.
        uint lowerTone = 0;
        uint upperTone = 100;
        while (lowerTone < upperTone)
        {
            var midTone = (lowerTone + upperTone) / 2;
            var isAscending = maxChroma(midTone) < maxChroma(midTone + toneStepSize);
            var sufficientChroma = maxChroma(midTone) >= RequestedChroma - epsilon;

            if (sufficientChroma)
            {
                // Either range [lowerTone, midTone] or [midTone, upperTone] has
                // the answer, so search in the range that is closer the pivot tone.
                if (Math.Abs(lowerTone - pivotTone) < Math.Abs(upperTone - pivotTone))
                {
                    upperTone = midTone;
                }
                else
                {
                    if (lowerTone == midTone) return Hct.From(Hue, RequestedChroma, lowerTone);
                    lowerTone = midTone;
                }
            }
            else
            {
                // As there is no sufficient chroma in the midTone, follow the direction to the chroma
                // peak.
                if (isAscending)
                    lowerTone = midTone + toneStepSize;
                else
                    // Keep midTone for potential chroma peak.
                    upperTone = midTone;
            }
        }

        return Hct.From(Hue, RequestedChroma, lowerTone);
    }

    // Find the maximum chroma for a given tone
    private double maxChroma(uint tone)
    {
        if (!chromaCache.TryGetValue(tone, out var chroma))
        {
            var newChroma = Hct.From(Hue, MAX_CHROMA_VALUE, tone).Chroma;
            chromaCache.Add(tone, newChroma);
        }

        return chromaCache[tone];
    }
}


==========================================
FILE: Theming\MaterialColors\Palettes\TonalPalette.cs
==========================================
Last Modified: 12/05/2024 13:23:15
Size: 3185 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Bdziam.UI.Theming.MaterialColors.ColorSpace;

namespace Bdziam.UI.Theming.MaterialColors.Palettes;

/// <summary>
///     A convenience class for retrieving colors that are constant in hue and
///     chroma, but vary in tone.
/// </summary>
public class TonalPalette
{
    protected Dictionary<uint, uint> _cache = new();

    private TonalPalette(double hue, double chroma, Hct keyColor)
    {
        _cache = new Dictionary<uint, uint>();
        Hue = hue;
        Chroma = chroma;
        KeyColor = keyColor;
    }

    public double Hue { get; protected set; }
    public double Chroma { get; protected set; }
    public Hct KeyColor { get; protected set; }


    /// <summary>Creates an ARGB color with HCT hue and chroma of this TonalPalette instance, and the provided HCT tone.</summary>
    /// <param name="tone">HCT tone, measured from 0 to 100.</param>
    /// <returns>ARGB representation of a color with that tone.</returns>
    public uint this[uint tone] => Tone(tone);

    /**
     * Create tones using the HCT hue and chroma from a color.
     * 
     * @param argb ARGB representation of a color
     * @return Tones matching that color's hue and chroma.
     */
    public static TonalPalette FromInt(uint argb)
    {
        return FromHct(Hct.FromInt(argb));
    }

    /**
     * Create tones using a HCT color.
     * 
     * @param hct HCT representation of a color.
     * @return Tones matching that color's hue and chroma.
     */
    public static TonalPalette FromHct(Hct hct)
    {
        return new TonalPalette(hct.Hue, hct.Chroma, hct);
    }

    /**
     * Create tones from a defined HCT hue and chroma.
     * 
     * @param hue HCT hue
     * @param chroma HCT chroma
     * @return Tones matching hue and chroma.
     */
    public static TonalPalette FromHueAndChroma(double hue, double chroma)
    {
        var keyColor = new KeyColor(hue, chroma).Create();
        return new TonalPalette(hue, chroma, keyColor);
    }

    /**
     * Create an ARGB color with HCT hue and chroma of this Tones instance, and the provided HCT tone.
     * 
     * @param tone HCT tone, measured from 0 to 100.
     * @return ARGB representation of a color with that tone.
     */
    public uint Tone(uint tone)
    {
        if (!_cache.TryGetValue(tone, out var color))
        {
            color = Hct.From(Hue, Chroma, tone).ToInt();
            _cache.Add(tone, color);
        }

        return color;
    }
}


==========================================
FILE: Theming\MaterialColors\Scheme\ContentScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:27
Size: 1085 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Dislike;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Temperature;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

public class ContentScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(
    sourceColorHct,
    DynamicSchemeVariant.Content,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, sourceColorHct.Chroma),
    TonalPalette.FromHueAndChroma(
        sourceColorHct.Hue,
        Math.Max(sourceColorHct.Chroma - 32.0, sourceColorHct.Chroma * 0.5)),
    TonalPalette.FromHct(
        DislikeAnalyzer.FixIfDisliked(
            new TemperatureCache(sourceColorHct)
                .GetAnalogousColors(3, 6)[2])),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, sourceColorHct.Chroma / 8.0),
    TonalPalette.FromHueAndChroma(
        sourceColorHct.Hue, sourceColorHct.Chroma / 8.0 + 4.0))
{
}


==========================================
FILE: Theming\MaterialColors\Scheme\DynamicSchemeMap.cs
==========================================
Last Modified: 12/05/2024 13:22:32
Size: 1769 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

public static class DynamicSchemeMap
{
    public static DynamicScheme GetDynamicScheme(Hct sourceColorHct, bool isDark, double contrastLevel,
        DynamicSchemeVariant dynamicSchemeVariant)
    {
        switch (dynamicSchemeVariant)
        {
            case DynamicSchemeVariant.Monochrome:
                return new MonochromeScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.Neutral:
                return new NeutralScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.TonalSpot:
                return new TonalSpotScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.Vibrant:
                return new VibrantScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.Expressive:
                return new ExpressiveScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.Fidelity:
                return new FidelityScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.Content:
                return new ContentScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.Rainbow:
                return new RainbowScheme(sourceColorHct, isDark, contrastLevel);
            case DynamicSchemeVariant.FruitSalad:
                return new FruitSaladScheme(sourceColorHct, isDark, contrastLevel);
            default:
                throw new ArgumentOutOfRangeException(nameof(dynamicSchemeVariant), dynamicSchemeVariant, null);
        }
    }
}


==========================================
FILE: Theming\MaterialColors\Scheme\ExpressiveScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:37
Size: 1376 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

public class ExpressiveScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.Expressive,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(
        MathUtils.SanitizeDegreesDouble(sourceColorHct.Hue + 240.0), 40.0),
    TonalPalette.FromHueAndChroma(
        GetRotatedHue(sourceColorHct, Hues, SecondaryRotations), 24.0),
    TonalPalette.FromHueAndChroma(
        GetRotatedHue(sourceColorHct, Hues, TertiaryRotations), 32.0),
    TonalPalette.FromHueAndChroma(
        MathUtils.SanitizeDegreesDouble(sourceColorHct.Hue + 15.0), 8.0),
    TonalPalette.FromHueAndChroma(
        MathUtils.SanitizeDegreesDouble(sourceColorHct.Hue + 15.0), 12.0))
{
    // NOMUTANTS--arbitrary increments/decrements, correctly, still passes tests.
    private static readonly double[] Hues = [0, 21, 51, 121, 151, 191, 271, 321, 360];
    private static readonly double[] SecondaryRotations = [45, 95, 45, 20, 45, 90, 45, 45, 45];
    private static readonly double[] TertiaryRotations = [120, 120, 20, 45, 20, 15, 20, 120, 120];
}


==========================================
FILE: Theming\MaterialColors\Scheme\FidelityScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:31
Size: 1037 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Dislike;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Temperature;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

public class FidelityScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.Fidelity,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, sourceColorHct.Chroma),
    TonalPalette.FromHueAndChroma(
        sourceColorHct.Hue,
        Math.Max(sourceColorHct.Chroma - 32.0, sourceColorHct.Chroma * 0.5)),
    TonalPalette.FromHct(
        DislikeAnalyzer.FixIfDisliked(new TemperatureCache(sourceColorHct).GetComplement())),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, sourceColorHct.Chroma / 8.0),
    TonalPalette.FromHueAndChroma(
        sourceColorHct.Hue, sourceColorHct.Chroma / 8.0 + 4.0))
{
}


==========================================
FILE: Theming\MaterialColors\Scheme\FruitSaladTheme.cs
==========================================
Last Modified: 12/05/2024 13:22:28
Size: 971 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

/// <summary>
///     A playful theme - the source color's hue does not appear in the theme.
/// </summary>
public class FruitSaladScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.FruitSalad,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(
        MathUtils.SanitizeDegreesDouble(sourceColorHct.Hue - 50.0), 48.0),
    TonalPalette.FromHueAndChroma(
        MathUtils.SanitizeDegreesDouble(sourceColorHct.Hue - 50.0), 36.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 36.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 10.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 16.0));


==========================================
FILE: Theming\MaterialColors\Scheme\MonochromeScheme.cs
==========================================
Last Modified: 12/05/2024 13:23:17
Size: 808 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

/// <summary>
///     A monochrome theme, colors are purely black / white / gray.
/// </summary>
public class MonochromeScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.Monochrome,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 0.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 0.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 0.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 0.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 0.0));


==========================================
FILE: Theming\MaterialColors\Scheme\NeutralScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:50
Size: 838 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

/// <summary>
///     A theme that's slightly more chromatic than monochrome, which is purely black / white / gray.
/// </summary>
public class NeutralScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.Neutral,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 12.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 8.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 16.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 2.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 2.0));


==========================================
FILE: Theming\MaterialColors\Scheme\RainbowScheme.cs
==========================================
Last Modified: 12/05/2024 13:23:16
Size: 913 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

/// <summary>
///     A playful theme - the source color's hue does not appear in the theme.
/// </summary>
public class RainbowScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.Rainbow,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 48.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 16.0),
    TonalPalette.FromHueAndChroma(
        MathUtils.SanitizeDegreesDouble(sourceColorHct.Hue + 60.0), 24.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 0.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 0.0));


==========================================
FILE: Theming\MaterialColors\Scheme\TonalSpotScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:30
Size: 911 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

/// <summary>
///     A calm theme, sedated colors that aren't particularly chromatic.
/// </summary>
public class TonalSpotScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.TonalSpot,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 36.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 16.0),
    TonalPalette.FromHueAndChroma(
        MathUtils.SanitizeDegreesDouble(sourceColorHct.Hue + 60.0), 24.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 6.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 8.0));


==========================================
FILE: Theming\MaterialColors\Scheme\VibrantScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:33
Size: 1208 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Palettes;

namespace Bdziam.UI.Theming.MaterialColors.Scheme;

/// <summary>
///     A loud theme, colorfulness is maximum for Primary palette, increased for others.
/// </summary>
public class VibrantScheme(Hct sourceColorHct, bool isDark, double contrastLevel) : DynamicScheme(sourceColorHct,
    DynamicSchemeVariant.Vibrant,
    isDark,
    contrastLevel,
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 200.0),
    TonalPalette.FromHueAndChroma(
        GetRotatedHue(sourceColorHct, Hues, SecondaryRotations), 24.0),
    TonalPalette.FromHueAndChroma(
        GetRotatedHue(sourceColorHct, Hues, TertiaryRotations), 32.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 10.0),
    TonalPalette.FromHueAndChroma(sourceColorHct.Hue, 12.0))
{
    private static readonly double[] Hues = [0, 41, 61, 101, 131, 181, 251, 301, 360];
    private static readonly double[] SecondaryRotations = [18, 15, 10, 12, 15, 18, 15, 12, 12];
    private static readonly double[] TertiaryRotations = [35, 30, 20, 25, 30, 35, 30, 25, 25];
}


==========================================
FILE: Theming\MaterialColors\Score\Score.cs
==========================================
Last Modified: 12/05/2024 13:22:29
Size: 7131 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.Score;

public static class Scorer
{
    /// <summary>
    ///     Given a large set of colors, remove colors that are unsuitable for a UI theme, and rank the rest
    ///     based on suitability.
    /// </summary>
    /// <remarks>
    ///     Enables use of a high cluster count for image quantization, thus ensuring colors aren't
    ///     muddied, while curating the high cluster count to a much smaller number of appropriate choices.
    /// </remarks>
    private const double CUTOFF_CHROMA = 15;

    private const double CUTOFF_EXCITED_PROPORTION = 0.01;
    private const double CUTOFF_TONE = 10;
    private const double TARGET_CHROMA = 48;
    private const double WEIGHT_PROPORTION = 0.7;
    private const double WEIGHT_CHROMA_ABOVE = 0.3;
    private const double WEIGHT_CHROMA_BELOW = 0.1;

    public const uint Default = 0xff4285F4; // Google Blue

    /// <summary>
    ///     Given a map with keys of colors and values of how often the color appears, rank the colors
    ///     based on suitability for being used for a UI theme.
    /// </summary>
    /// <param name="colorsToPopulation">
    ///     A dictionary with keys of colors and values of how often the color
    ///     appears, usually from a source image.
    /// </param>
    /// <returns>
    ///     A list of colors sorted by suitability for a UI theme. The most suitable color is the first
    ///     item, the least suitable is the last. There will always be at least one color returned. If
    ///     all the input colors were not suitable for a theme, a default fallback color will be provided,
    ///     Google Blue.
    /// </returns>
    public static List<uint> Score(Dictionary<uint, uint> colorsToPopulation)
    {
        // Determine the total count of all colors.
        double populationSum = 0;
        foreach (var entry in colorsToPopulation) populationSum += entry.Value;

        // Turn the count of each color into a proportion by dividing by the total
        // count. Also, fill a cache of CAM16 colors representing each color, and
        // record the proportion of colors for each CAM16 hue.
        Dictionary<uint, Cam16> colorsToCam = new();
        var hueProportions = new double[361];
        foreach (var entry in colorsToPopulation)
        {
            var color = entry.Key;
            double population = entry.Value;
            var proportion = population / populationSum;

            var cam = Cam16.FromInt(color);
            colorsToCam[color] = cam;

            var hue = (uint)Math.Round(cam.Hue);
            hueProportions[hue] += proportion;
        }

        // Determine the proportion of the colors around each color, by summing the
        // proportions around each color's hue.
        Dictionary<uint, double> colorsToExcitedProportion = new();
        foreach (var entry in colorsToCam)
        {
            var color = entry.Key;
            var cam = entry.Value;
            var hue = (int)Math.Round(cam.Hue);

            double excitedProportion = 0;
            for (var j = hue - 15; j < hue + 15; j++)
            {
                var neighborHue = MathUtils.SanitizeDegreesInt(j);
                excitedProportion += hueProportions[neighborHue];
            }

            colorsToExcitedProportion[color] = excitedProportion;
        }

        // Score the colors by their proportion, as well as how chromatic they are.
        Dictionary<uint, double> colorsToScore = new();
        foreach (var entry in colorsToCam)
        {
            var color = entry.Key;
            var cam = entry.Value;

            var proportion = colorsToExcitedProportion[color];
            var proportionScore = proportion * 100.0 * WEIGHT_PROPORTION;

            var chromaWeight =
                cam.Chroma < TARGET_CHROMA ? WEIGHT_CHROMA_BELOW : WEIGHT_CHROMA_ABOVE;
            var chromaScore = (cam.Chroma - TARGET_CHROMA) * chromaWeight;

            var score = proportionScore + chromaScore;
            colorsToScore[color] = score;
        }

        // Remove colors that are unsuitable, ex. very dark or unchromatic colors.
        // Also, remove colors that are very similar in hue.
        var filteredColors = Filter(colorsToExcitedProportion, colorsToCam);
        Dictionary<uint, double> filteredColorsToScore = new();
        foreach (var color in filteredColors) filteredColorsToScore[color] = colorsToScore[color];

        // Ensure the list of colors returned is sorted such that the first in the
        // list is the most suitable, and the last is the least suitable.
        List<KeyValuePair<uint, double>> entryList = new(filteredColorsToScore);
        entryList.Sort((a, b) => b.Value.CompareTo(a.Value));
        List<uint> colorsByScoreDescending = new();
        foreach (var entry in entryList)
        {
            var color = entry.Key;
            var cam = colorsToCam[color];
            var duplicateHue = false;

            foreach (var alreadyChosenColor in colorsByScoreDescending)
            {
                var alreadyChosenCam = colorsToCam[alreadyChosenColor];
                if (MathUtils.DifferenceDegrees(cam.Hue, alreadyChosenCam.Hue) < 15)
                {
                    duplicateHue = true;
                    break;
                }
            }

            if (duplicateHue) continue;
            colorsByScoreDescending.Add(entry.Key);
        }

        // Ensure that at least one color is returned.
        if (!colorsByScoreDescending.Any()) colorsByScoreDescending.Add(Default);
        return colorsByScoreDescending;
    }

    private static List<uint> Filter(
        Dictionary<uint, double> colorsToExcitedProportion, Dictionary<uint, Cam16> colorsToCam)
    {
        List<uint> filtered = new();
        foreach (var entry in colorsToCam)
        {
            var color = entry.Key;
            var cam = entry.Value;
            var proportion = colorsToExcitedProportion[color];

            if (cam.Chroma >= CUTOFF_CHROMA
                && ColorUtils.LStarFromArgb(color) >= CUTOFF_TONE
                && proportion >= CUTOFF_EXCITED_PROPORTION)
                filtered.Add(color);
        }

        return filtered;
    }
}


==========================================
FILE: Theming\MaterialColors\Temperature\TemperatureCache.cs
==========================================
Last Modified: 12/05/2024 13:22:42
Size: 8826 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors.Temperature;

/**
 * Design utilities using color temperature theory.
 * <p>
 *     Analogous colors, complementary color, and cache to efficiently, lazily, generate data for
 *     calculations when needed.
 */
public sealed class TemperatureCache
{
    private readonly Hct _input;

    private Hct _precomputedComplement;
    private List<Hct> _precomputedHctsByHue;
    private List<Hct> _precomputedHctsByTemp;
    private Dictionary<Hct, double> _precomputedTempsByHct;

    private TemperatureCache()
    {
        throw new NotSupportedException();
    }

    /**
     * Create a cache that allows calculation of ex. complementary and analogous colors.
     * 
     * @param input Color to find complement/analogous colors of. Any colors will have the same tone,
     * and chroma as the input color, modulo any restrictions due to the other hues having lower
     * limits on chroma.
     */
    public TemperatureCache(Hct input)
    {
        _input = input;
    }

    /**
     * A color that complements the input color aesthetically.
     * <p>
     *     In art, this is usually described as being across the color wheel. History of this shows
     *     intent as a color that is just as cool-warm as the input color is warm-cool.
     */
    public Hct GetComplement()
    {
        if (_precomputedComplement != null) return _precomputedComplement;

        var coldestHue = GetColdest().Hue;
        var coldestTemp = GetTempsByHct()[GetColdest()];

        var warmestHue = GetWarmest().Hue;
        var warmestTemp = GetTempsByHct()[GetWarmest()];
        var range = warmestTemp - coldestTemp;
        var startHueIsColdestToWarmest = IsBetween(_input.Hue, coldestHue, warmestHue);
        var startHue = startHueIsColdestToWarmest ? warmestHue : coldestHue;
        var endHue = startHueIsColdestToWarmest ? coldestHue : warmestHue;
        var directionOfRotation = 1.0;
        var smallestError = 1000.0;
        var answer = GetHctsByHue()[(int)Math.Round(_input.Hue)];

        var complementRelativeTemp = 1.0 - GetRelativeTemperature(_input);

        for (var hueAddend = 0.0; hueAddend <= 360.0; hueAddend += 1.0)
        {
            var hue = MathUtils.SanitizeDegreesDouble(startHue + directionOfRotation * hueAddend);
            if (!IsBetween(hue, startHue, endHue)) continue;
            var possibleAnswer = GetHctsByHue()[(int)Math.Round(hue)];
            var relativeTemp = (GetTempsByHct()[possibleAnswer] - coldestTemp) / range;
            var error = Math.Abs(complementRelativeTemp - relativeTemp);
            if (error < smallestError)
            {
                smallestError = error;
                answer = possibleAnswer;
            }
        }

        _precomputedComplement = answer;
        return _precomputedComplement;
    }

    /**
     * 5 colors that pair well with the input color.
     * <p>The colors are equidistant in temperature and adjacent in hue.
     */
    public List<Hct> GetAnalogousColors()
    {
        return GetAnalogousColors(5, 12);
    }

    /**
     * A set of colors with differing hues, equidistant in temperature.
     * <p>
     *     Behavior is undefined when count or divisions is 0. When divisions
     *     < count, colors repeat.
     * 
     *         @ param count The number of colors to return, includes the input color.
     *         @ param divisions The number of divisions on the color wheel.
     */
    public List<Hct> GetAnalogousColors(int count, int divisions)
    {
        var startHue = (int)Math.Round(_input.Hue);
        var startHct = GetHctsByHue()[startHue];
        var lastTemp = GetRelativeTemperature(startHct);

        var allColors = new List<Hct> { startHct };

        var absoluteTotalTempDelta = 0.0;
        for (var i = 0; i < 360; i++)
        {
            var hue = MathUtils.SanitizeDegreesInt(startHue + i);
            var hct = GetHctsByHue()[(int)hue];
            var temp = GetRelativeTemperature(hct);
            var tempDelta = Math.Abs(temp - lastTemp);
            lastTemp = temp;
            absoluteTotalTempDelta += tempDelta;
        }

        var hueAddend = 1;
        var tempStep = absoluteTotalTempDelta / divisions;
        var totalTempDelta = 0.0;
        lastTemp = GetRelativeTemperature(startHct);
        while (allColors.Count < divisions)
        {
            var hue = MathUtils.SanitizeDegreesInt(startHue + hueAddend);
            var hct = GetHctsByHue()[(int)hue];
            var temp = GetRelativeTemperature(hct);
            var tempDelta = Math.Abs(temp - lastTemp);
            totalTempDelta += tempDelta;

            var desiredTotalTempDeltaForIndex = allColors.Count * tempStep;
            var indexSatisfied = totalTempDelta >= desiredTotalTempDeltaForIndex;
            var indexAddend = 1;

            while (indexSatisfied && allColors.Count < divisions)
            {
                allColors.Add(hct);
                desiredTotalTempDeltaForIndex = (allColors.Count + indexAddend) * tempStep;
                indexSatisfied = totalTempDelta >= desiredTotalTempDeltaForIndex;
                indexAddend++;
            }

            lastTemp = temp;
            hueAddend++;

            if (hueAddend > 360)
            {
                while (allColors.Count < divisions) allColors.Add(hct);
                break;
            }
        }

        var answers = new List<Hct> { _input };

        var ccwCount = (int)Math.Floor((count - 1) / 2.0);
        for (var i = 1; i < ccwCount + 1; i++)
        {
            var index = 0 - i;
            while (index < 0) index = allColors.Count + index;
            if (index >= allColors.Count) index %= allColors.Count;
            answers.Insert(0, allColors[index]);
        }

        var cwCount = count - ccwCount - 1;
        for (var i = 1; i < cwCount + 1; i++)
        {
            var index = i;
            while (index < 0) index = allColors.Count + index;
            if (index >= allColors.Count) index %= allColors.Count;
            answers.Add(allColors[index]);
        }

        return answers;
    }

    public double GetRelativeTemperature(Hct hct)
    {
        var range = GetTempsByHct()[GetWarmest()] - GetTempsByHct()[GetColdest()];
        var differenceFromColdest = GetTempsByHct()[hct] - GetTempsByHct()[GetColdest()];
        if (range == 0.0) return 0.5;
        return differenceFromColdest / range;
    }

    public static double RawTemperature(Hct color)
    {
        var lab = ColorUtils.LabFromArgb(color.ToInt());
        var hue = MathUtils.SanitizeDegreesDouble(Math.Atan2(lab[2], lab[1]) * (180.0 / Math.PI));
        var chroma = Math.Sqrt(Math.Pow(lab[1], 2) + Math.Pow(lab[2], 2));
        return -0.5
               + 0.02 * Math.Pow(chroma, 1.07)
                      * Math.Cos(MathUtils.SanitizeDegreesDouble(hue - 50.0) * (Math.PI / 180.0));
    }

    private Hct GetColdest()
    {
        return GetHctsByTemp()[0];
    }

    private List<Hct> GetHctsByHue()
    {
        if (_precomputedHctsByHue != null) return _precomputedHctsByHue;
        var hcts = new List<Hct>();
        for (var hue = 0.0; hue <= 360.0; hue += 1.0)
        {
            var colorAtHue = Hct.From(hue, _input.Chroma, _input.Tone);
            hcts.Add(colorAtHue);
        }

        _precomputedHctsByHue = hcts.AsReadOnly().ToList();
        return _precomputedHctsByHue;
    }

    private List<Hct> GetHctsByTemp()
    {
        if (_precomputedHctsByTemp != null) return _precomputedHctsByTemp;

        var hcts = new List<Hct>(GetHctsByHue()) { _input };
        hcts.Sort((a, b) => GetTempsByHct()[a].CompareTo(GetTempsByHct()[b]));
        _precomputedHctsByTemp = hcts;
        return _precomputedHctsByTemp;
    }

    private Dictionary<Hct, double> GetTempsByHct()
    {
        if (_precomputedTempsByHct != null) return _precomputedTempsByHct;

        var allHcts = new List<Hct>(GetHctsByHue()) { _input };

        var temperaturesByHct = new Dictionary<Hct, double>();
        foreach (var hct in allHcts) temperaturesByHct[hct] = RawTemperature(hct);

        _precomputedTempsByHct = temperaturesByHct;
        return _precomputedTempsByHct;
    }

    private Hct GetWarmest()
    {
        return GetHctsByTemp()[GetHctsByTemp().Count - 1];
    }

    private static bool IsBetween(double angle, double a, double b)
    {
        if (a < b) return a <= angle && angle <= b;
        return a <= angle || angle <= b;
    }
}


==========================================
FILE: Theming\MaterialColors\Utils\ColorUtils.cs
==========================================
Last Modified: 12/05/2024 13:22:56
Size: 11494 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace Bdziam.UI.Theming.MaterialColors.Utils;

/// <summary>
///     Color science utilities.
/// </summary>
/// <remarks>
///     Utility methods for color science constants and color space conversions that aren't HCT or
///     CAM16.
/// </remarks>
public static class ColorUtils
{
    private static readonly double[][] SrgbToXyz =
    {
        new[] { 0.41233895, 0.35762064, 0.18051042 },
        new[] { 0.2126, 0.7152, 0.0722 },
        new[] { 0.01932141, 0.11916382, 0.95034478 }
    };

    private static readonly double[][] XyzToSrgb =
    {
        new[] { 3.2413774792388685, -1.5376652402851851, -0.49885366846268053 },
        new[] { -0.9691452513005321, 1.8758853451067872, 0.04156585616912061 },
        new[] { 0.05562093689691305, -0.20395524564742123, 1.0571799111220335 }
    };

    /// <summary>
    ///     The standard white point; white on a sunny day.
    /// </summary>
    public static double[] WhitePointD65 { get; } = { 95.047, 100, 108.883 };

    public static double LStarFromY(double y)
    {
        return LabF(y / 100.0) * 116.0 - 16.0;
    }

    /// <summary>Converts a color from RGB components to ARGB format.</summary>
    public static uint ArgbFromRgb(uint red, uint green, uint blue)
    {
        return (255u << 24) | ((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
    }

    /// <summary>Converts a color from ARGB components to ARGB format.</summary>
    public static uint ArgbFromComponents(uint alpha, uint red, uint green, uint blue)
    {
        return ((alpha & 255) << 24) | ((red & 255) << 16) | ((green & 255) << 8) | (blue & 255);
    }

    /// <summary>Converts a color from linear RGB components to ARGB format.</summary>
    public static uint ArgbFromLinrgb(double[] linrgb)
    {
        var r = Delinearized(linrgb[0]);
        var g = Delinearized(linrgb[1]);
        var b = Delinearized(linrgb[2]);
        return ArgbFromRgb(r, g, b);
    }

    /// <summary>Returns the alpha component of a color in ARGB format.</summary>
    public static uint AlphaFromArgb(uint argb)
    {
        return (argb >> 24) & 255;
    }

    /// <summary>Returns the red component of a color in ARGB format.</summary>
    public static uint RedFromArgb(uint argb)
    {
        return (argb >> 16) & 255;
    }

    /// <summary>Returns the green component of a color in ARGB format.</summary>
    public static uint GreenFromArgb(uint argb)
    {
        return (argb >> 8) & 255;
    }

    /// <summary>Returns the blue component of a color in ARGB format.</summary>
    public static uint BlueFromArgb(uint argb)
    {
        return argb & 255;
    }

    /// <summary>Returns whether a color in ARGB format is opaque.</summary>
    public static bool IsOpaque(uint argb)
    {
        return AlphaFromArgb(argb) >= 255;
    }

    /// <summary>Converts a color from XYZ to ARGB.</summary>
    public static uint ArgbFromXyz(double x, double y, double z)
    {
        var matrix = XyzToSrgb;
        var linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z;
        var linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z;
        var linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
        var r = Delinearized(linearR);
        var g = Delinearized(linearG);
        var b = Delinearized(linearB);
        return ArgbFromRgb(r, g, b);
    }

    /// <summary>Converts a color from ARGB to XYZ.</summary>
    public static double[] XyzFromArgb(uint argb)
    {
        var r = Linearized(RedFromArgb(argb));
        var g = Linearized(GreenFromArgb(argb));
        var b = Linearized(BlueFromArgb(argb));
        return MathUtils.MatrixMultiply(new[] { r, g, b }, SrgbToXyz);
    }

    /// <summary>Converts a color represented in Lab color space into an ARGB integer.</summary>
    public static uint ArgbFromLab(double l, double a, double b)
    {
        var whitePoint = WhitePointD65;
        var fy = (l + 16.0) / 116.0;
        var fx = a / 500.0 + fy;
        var fz = fy - b / 200.0;
        var xNormalized = LabInvf(fx);
        var yNormalized = LabInvf(fy);
        var zNormalized = LabInvf(fz);
        var x = xNormalized * whitePoint[0];
        var y = yNormalized * whitePoint[1];
        var z = zNormalized * whitePoint[2];
        return ArgbFromXyz(x, y, z);
    }

    /// <summary>Converts a color from ARGB representation to L*a*b* representation.</summary>
    public static double[] LabFromArgb(uint argb)
    {
        var linearR = Linearized(RedFromArgb(argb));
        var linearG = Linearized(GreenFromArgb(argb));
        var linearB = Linearized(BlueFromArgb(argb));
        var matrix = SrgbToXyz;
        var x = matrix[0][0] * linearR + matrix[0][1] * linearG + matrix[0][2] * linearB;
        var y = matrix[1][0] * linearR + matrix[1][1] * linearG + matrix[1][2] * linearB;
        var z = matrix[2][0] * linearR + matrix[2][1] * linearG + matrix[2][2] * linearB;
        var whitePoint = WhitePointD65;
        var xNormalized = x / whitePoint[0];
        var yNormalized = y / whitePoint[1];
        var zNormalized = z / whitePoint[2];
        var fx = LabF(xNormalized);
        var fy = LabF(yNormalized);
        var fz = LabF(zNormalized);
        var l = 116.0 * fy - 16;
        var a = 500.0 * (fx - fy);
        var b = 200.0 * (fy - fz);
        return new[] { l, a, b };
    }

    /// <summary>Converts an L* value to an ARGB representation.</summary>
    /// <param name="l">L* in L*a*b*</param>
    /// <returns>ARGB representation of grayscale color with lightness matching L*</returns>
    public static uint ArgbFromLstar(double lstar)
    {
        var fy = (lstar + 16.0) / 116.0;
        var fz = fy;
        var fx = fy;
        var kappa = 24389.0 / 27.0;
        var epsilon = 216.0 / 24389.0;
        var lExceedsEpsilonKappa = lstar > 8.0;
        var y = lExceedsEpsilonKappa ? fy * fy * fy : lstar / kappa;
        var cubeExceedEpsilon = fy * fy * fy > epsilon;
        var x = cubeExceedEpsilon ? fx * fx * fx : lstar / kappa;
        var z = cubeExceedEpsilon ? fz * fz * fz : lstar / kappa;
        var whitePoint = WhitePointD65;
        return ArgbFromXyz(x * whitePoint[0], y * whitePoint[1], z * whitePoint[2]);
    }

    /// <summary>Computes the L* value of a color in ARGB representation.</summary>
    /// <param name="argb">ARGB representation of a color</param>
    /// <returns>L*, from L*a*b*, coordinate of the color</returns>
    public static double LStarFromArgb(uint argb)
    {
        var y = XyzFromArgb(argb)[1] / 100.0;
        var e = 216.0 / 24389.0;
        if (y <= e) return 24389.0 / 27.0 * y;

        var yIntermediate = Math.Pow(y, 1.0 / 3.0);
        return 116.0 * yIntermediate - 16.0;
    }

    /// <summary>
    ///     Converts an L* value to a Y value.
    /// </summary>
    /// <remarks>
    ///     L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
    ///     L* measures perceptual luminance, a linear scale. Y in XYZ measures relative luminance, a
    ///     logarithmic scale.
    /// </remarks>
    /// <param name="lstar">L* in L*a*b*</param>
    /// <returns>Y in XYZ</returns>
    public static double YFromLstar(double lstar)
    {
        var ke = 8.0;
        if (lstar > ke)
            return Math.Pow((lstar + 16.0) / 116.0, 3.0) * 100.0;
        return lstar / (24389.0 / 27.0) * 100.0;
    }

    /// <summary>
    ///     Linearizes an RGB component.
    /// </summary>
    /// <param name="rgbComponent">0 ≤ rgb_component ≤ 255, represents R/G/B channel</param>
    /// <returns>0.0 ≤ output ≤ 100.0, color channel converted to linear RGB space</returns>
    public static double Linearized(uint rgbComponent)
    {
        var normalized = rgbComponent / 255.0;
        if (normalized <= 0.040449936)
            return normalized / 12.92 * 100.0;
        return Math.Pow((normalized + 0.055) / 1.055, 2.4) * 100.0;
    }

    /// <summary>
    ///     Delinearizes an RGB component.
    /// </summary>
    /// <param name="rgbComponent">0.0 ≤ rgb_component ≤ 100.0, represents linear R/G/B channel</param>
    /// <returns>0 ≤ output ≤ 255, color channel converted to regular RGB space</returns>
    public static uint Delinearized(double rgbComponent)
    {
        var normalized = rgbComponent / 100.0;
        double delinearized;
        if (normalized <= 0.0031308)
            delinearized = normalized * 12.92;
        else
            delinearized = 1.055 * Math.Pow(normalized, 1.0 / 2.4) - 0.055;
        return MathUtils.ClampInt(0, 255, (uint)Math.Round(delinearized * 255.0));
    }

    public static double LabF(double t)
    {
        const double e = 216.0 / 24389.0;
        const double kappa = 24389.0 / 27.0;
        if (t > e)
            return Math.Pow(t, 1.0 / 3.0);
        return (kappa * t + 16) / 116;
    }

    public static double LabInvf(double ft)
    {
        var e = 216.0 / 24389.0;
        var kappa = 24389.0 / 27.0;
        var ft3 = ft * ft * ft;
        if (ft3 > e)
            return ft3;
        return (116 * ft - 16) / kappa;
    }

    public static uint Add(this uint background, uint foreground, double foregroundAlpha)
    {
        var a = (uint)(foregroundAlpha * 255);
        foreground &= (a << 24) | 0x00FFFFFF;
        return Add(background, foreground);
    }

    public static uint Add(this uint background, uint foreground)
    {
        DeconstructArgb(background,
            out var bgA,
            out var bgR,
            out var bgG,
            out var bgB);
        DeconstructArgb(foreground,
            out var fgA,
            out var fgR,
            out var fgG,
            out var fgB);

        var a = fgA + bgA * (1 - fgA);

        var r = CompositeComponent(fgR, bgR, fgA, bgA, a);
        var g = CompositeComponent(fgG, bgG, fgA, bgA, a);
        var b = CompositeComponent(fgB, bgB, fgA, bgA, a);

        return ArgbFromComponents(
            (uint)(a * 255),
            (uint)(r * 255),
            (uint)(g * 255),
            (uint)(b * 255));
    }

    public static float CompositeComponent(float fgC, float bgC, float fgA, float bgA, float a)
    {
        if (a == 0) return 0;
        return (fgC * fgA + bgC * bgA * (1 - fgA)) / a;
    }

    public static void DeconstructArgb(
        uint argb,
        out float a,
        out float r,
        out float g,
        out float b)
    {
        a = AlphaFromArgb(argb) / 255f;
        r = RedFromArgb(argb) / 255f;
        g = GreenFromArgb(argb) / 255f;
        b = BlueFromArgb(argb) / 255f;
    }
}


==========================================
FILE: Theming\MaterialColors\Utils\MathUtils.cs
==========================================
Last Modified: 12/05/2024 13:23:19
Size: 5822 bytes
------------------------------------------

// Copyright 2021 Google LLC
// Copyright 2021-2022 project contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace Bdziam.UI.Theming.MaterialColors.Utils;

/// <summary>
///     Utility methods for mathematical operations.
/// </summary>
public static class MathUtils
{
    /// <summary>The linear interpolation function.</summary>
    /// <returns>
    ///     <paramref name="start" /> if <paramref name="amount" /> = 0 and <paramref name="stop" /> if
    ///     <paramref name="amount" /> = 1
    /// </returns>
    public static double Lerp(double start, double stop, double amount)
    {
        return (1.0 - amount) * start + amount * stop;
    }

    /// <summary>Clamps an integer between two integers.</summary>
    /// <returns>
    ///     <paramref name="input" /> when <paramref name="min" /> ≤ <paramref name="input" /> ≤ <paramref name="max" />,
    ///     and either <paramref name="min" /> or <paramref name="max" /> otherwise.
    /// </returns>
    public static uint ClampInt(uint min, uint max, uint input)
    {
        if (input < min)
            return min;
        if (input > max)
            return max;
        return input;
    }

    /// <summary>Clamps an integer between two floating-point numbers.</summary>
    /// <returns>
    ///     <paramref name="input" /> when <paramref name="min" /> ≤ <paramref name="input" /> ≤ <paramref name="max" />,
    ///     and either <paramref name="min" /> or <paramref name="max" /> otherwise.
    /// </returns>
    public static double ClampDouble(double min, double max, double input)
    {
        if (input < min)
            return min;
        if (input > max)
            return max;
        return input;
    }

    /// <summary>Sanitizes a degree measure as an integer.</summary>
    /// <returns>A degree measure between 0 (inclusive) and 360 (exclusive).</returns>
    public static uint SanitizeDegreesInt(int degrees)
    {
        degrees %= 360;
        if (degrees < 0) degrees += 360;
        return (uint)degrees;
    }

    /// <summary>Sanitizes a degree measure as a floating-point number.</summary>
    /// <returns>A degree measure between 0.0 (inclusive) and 360.0 (exclusive).</returns>
    public static double SanitizeDegreesDouble(double degrees)
    {
        degrees %= 360.0;
        if (degrees < 0) degrees += 360.0;
        return degrees;
    }

    /// <summary>
    ///     Sign of direction change needed to travel from one angle to another.
    /// </summary>
    /// <param name="from">The angle travel starts from, in degrees.</param>
    /// <param name="to">The angle travel ends at, in degrees.</param>
    /// <returns>
    ///     -1 if decreasing <paramref name="from" /> leads to the shortest travel distance, 1 if increasing
    ///     <paramref name="from" /> leads
    ///     to the shortest travel distance.
    /// </returns>
    public static double RotationDirection(double from, double to)
    {
        var increasingDifference = SanitizeDegreesDouble(to - from);
        return increasingDifference <= 180.0 ? 1.0 : -1.0;
    }

    /// <summary>Distance of two points on a circle, represented using degrees.</summary>
    public static double DifferenceDegrees(double a, double b)
    {
        return 180.0 - Math.Abs(Math.Abs(a - b) - 180.0);
    }

    /// <summary>Multiplies a 1x3 row vector with a 3x3 matrix.</summary>
    public static double[] MatrixMultiply(double[] row, double[][] matrix)
    {
        var a = row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2];
        var b = row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2];
        var c = row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2];
        return new[] { a, b, c };
    }

    public static double ToRadians(double angdeg)
    {
        return Math.PI / 180 * angdeg;
    }

    public static double Hypot(double x, double y)
    {
        return Math.Sqrt(x * x + y * y);
    }

    public static double Log1p(double x)
    {
        return Math.Log(1 + x);
    }

    public static double Expm1(double x)
    {
        return Math.Exp(x) - 1;
    }

    /// <summary>
    ///     Given a seed hue, and a mapping of hues to hue rotations, find which hues in the mapping the seed hue falls
    ///     between, and add the hue rotation of the lower hue to the seed hue.
    /// </summary>
    /// <param name="seedHue">Hue of the seed color</param>
    /// <param name="hueAndRotations">
    ///     List of pairs, where the first item in a pair is a hue, and the second item in
    ///     the pair is a hue rotation that should be applied
    /// </param>
    /// <returns></returns>
    public static double RotateHue(double seedHue, params (int Hue, int Rotation)[] hueAndRotations)
    {
        for (var i = 0; i < hueAndRotations.Length - 1; i++)
        {
            double thisHue = hueAndRotations[i].Hue;
            double nextHue = hueAndRotations[i + 1].Hue;
            if (thisHue <= seedHue && seedHue < nextHue)
                return SanitizeDegreesDouble(seedHue + hueAndRotations[i].Rotation);
        }

        return seedHue;
    }
}


==========================================
FILE: Theming\MaterialColors\Utils\StringUtils.cs
==========================================
Last Modified: 12/05/2024 13:22:27
Size: 479 bytes
------------------------------------------

namespace Bdziam.UI.Theming.MaterialColors.Utils;

/// <summary>
///     Utility methods for string representations of colors.
/// </summary>
public static class StringUtils
{
    /// <summary>
    ///     Hex string representing color, ex. #0000FF for blue.
    /// </summary>
    /// <param name="argb">ARGB representation of a color.</param>
    public static string HexFromArgb(uint argb)
    {
        return "#" + argb.ToString("X8").Substring(2);
    }
}


==========================================
FILE: Theming\MaterialColors\Contrast.cs
==========================================
Last Modified: 12/05/2024 13:22:37
Size: 3535 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.Utils;

namespace Bdziam.UI.Theming.MaterialColors;

public static class Contrast
{
    // Constants
    public const double RATIO_MIN = 1.0;
    public const double RATIO_MAX = 21.0;
    public const double RATIO_30 = 3.0;
    public const double RATIO_45 = 4.5;
    public const double RATIO_70 = 7.0;

    private const double CONTRAST_RATIO_EPSILON = 0.04;
    private const double LUMINANCE_GAMUT_MAP_TOLERANCE = 0.4;

    /// <summary>
    ///     Calculates the contrast ratio between two Y (relative luminance) values.
    /// </summary>
    public static double RatioOfYs(double y1, double y2)
    {
        var lighter = Math.Max(y1, y2);
        var darker = lighter == y2 ? y1 : y2;
        return (lighter + 5.0) / (darker + 5.0);
    }

    /// <summary>
    ///     Calculates the contrast ratio between two tones.
    /// </summary>
    public static double RatioOfTones(double t1, double t2)
    {
        return RatioOfYs(ColorUtils.YFromLstar(t1), ColorUtils.YFromLstar(t2));
    }

    /// <summary>
    ///     Returns the tone >= the input tone that ensures the specified contrast ratio.
    ///     Returns -1 if the ratio cannot be achieved.
    /// </summary>
    public static double Lighter(double tone, double ratio)
    {
        if (tone < 0.0 || tone > 100.0) return -1.0;

        var darkY = ColorUtils.YFromLstar(tone);
        var lightY = ratio * (darkY + 5.0) - 5.0;

        if (lightY < 0.0 || lightY > 100.0) return -1.0;

        var realContrast = RatioOfYs(lightY, darkY);
        var delta = Math.Abs(realContrast - ratio);

        if (realContrast < ratio && delta > CONTRAST_RATIO_EPSILON) return -1.0;

        var returnValue = ColorUtils.LStarFromY(lightY) + LUMINANCE_GAMUT_MAP_TOLERANCE;

        if (returnValue < 0 || returnValue > 100) return -1.0;

        return returnValue;
    }

    /// <summary>
    ///     Returns the tone >= the input tone that ensures the specified contrast ratio.
    ///     Returns 100 if the ratio cannot be achieved.
    /// </summary>
    public static double LighterUnsafe(double tone, double ratio)
    {
        var lighterSafe = Lighter(tone, ratio);
        return lighterSafe < 0.0 ? 100.0 : lighterSafe;
    }

    /// <summary>
    ///     Returns the tone <= the input tone that ensures the specified contrast ratio.
    ///     Returns -1 if the ratio cannot be achieved.
    /// </summary>
    public static double Darker(double tone, double ratio)
    {
        if (tone < 0.0 || tone > 100.0) return -1.0;

        var lightY = ColorUtils.YFromLstar(tone);
        var darkY = (lightY + 5.0) / ratio - 5.0;

        if (darkY < 0.0 || darkY > 100.0) return -1.0;

        var realContrast = RatioOfYs(lightY, darkY);
        var delta = Math.Abs(realContrast - ratio);

        if (realContrast < ratio && delta > CONTRAST_RATIO_EPSILON) return -1.0;

        var returnValue = ColorUtils.LStarFromY(darkY) - LUMINANCE_GAMUT_MAP_TOLERANCE;

        if (returnValue < 0 || returnValue > 100) return -1.0;

        return returnValue;
    }

    /// <summary>
    ///     Returns the tone <= the input tone that ensures the specified contrast ratio.
    ///     Returns 0 if the ratio cannot be achieved.
    /// </summary>
    public static double DarkerUnsafe(double tone, double ratio)
    {
        var darkerSafe = Darker(tone, ratio);
        return Math.Max(0.0, darkerSafe);
    }
}


==========================================
FILE: Theming\Model\BColorScheme.cs
==========================================
Last Modified: 12/05/2024 13:22:49
Size: 13212 bytes
------------------------------------------

using System.Drawing;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Utilities;

namespace Bdziam.UI.Theming.Model;

public class BColorScheme(DynamicScheme scheme)
{
    public DynamicScheme CurrentScheme { get; set; } = scheme;

    // Palette key colors
    public Color PrimaryPaletteKeyColor => ColorUtility.ColorFromArgb(CurrentScheme.PrimaryPaletteKeyColor);
    public Color SecondaryPaletteKeyColor => ColorUtility.ColorFromArgb(CurrentScheme.SecondaryPaletteKeyColor);
    public Color TertiaryPaletteKeyColor => ColorUtility.ColorFromArgb(CurrentScheme.TertiaryPaletteKeyColor);
    public Color NeutralPaletteKeyColor => ColorUtility.ColorFromArgb(CurrentScheme.NeutralPaletteKeyColor);

    public Color NeutralVariantPaletteKeyColor =>
        ColorUtility.ColorFromArgb(CurrentScheme.NeutralVariantPaletteKeyColor);

    // Background, surface, and container colors
    public Color Background => ColorUtility.ColorFromArgb(CurrentScheme.Background);
    public Color OnBackground => ColorUtility.ColorFromArgb(CurrentScheme.OnBackground);
    public Color Surface => ColorUtility.ColorFromArgb(CurrentScheme.Surface);
    public Color SurfaceDim => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceDim);
    public Color SurfaceBright => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceBright);
    public Color SurfaceContainerLowest => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceContainerLowest);
    public Color SurfaceContainerLow => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceContainerLow);
    public Color SurfaceContainer => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceContainer);
    public Color SurfaceContainerHigh => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceContainerHigh);
    public Color SurfaceContainerHighest => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceContainerHighest);
    public Color OnSurface => ColorUtility.ColorFromArgb(CurrentScheme.OnSurface);
    public Color SurfaceVariant => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceVariant);
    public Color OnSurfaceVariant => ColorUtility.ColorFromArgb(CurrentScheme.OnSurfaceVariant);
    public Color InverseSurface => ColorUtility.ColorFromArgb(CurrentScheme.InverseSurface);
    public Color InverseOnSurface => ColorUtility.ColorFromArgb(CurrentScheme.InverseOnSurface);

    // Outline, shadow, and tint colors
    public Color Outline => ColorUtility.ColorFromArgb(CurrentScheme.Outline);
    public Color OutlineVariant => ColorUtility.ColorFromArgb(CurrentScheme.OutlineVariant);
    public Color Shadow => ColorUtility.ColorFromArgb(CurrentScheme.Shadow);
    public Color Scrim => ColorUtility.ColorFromArgb(CurrentScheme.Scrim);
    public Color SurfaceTint => ColorUtility.ColorFromArgb(CurrentScheme.SurfaceTint);

    // Primary colors
    public Color Primary => ColorUtility.ColorFromArgb(CurrentScheme.Primary);
    public Color OnPrimary => ColorUtility.ColorFromArgb(CurrentScheme.OnPrimary);
    public Color PrimaryContainer => ColorUtility.ColorFromArgb(CurrentScheme.PrimaryContainer);
    public Color OnPrimaryContainer => ColorUtility.ColorFromArgb(CurrentScheme.OnPrimaryContainer);
    public Color InversePrimary => ColorUtility.ColorFromArgb(CurrentScheme.InversePrimary);

    // Secondary colors
    public Color Secondary => ColorUtility.ColorFromArgb(CurrentScheme.Secondary);
    public Color OnSecondary => ColorUtility.ColorFromArgb(CurrentScheme.OnSecondary);
    public Color SecondaryContainer => ColorUtility.ColorFromArgb(CurrentScheme.SecondaryContainer);
    public Color OnSecondaryContainer => ColorUtility.ColorFromArgb(CurrentScheme.OnSecondaryContainer);

    // Tertiary colors
    public Color Tertiary => ColorUtility.ColorFromArgb(CurrentScheme.Tertiary);
    public Color OnTertiary => ColorUtility.ColorFromArgb(CurrentScheme.OnTertiary);
    public Color TertiaryContainer => ColorUtility.ColorFromArgb(CurrentScheme.TertiaryContainer);
    public Color OnTertiaryContainer => ColorUtility.ColorFromArgb(CurrentScheme.OnTertiaryContainer);

    // Error colors
    public Color Error => ColorUtility.ColorFromArgb(CurrentScheme.Error);
    public Color OnError => ColorUtility.ColorFromArgb(CurrentScheme.OnError);
    public Color ErrorContainer => ColorUtility.ColorFromArgb(CurrentScheme.ErrorContainer);
    public Color OnErrorContainer => ColorUtility.ColorFromArgb(CurrentScheme.OnErrorContainer);

    // Warning colors
    public Color Warning => ColorUtility.ColorFromArgb(CurrentScheme.Warning);
    public Color OnWarning => ColorUtility.ColorFromArgb(CurrentScheme.OnWarning);
    public Color WarningContainer => ColorUtility.ColorFromArgb(CurrentScheme.WarningContainer);
    public Color OnWarningContainer => ColorUtility.ColorFromArgb(CurrentScheme.OnWarningContainer);

    // Info colors
    public Color Info => ColorUtility.ColorFromArgb(CurrentScheme.Info);
    public Color OnInfo => ColorUtility.ColorFromArgb(CurrentScheme.OnInfo);
    public Color InfoContainer => ColorUtility.ColorFromArgb(CurrentScheme.InfoContainer);
    public Color OnInfoContainer => ColorUtility.ColorFromArgb(CurrentScheme.OnInfoContainer);

    // Success colors
    public Color Success => ColorUtility.ColorFromArgb(CurrentScheme.Success);
    public Color OnSuccess => ColorUtility.ColorFromArgb(CurrentScheme.OnSuccess);
    public Color SuccessContainer => ColorUtility.ColorFromArgb(CurrentScheme.SuccessContainer);
    public Color OnSuccessContainer => ColorUtility.ColorFromArgb(CurrentScheme.OnSuccessContainer);

    // Fixed colors
    public Color PrimaryFixed => ColorUtility.ColorFromArgb(CurrentScheme.PrimaryFixed);
    public Color PrimaryFixedDim => ColorUtility.ColorFromArgb(CurrentScheme.PrimaryFixedDim);
    public Color OnPrimaryFixed => ColorUtility.ColorFromArgb(CurrentScheme.OnPrimaryFixed);
    public Color OnPrimaryFixedVariant => ColorUtility.ColorFromArgb(CurrentScheme.OnPrimaryFixedVariant);
    public Color SecondaryFixed => ColorUtility.ColorFromArgb(CurrentScheme.SecondaryFixed);
    public Color SecondaryFixedDim => ColorUtility.ColorFromArgb(CurrentScheme.SecondaryFixedDim);
    public Color OnSecondaryFixed => ColorUtility.ColorFromArgb(CurrentScheme.OnSecondaryFixed);
    public Color OnSecondaryFixedVariant => ColorUtility.ColorFromArgb(CurrentScheme.OnSecondaryFixedVariant);
    public Color TertiaryFixed => ColorUtility.ColorFromArgb(CurrentScheme.TertiaryFixed);
    public Color TertiaryFixedDim => ColorUtility.ColorFromArgb(CurrentScheme.TertiaryFixedDim);
    public Color OnTertiaryFixed => ColorUtility.ColorFromArgb(CurrentScheme.OnTertiaryFixed);
    public Color OnTertiaryFixedVariant => ColorUtility.ColorFromArgb(CurrentScheme.OnTertiaryFixedVariant);

    // Controls and text
    public Color ControlActivated => ColorUtility.ColorFromArgb(CurrentScheme.ControlActivated);
    public Color ControlNormal => ColorUtility.ColorFromArgb(CurrentScheme.ControlNormal);
    public Color ControlHighlight => ColorUtility.ColorFromArgb(CurrentScheme.ControlHighlight);
    public Color TextPrimaryInverse => ColorUtility.ColorFromArgb(CurrentScheme.TextPrimaryInverse);

    public Color TextSecondaryAndTertiaryInverse =>
        ColorUtility.ColorFromArgb(CurrentScheme.TextSecondaryAndTertiaryInverse);

    public Color TextPrimaryInverseDisableOnly =>
        ColorUtility.ColorFromArgb(CurrentScheme.TextPrimaryInverseDisableOnly);

    public Color TextSecondaryAndTertiaryInverseDisabled =>
        ColorUtility.ColorFromArgb(CurrentScheme.TextSecondaryAndTertiaryInverseDisabled);

    public Color TextHintInverse => ColorUtility.ColorFromArgb(CurrentScheme.TextHintInverse);

    public Color GetColorByEnum(MaterialColor materialColorEnum)
    {
        return materialColorEnum switch
        {
            // Palette key colors
            MaterialColor.PrimaryPaletteKeyColor => PrimaryPaletteKeyColor,
            MaterialColor.SecondaryPaletteKeyColor => SecondaryPaletteKeyColor,
            MaterialColor.TertiaryPaletteKeyColor => TertiaryPaletteKeyColor,
            MaterialColor.NeutralPaletteKeyColor => NeutralPaletteKeyColor,
            MaterialColor.NeutralVariantPaletteKeyColor => NeutralVariantPaletteKeyColor,

            // Background, surface, and container colors
            MaterialColor.Background => Background,
            MaterialColor.OnBackground => OnBackground,
            MaterialColor.Surface => Surface,
            MaterialColor.SurfaceDim => SurfaceDim,
            MaterialColor.SurfaceBright => SurfaceBright,
            MaterialColor.SurfaceContainerLowest => SurfaceContainerLowest,
            MaterialColor.SurfaceContainerLow => SurfaceContainerLow,
            MaterialColor.SurfaceContainer => SurfaceContainer,
            MaterialColor.SurfaceContainerHigh => SurfaceContainerHigh,
            MaterialColor.SurfaceContainerHighest => SurfaceContainerHighest,
            MaterialColor.OnSurface => OnSurface,
            MaterialColor.SurfaceVariant => SurfaceVariant,
            MaterialColor.OnSurfaceVariant => OnSurfaceVariant,
            MaterialColor.InverseSurface => InverseSurface,
            MaterialColor.InverseOnSurface => InverseOnSurface,

            // Outline, shadow, and tint colors
            MaterialColor.Outline => Outline,
            MaterialColor.OutlineVariant => OutlineVariant,
            MaterialColor.Shadow => Shadow,
            MaterialColor.Scrim => Scrim,
            MaterialColor.SurfaceTint => SurfaceTint,

            // Primary colors
            MaterialColor.Primary => Primary,
            MaterialColor.OnPrimary => OnPrimary,
            MaterialColor.PrimaryContainer => PrimaryContainer,
            MaterialColor.OnPrimaryContainer => OnPrimaryContainer,
            MaterialColor.InversePrimary => InversePrimary,

            // Secondary colors
            MaterialColor.Secondary => Secondary,
            MaterialColor.OnSecondary => OnSecondary,
            MaterialColor.SecondaryContainer => SecondaryContainer,
            MaterialColor.OnSecondaryContainer => OnSecondaryContainer,

            // Tertiary colors
            MaterialColor.Tertiary => Tertiary,
            MaterialColor.OnTertiary => OnTertiary,
            MaterialColor.TertiaryContainer => TertiaryContainer,
            MaterialColor.OnTertiaryContainer => OnTertiaryContainer,

            // Error colors
            MaterialColor.Error => Error,
            MaterialColor.OnError => OnError,
            MaterialColor.ErrorContainer => ErrorContainer,
            MaterialColor.OnErrorContainer => OnErrorContainer,

            // Warning colors
            MaterialColor.Warning => Warning,
            MaterialColor.OnWarning => OnWarning,
            MaterialColor.WarningContainer => WarningContainer,
            MaterialColor.OnWarningContainer => OnWarningContainer,

            // Info colors
            MaterialColor.Info => Info,
            MaterialColor.OnInfo => OnInfo,
            MaterialColor.InfoContainer => InfoContainer,
            MaterialColor.OnInfoContainer => OnInfoContainer,

            // Success colors
            MaterialColor.Success => Success,
            MaterialColor.OnSuccess => OnSuccess,
            MaterialColor.SuccessContainer => SuccessContainer,
            MaterialColor.OnSuccessContainer => OnSuccessContainer,

            // Fixed colors
            MaterialColor.PrimaryFixed => PrimaryFixed,
            MaterialColor.PrimaryFixedDim => PrimaryFixedDim,
            MaterialColor.OnPrimaryFixed => OnPrimaryFixed,
            MaterialColor.OnPrimaryFixedVariant => OnPrimaryFixedVariant,
            MaterialColor.SecondaryFixed => SecondaryFixed,
            MaterialColor.SecondaryFixedDim => SecondaryFixedDim,
            MaterialColor.OnSecondaryFixed => OnSecondaryFixed,
            MaterialColor.OnSecondaryFixedVariant => OnSecondaryFixedVariant,
            MaterialColor.TertiaryFixed => TertiaryFixed,
            MaterialColor.TertiaryFixedDim => TertiaryFixedDim,
            MaterialColor.OnTertiaryFixed => OnTertiaryFixed,
            MaterialColor.OnTertiaryFixedVariant => OnTertiaryFixedVariant,

            // Controls and text
            MaterialColor.ControlActivated => ControlActivated,
            MaterialColor.ControlNormal => ControlNormal,
            MaterialColor.ControlHighlight => ControlHighlight,
            MaterialColor.TextPrimaryInverse => TextPrimaryInverse,
            MaterialColor.TextSecondaryAndTertiaryInverse => TextSecondaryAndTertiaryInverse,
            MaterialColor.TextPrimaryInverseDisableOnly => TextPrimaryInverseDisableOnly,
            MaterialColor.TextSecondaryAndTertiaryInverseDisabled => TextSecondaryAndTertiaryInverseDisabled,
            MaterialColor.TextHintInverse => TextHintInverse,

            _ => throw new ArgumentOutOfRangeException(nameof(materialColorEnum), materialColorEnum,
                "Invalid color enum value")
        };
    }
}


==========================================
FILE: Theming\Model\ThemeSettings.cs
==========================================
Last Modified: 12/05/2024 13:23:00
Size: 272 bytes
------------------------------------------

using Bdziam.UI.Theming.MaterialColors.DynamicColor;

namespace Bdziam.UI.Theming.Model;

public class ThemeSettings
{
    public uint SeedColor { get; set; }
    public bool IsDarkMode { get; set; }
    public DynamicSchemeVariant PalleteStyle { get; set; }
}


==========================================
FILE: Theming\BThemeProvider.razor
==========================================
Last Modified: 12/05/2024 13:23:01
Size: 119 bytes
------------------------------------------

@using Bdziam.UI.Theming
@namespace Bdziam.UI
@inject ThemeService ThemeService


@((MarkupString)BuildTheme())


==========================================
FILE: Theming\BThemeProvider.razor.cs
==========================================
Last Modified: 12/05/2024 13:22:31
Size: 5135 bytes
------------------------------------------

using System.Drawing;
using System.Text;
using Bdziam.UI.Model.Enums;
using Bdziam.UI.Theming;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.Model;
using Bdziam.UI.Utilities;
using Blazored.LocalStorage;
using Microsoft.AspNetCore.Components;

namespace Bdziam.UI;

public partial class BThemeProvider
{
    private const string BdziamThemeKey = "bdziam_theme";

    private bool _isDarkMode;

    private Color _seedColor = Color.OrangeRed;

    private DynamicSchemeVariant _style = DynamicSchemeVariant.Vibrant;

    private bool _tintSurfaces = true;

    [Inject] public ILocalStorageService Storage { get; set; }

    /// <summary>
    ///     Invoked when the seed color changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> TintSurfacesChanged { get; set; }

    /// <summary>
    ///     Tracks the current seed color state and triggers changes.
    /// </summary>
    [Parameter]
    public bool TintSurfaces
    {
        get => _tintSurfaces;
        set
        {
            if (_tintSurfaces != value)
            {
                _tintSurfaces = value;
                TintSurfacesChanged.InvokeAsync(_tintSurfaces);
                SaveBdziamTheme();
                StateHasChanged();
            }
        }
    }

    /// <summary>
    ///     Invoked when the seed color changes.
    /// </summary>
    [Parameter]
    public EventCallback<Color> SeedColorChanged { get; set; }

    /// <summary>
    ///     Tracks the current seed color state and triggers changes.
    /// </summary>
    [Parameter]
    public Color SeedColor
    {
        get => _seedColor;
        set
        {
            if (_seedColor != value)
            {
                _seedColor = value;
                SeedColorChanged.InvokeAsync(_seedColor);
                ThemeService.SeedColor = SeedColor;
                SaveBdziamTheme();
            }
        }
    }

    /// <summary>
    ///     Invoked when the style changes.
    /// </summary>
    [Parameter]
    public EventCallback<DynamicSchemeVariant> StyleChanged { get; set; }

    /// <summary>
    ///     Tracks the current style state and triggers changes.
    /// </summary>
    [Parameter]
    public DynamicSchemeVariant Style
    {
        get => _style;
        set
        {
            if (_style != value)
            {
                _style = value;
                StyleChanged.InvokeAsync(_style);
                ThemeService.Style = Style;
                SaveBdziamTheme();
            }
        }
    }

    /// <summary>
    ///     Invoked when the dark mode changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> IsDarkModeChanged { get; set; }

    /// <summary>
    ///     Tracks the current dark mode state and triggers changes.
    /// </summary>
    [Parameter]
    public bool IsDarkMode
    {
        get => _isDarkMode;
        set
        {
            if (_isDarkMode != value)
            {
                _isDarkMode = value;
                IsDarkModeChanged.InvokeAsync(_isDarkMode);
                ThemeService.IsDarkMode = IsDarkMode;
                SaveBdziamTheme();
            }
        }
    }

    private void SaveBdziamTheme()
    {
        Task.Run(async () => await Storage.SetItemAsync(BdziamThemeKey, new ThemeSettings
        {
            IsDarkMode = IsDarkMode,
            PalleteStyle = Style,
            SeedColor = ColorUtility.ToArgb(SeedColor)
        }));
    }

    protected override async Task OnInitializedAsync()
    {
        var themeSettings = await Storage.GetItemAsync<ThemeSettings>(BdziamThemeKey);
        if (themeSettings != null)
        {
            SeedColor = ColorUtility.ColorFromArgb(themeSettings.SeedColor);
            Style = themeSettings.PalleteStyle;
            IsDarkMode = themeSettings.IsDarkMode;
            StateHasChanged();
        }

        ThemeService.OnThemeChanged += StateHasChanged;
    }

    public string BuildTheme()
    {
        StringBuilder builder = new();
        var scheme = ThemeService.CurrentColorScheme;

        builder.AppendLine("<style>");
        builder.Append(":root");
        builder.Append(" {\n");
        foreach (var color in Enum.GetValues<MaterialColor>())
        {
            builder.Append("    --md-sys-color-");
            builder.Append(CaseUtility.PascalToKebab(color.ToString()));
            builder.Append(": ");
            builder.Append(StyleUtility.ToCssColor(ThemeService.CurrentColorScheme!.GetColorByEnum(color)));
            builder.Append(";\n");
        }

        foreach (var motion in ThemingConstants.Motions)
        {
            builder.Append("    --md-sys-motion-");
            builder.Append(motion.Key);
            builder.Append(": ");
            builder.Append(motion.Value);
            builder.Append(";\n");
        }

        builder.Append('}');
        builder.AppendLine("</style>");
        return builder.ToString();
    }
}


==========================================
FILE: Theming\ThemeService.cs
==========================================
Last Modified: 12/05/2024 13:23:44
Size: 1580 bytes
------------------------------------------

using System.Drawing;
using Bdziam.UI.Theming.MaterialColors.ColorSpace;
using Bdziam.UI.Theming.MaterialColors.DynamicColor;
using Bdziam.UI.Theming.MaterialColors.Scheme;
using Bdziam.UI.Theming.Model;
using Bdziam.UI.Utilities;

namespace Bdziam.UI.Theming;

public class ThemeService
{
    private bool _isDarkMode;
    private Color _seedColor = Color.OrangeRed;

    private DynamicSchemeVariant _style = DynamicSchemeVariant.Vibrant;

    /// <summary>
    ///     Initializes the theme service and applies a default theme.
    /// </summary>
    public ThemeService()
    {
        InitializeTheme();
    }

    public Color SeedColor
    {
        get => _seedColor;
        set
        {
            _seedColor = value;
            InitializeTheme();
        }
    }

    public DynamicSchemeVariant Style
    {
        get => _style;
        set
        {
            _style = value;
            InitializeTheme();
        }
    }

    public bool IsDarkMode
    {
        get => _isDarkMode;
        set
        {
            _isDarkMode = value;
            InitializeTheme();
        }
    }

    public BColorScheme? CurrentColorScheme { get; private set; }

    public event Action OnThemeChanged;

    public void InitializeTheme()
    {
        var seedColor = ColorUtility.ToArgb(_seedColor);
        var scheme = DynamicSchemeMap.GetDynamicScheme(Hct.FromInt(seedColor), IsDarkMode, 0.7, Style);
        CurrentColorScheme = new BColorScheme(scheme);
        OnThemeChanged?.Invoke();
    }
}


==========================================
FILE: Theming\ThemingConstants.cs
==========================================
Last Modified: 12/05/2024 13:22:28
Size: 995 bytes
------------------------------------------

namespace Bdziam.UI.Theming;

public class ThemingConstants
{
    public const int SurfaceLevelsCount = 5;
    public const int LightSurfaceLevelMultiplier = 8;
    public const int DarkSurfaceLevelMultiplier = 10;

    public static readonly Dictionary<string, string> Motions = new()
    {
        ["easing-emphasized"] = "cubic-bezier(0.2, 0, 0, 1)",
        ["easing-emphasized-accelerate"] = "cubic-bezier(0.3, 0, 0.8, 0.15)",
        ["easing-emphasized-decelerate"] = "cubic-bezier(0.05, 0.7, 0.1, 1)",
        ["easing-legacy"] = "cubic-bezier(0.4, 0, 0.2, 1)",
        ["easing-legacy-accelerate"] = "cubic-bezier(0.4, 0, 1, 1)",
        ["easing-legacy-decelerate"] = "cubic-bezier(0, 0, 0.2, 1)",
        ["easing-linear"] = "cubic-bezier(0, 0, 1, 1)",
        ["easing-standard"] = "cubic-bezier(0.2, 0, 0, 1)",
        ["easing-standard-accelerate"] = "cubic-bezier(0.3, 0, 1, 1)",
        ["easing-standard-decelerate"] = "cubic-bezier(0, 0, 0, 1)"
    };
}


==========================================
FILE: Utilities\CaseUtility.cs
==========================================
Last Modified: 12/05/2024 13:22:40
Size: 897 bytes
------------------------------------------

namespace Bdziam.UI.Utilities;

public class CaseUtility
{
    public static string PascalToKebab(ReadOnlySpan<char> pascalCase)
    {
        if (pascalCase.Length == 0) return string.Empty;

        Span<char> kebabCase = stackalloc char[pascalCase.Length + pascalCase.Length / 2];
        var kebabCaseIndex = 0;
        kebabCase[kebabCaseIndex++] = char.ToLower(pascalCase[0]);

        for (var i = 1; i < pascalCase.Length; i++)
        {
            var currentChar = pascalCase[i];

            if (char.IsUpper(currentChar))
            {
                kebabCase[kebabCaseIndex++] = '-';
                kebabCase[kebabCaseIndex++] = char.ToLower(currentChar);
            }
            else
            {
                kebabCase[kebabCaseIndex++] = currentChar;
            }
        }

        return new string(kebabCase[..kebabCaseIndex]);
    }
}


==========================================
FILE: Utilities\ColorUtility.cs
==========================================
Last Modified: 12/06/2024 16:28:49
Size: 9903 bytes
------------------------------------------

using System.Drawing;
using Bdziam.UI.Model.Enums;

namespace Bdziam.UI.Utilities;

public static class ColorUtility
{
    public static uint ToArgb(Color color)
    {
        return (uint)((color.A << 24) | (color.R << 16) | (color.G << 8) | color.B);
    }

    public const string DisabledOpacity = "0.38";

    /// <summary>
    ///     Converts an ARGB integer to a Color.
    /// </summary>
    public static Color ColorFromArgb(uint argb)
    {
        var a = (byte)((argb >> 24) & 0xFF);
        var r = (byte)((argb >> 16) & 0xFF);
        var g = (byte)((argb >> 8) & 0xFF);
        var b = (byte)(argb & 0xFF);
        return Color.FromArgb(a, r, g, b);
    }

    public static string GetColorVariable(MaterialColor materialColor)
    {
        return $"var(--md-sys-color-{CaseUtility.PascalToKebab(materialColor.ToString())})";
    }

    public static string GetSurfaceColorVariable(int elevation)
    {
        return GetSurfaceContainerColorVariable(elevation);
    }

    public static MaterialColor GetContainerVariant(MaterialColor materialColor)
    {
        if (!Enum.TryParse<MaterialColor>($"{materialColor.ToString()}Container", out var result))
            return MaterialColor.Surface;

        return result;
    }

    public static string GetContainerColorVariable(MaterialColor materialColor)
    {
        if (materialColor.ToString().Contains("Container"))
            return GetColorVariable(materialColor);

        return GetColorVariable(GetContainerVariant(materialColor));
    }

    public static string GetSurfaceContainerColorVariable(int elevation = 0)
    {
        if (elevation > 5)
            elevation = 5;
        if (elevation == 0)
            return GetColorVariable(MaterialColor.SurfaceContainerLowest);

        return elevation switch
        {
            4 => GetColorVariable(MaterialColor.SurfaceContainerHighest),
            3 => GetColorVariable(MaterialColor.SurfaceContainerHigh),
            2 => GetColorVariable(MaterialColor.SurfaceContainer),
            1 => GetColorVariable(MaterialColor.SurfaceContainerLow),
            _ => GetColorVariable(MaterialColor.SurfaceContainerLowest)
        };
    }

    public static string GetTextColorVariable(MaterialColor materialColor)
    {
        return GetColorVariable(GetTextColor(materialColor));
    }

    public static MaterialColor GetTextColor(MaterialColor materialColor)
    {
        switch (materialColor)
        {
            // Palette key colors
            case MaterialColor.PrimaryPaletteKeyColor:
                return MaterialColor.OnPrimary;

            case MaterialColor.SecondaryPaletteKeyColor:
                return MaterialColor.OnSecondary;

            case MaterialColor.TertiaryPaletteKeyColor:
                return MaterialColor.OnTertiary;

            case MaterialColor.NeutralPaletteKeyColor:
                return MaterialColor.InverseOnSurface;

            case MaterialColor.NeutralVariantPaletteKeyColor:
                return MaterialColor.InverseOnSurface;

            // Background, surface, and container colors
            case MaterialColor.Background:
                return MaterialColor.OnBackground;

            case MaterialColor.OnBackground:
                return MaterialColor.Background;

            case MaterialColor.Surface:
            case MaterialColor.SurfaceDim:
            case MaterialColor.SurfaceBright:
            case MaterialColor.SurfaceContainerLowest:
            case MaterialColor.SurfaceContainerLow:
            case MaterialColor.SurfaceContainer:
            case MaterialColor.SurfaceContainerHigh:
            case MaterialColor.SurfaceContainerHighest:
            case MaterialColor.SurfaceTint:
                return MaterialColor.OnSurface;

            case MaterialColor.OnSurface:
                return MaterialColor.Surface;

            case MaterialColor.SurfaceVariant:
                return MaterialColor.OnSurfaceVariant;

            case MaterialColor.OnSurfaceVariant:
                return MaterialColor.SurfaceVariant;

            case MaterialColor.InverseSurface:
                return MaterialColor.InverseOnSurface;

            case MaterialColor.InverseOnSurface:
                return MaterialColor.InverseSurface;

            // Outline, shadow, and tint colors
            case MaterialColor.Outline:
            case MaterialColor.OutlineVariant:
            case MaterialColor.Shadow:
            case MaterialColor.Scrim:
                return MaterialColor.OnPrimary;

            // Primary colors
            case MaterialColor.Primary:
                return MaterialColor.OnPrimary;

            case MaterialColor.OnPrimary:
                return MaterialColor.Primary;

            case MaterialColor.PrimaryContainer:
                return MaterialColor.OnPrimaryContainer;

            case MaterialColor.OnPrimaryContainer:
                return MaterialColor.PrimaryContainer;

            case MaterialColor.InversePrimary:
                return MaterialColor.Primary;

            // Secondary colors
            case MaterialColor.Secondary:
                return MaterialColor.OnSecondary;

            case MaterialColor.OnSecondary:
                return MaterialColor.Secondary;

            case MaterialColor.SecondaryContainer:
                return MaterialColor.OnSecondaryContainer;

            case MaterialColor.OnSecondaryContainer:
                return MaterialColor.SecondaryContainer;

            // Tertiary colors
            case MaterialColor.Tertiary:
                return MaterialColor.OnTertiary;

            case MaterialColor.OnTertiary:
                return MaterialColor.Tertiary;

            case MaterialColor.TertiaryContainer:
                return MaterialColor.OnTertiaryContainer;

            case MaterialColor.OnTertiaryContainer:
                return MaterialColor.TertiaryContainer;

            // Error colors
            case MaterialColor.Error:
                return MaterialColor.OnError;

            case MaterialColor.OnError:
                return MaterialColor.Error;

            case MaterialColor.ErrorContainer:
                return MaterialColor.OnErrorContainer;

            case MaterialColor.OnErrorContainer:
                return MaterialColor.ErrorContainer;

            // Warning colors
            case MaterialColor.Warning:
                return MaterialColor.OnWarning;

            case MaterialColor.OnWarning:
                return MaterialColor.Warning;

            case MaterialColor.WarningContainer:
                return MaterialColor.OnWarningContainer;

            case MaterialColor.OnWarningContainer:
                return MaterialColor.WarningContainer;

            // Info colors
            case MaterialColor.Info:
                return MaterialColor.OnInfo;

            case MaterialColor.OnInfo:
                return MaterialColor.Info;

            case MaterialColor.InfoContainer:
                return MaterialColor.OnInfoContainer;

            case MaterialColor.OnInfoContainer:
                return MaterialColor.InfoContainer;

            // Success colors
            case MaterialColor.Success:
                return MaterialColor.OnSuccess;

            case MaterialColor.OnSuccess:
                return MaterialColor.Success;

            case MaterialColor.SuccessContainer:
                return MaterialColor.OnSuccessContainer;

            case MaterialColor.OnSuccessContainer:
                return MaterialColor.SuccessContainer;

            // Fixed colors
            case MaterialColor.PrimaryFixed:
                return MaterialColor.OnPrimaryFixed;

            case MaterialColor.PrimaryFixedDim:
                return MaterialColor.OnPrimaryFixedVariant;

            case MaterialColor.OnPrimaryFixed:
                return MaterialColor.PrimaryFixed;

            case MaterialColor.OnPrimaryFixedVariant:
                return MaterialColor.PrimaryFixedDim;

            case MaterialColor.SecondaryFixed:
                return MaterialColor.OnSecondaryFixed;

            case MaterialColor.SecondaryFixedDim:
                return MaterialColor.OnSecondaryFixedVariant;

            case MaterialColor.OnSecondaryFixed:
                return MaterialColor.SecondaryFixed;

            case MaterialColor.OnSecondaryFixedVariant:
                return MaterialColor.SecondaryFixedDim;

            case MaterialColor.TertiaryFixed:
                return MaterialColor.OnTertiaryFixed;

            case MaterialColor.TertiaryFixedDim:
                return MaterialColor.OnTertiaryFixedVariant;

            case MaterialColor.OnTertiaryFixed:
                return MaterialColor.TertiaryFixed;

            case MaterialColor.OnTertiaryFixedVariant:
                return MaterialColor.TertiaryFixedDim;

            // Controls and text
            case MaterialColor.ControlActivated:
            case MaterialColor.ControlNormal:
            case MaterialColor.ControlHighlight:
                return MaterialColor.OnPrimary;

            case MaterialColor.TextPrimaryInverse:
                return MaterialColor.Background;

            case MaterialColor.TextSecondaryAndTertiaryInverse:
            case MaterialColor.TextPrimaryInverseDisableOnly:
            case MaterialColor.TextSecondaryAndTertiaryInverseDisabled:
            case MaterialColor.TextHintInverse:
                return MaterialColor.OnBackground;

            default:
                throw new ArgumentOutOfRangeException(nameof(materialColor), materialColor, null);
        }
    }
}


==========================================
FILE: Utilities\CssClassBuilder.cs
==========================================
Last Modified: 12/05/2024 13:22:35
Size: 1677 bytes
------------------------------------------

namespace Bdziam.UI.Utilities;

public class CssClassBuilder
{
    private readonly List<string> _classes = new();

    /// <summary>
    ///     Initializes a new instance of the <see cref="CssClassBuilder" /> class.
    /// </summary>
    /// <param name="initialClass">An optional initial CSS class.</param>
    public CssClassBuilder(string initialClass = null)
    {
        if (!string.IsNullOrWhiteSpace(initialClass)) _classes.Add(initialClass);
    }

    /// <summary>
    ///     Adds a CSS class to the builder.
    /// </summary>
    /// <param name="className">The CSS class to add.</param>
    /// <returns>The updated <see cref="CssClassBuilder" /> instance.</returns>
    public CssClassBuilder AddClass(string className)
    {
        if (!string.IsNullOrWhiteSpace(className)) _classes.Add(className);
        return this;
    }

    /// <summary>
    ///     Adds a CSS class to the builder based on a condition.
    /// </summary>
    /// <param name="className">The CSS class to add.</param>
    /// <param name="condition">A boolean indicating whether to add the class.</param>
    /// <returns>The updated <see cref="CssClassBuilder" /> instance.</returns>
    public CssClassBuilder AddClass(string className, bool condition)
    {
        if (condition && !string.IsNullOrWhiteSpace(className)) _classes.Add(className);
        return this;
    }

    /// <summary>
    ///     Builds the final CSS class string.
    /// </summary>
    /// <returns>A string containing all the CSS classes separated by spaces.</returns>
    public string Build()
    {
        return string.Join(" ", _classes);
    }
}


==========================================
FILE: Utilities\CssStyleBuilder.cs
==========================================
Last Modified: 12/05/2024 13:22:29
Size: 3463 bytes
------------------------------------------

namespace Bdziam.UI.Utilities;

public class CssStyleBuilder
{
    private readonly List<string> _styles = new();

    /// <summary>
    ///     Adds a CSS style to the builder.
    /// </summary>
    /// <param name="property">The CSS property name.</param>
    /// <param name="value">The CSS property value.</param>
    /// <returns>The updated <see cref="CssStyleBuilder" /> instance.</returns>
    public CssStyleBuilder AddStyle(string property, string value)
    {
        if (!string.IsNullOrWhiteSpace(property) && !string.IsNullOrWhiteSpace(value))
            _styles.Add($"{property}: {value};");

        return this;
    }


    /// <summary>
    ///     Adds a CSS style to the builder.
    /// </summary>
    /// <param name="property">The CSS property name.</param>
    /// <param name="value">The CSS property value.</param>
    /// <returns>The updated <see cref="CssStyleBuilder" /> instance.</returns>
    public CssStyleBuilder AddStyle(string property, Func<string> style)
    {
        if (!string.IsNullOrWhiteSpace(property) && !string.IsNullOrWhiteSpace(style?.Invoke()))
            _styles.Add($"{property}: {style?.Invoke()};");

        return this;
    }

    /// <summary>
    ///     Adds a CSS style to the builder.
    /// </summary>
    /// <param name="property">The CSS property name.</param>
    /// <param name="value">The CSS property value.</param>
    /// <returns>The updated <see cref="CssStyleBuilder" /> instance.</returns>
    public CssStyleBuilder AddStyle(string property, Func<string, Task<string>> style)
    {
        Task.Run(async () =>
        {
            var finalString = "";
            if (!string.IsNullOrWhiteSpace(property) && !string.IsNullOrWhiteSpace(await style?.Invoke(finalString)!))
                _styles.Add($"{property}: {finalString};");
        });
        return this;
    }


    /// <summary>
    ///     Adds a CSS style to the builder.
    /// </summary>
    /// <param name="property">The CSS property name.</param>
    /// <param name="value">The CSS property value.</param>
    /// <returns>The updated <see cref="CssStyleBuilder" /> instance.</returns>
    public CssStyleBuilder AddStyle(string style, bool condition = true)
    {
        if (!string.IsNullOrWhiteSpace(style) && condition)
            _styles.Add($"{(style.EndsWith(";") ? style : $"{style};")}");

        return this;
    }

    /// <summary>
    ///     Adds a CSS style to the builder based on a condition.
    /// </summary>
    /// <param name="property">The CSS property name.</param>
    /// <param name="value">The CSS property value.</param>
    /// <param name="condition">A boolean indicating whether to add the style.</param>
    /// <returns>The updated <see cref="CssStyleBuilder" /> instance.</returns>
    public CssStyleBuilder AddStyle(string property, string value, bool condition)
    {
        if (condition && !string.IsNullOrWhiteSpace(property) && !string.IsNullOrWhiteSpace(value))
            _styles.Add($"{property}: {value};");

        return this;
    }

    /// <summary>
    ///     Builds the final CSS style string.
    /// </summary>
    /// <returns>A string containing all the CSS styles concatenated.</returns>
    public string Build(string? baseStyle = null)
    {
        return string.Concat(string.Join(" ", _styles), baseStyle != null ? $"{baseStyle}" : "");
    }
}


==========================================
FILE: Utilities\MotionUtility.cs
==========================================
Last Modified: 12/05/2024 13:54:55
Size: 1627 bytes
------------------------------------------

using System.Globalization;
using Bdziam.UI.Model.Enums;

namespace Bdziam.UI.Utilities;

public static class MotionUtility
{
    public static string ConstructTransition(Motion motion = Motion.EasingEmphasized, double durationSecs = 0.2,
        params string[] properties)
    {
        // Convert the enum value to a kebab-case string
        var motionVariantKebabCase = CaseUtility.PascalToKebab(motion.ToString());
        var propertiesList = new List<string>();
        if (properties.Length == 0)
            propertiesList.Add(
                $"all {durationSecs.ToString(CultureInfo.InvariantCulture)}s var(--md-sys-motion-{motionVariantKebabCase})");

        foreach (var property in properties)
            propertiesList.Add(
                $"{property} {durationSecs.ToString(CultureInfo.InvariantCulture)}s var(--md-sys-motion-{motionVariantKebabCase})");

        return string.Join(", ", propertiesList);
    }
    
    public static string ConstructTransition(params string[] properties)
    {
        // Convert the enum value to a kebab-case string
        var motionVariantKebabCase = CaseUtility.PascalToKebab(Motion.EasingEmphasized.ToString());
        var propertiesList = new List<string>();
        if (properties.Length == 0)
            propertiesList.Add(
                $"all 0.2s var(--md-sys-motion-{motionVariantKebabCase})");

        foreach (var property in properties)
            propertiesList.Add(
                $"{property} 0.2s var(--md-sys-motion-{motionVariantKebabCase})");

        return string.Join(", ", propertiesList);
    }
}


==========================================
FILE: Utilities\SizeUtility.cs
==========================================
Last Modified: 12/05/2024 13:23:44
Size: 1277 bytes
------------------------------------------

using Bdziam.UI.Model.Enums;
using Bdziam.UI.Utilities;

namespace Bdziam.UI.Model.Utility;

public static class SizeUtility
{
    public static string GetIconSize(Size size)
    {
        return size switch
        {
            Size.Small => "1.25rem",
            Size.Medium => "1.5rem",
            Size.Large => "2rem",
            Size.ExtraLarge => "3rem",
            _ => "1.5rem"
        };
    }

    public static string GetPadding(Size size)
    {
        return size switch
        {
            Size.Small => "0.5rem",
            Size.Medium => "1rem",
            Size.Large => "2rem",
            Size.ExtraLarge => "3rem",
            Size.None => "0rem",
            _ => "0rem"
        };
    }

    public static Dictionary<string, object> GetIconSizeAttributes(Size iconSize = Size.Medium,
        string additionalStyle = "")
    {
        return new Dictionary<string, object>
        {
            ["style"] = new CssStyleBuilder()
                .AddStyle("width", GetIconSize(iconSize))
                .AddStyle("height", GetIconSize(iconSize))
                .Build(additionalStyle),
            ["width"] = GetIconSize(iconSize),
            ["height"] = GetIconSize(iconSize)
        };
    }
}


==========================================
FILE: Utilities\StyleUtility.cs
==========================================
Last Modified: 12/05/2024 13:22:48
Size: 3073 bytes
------------------------------------------

using Bdziam.UI.Model.Enums;
using Color = System.Drawing.Color;
using Size = Bdziam.UI.Model.Enums.Size;

namespace Bdziam.UI.Utilities;

public static class StyleUtility
{
    public static string GetRadiusClass(BorderRadius radius)
    {
        return radius switch
        {
            BorderRadius.None => "rounded-none",
            BorderRadius.Small => "rounded-sm",
            BorderRadius.Medium => "rounded-md",
            BorderRadius.Large => "rounded-lg",
            BorderRadius.Pill => "rounded-full",
            _ => "rounded-md"
        };
    }


    public static string GetRadiusStyle(BorderRadius radius)
    {
        return radius switch
        {
            BorderRadius.None => "0px",
            BorderRadius.Small => "0.250rem",
            BorderRadius.Medium => "0.5rem",
            BorderRadius.Large => "0.75rem",
            BorderRadius.Pill => "9999px",
            _ => "0.5rem"
        };
    }

    /// <summary>
    ///     Converts a System.Drawing.Color to an inline CSS color string.
    /// </summary>
    public static string ToCssColor(Color color)
    {
        return $"rgb({color.R}, {color.G}, {color.B})";
    }

    public static string GetPadding(Size size)
    {
        return size switch
        {
            Size.Small => "0.25rem 0.5rem", // Small: 1px vertical, 2px horizontal
            Size.Medium => "0.5rem 1rem", // Medium: 2px vertical, 4px horizontal
            Size.Large => "0.75rem 1.5rem", // Large: 3px vertical, 6px horizontal
            Size.ExtraLarge => "1rem 2rem", // ExtraLarge: 4px vertical, 8px horizontal
            _ => "0.5rem 1rem" // Default: Medium
        };
    }

    public static string GetHorizontalPadding(Size size)
    {
        return size switch
        {
            Size.Small => "0.5rem", // Small: 1px vertical, 2px horizontal
            Size.Medium => "0.75rem", // Medium: 2px vertical, 4px horizontal
            Size.Large => "1rem", // Large: 3px vertical, 6px horizontal
            Size.ExtraLarge => "1.5rem",
            Size.None => "0rem", // ExtraLarge: 4px vertical, 8px horizontal
            _ => "0.5rem" // Default: Medium
        };
    }

    public static string GetVerticalPadding(Size size)
    {
        return size switch
        {
            Size.Small => "0.375rem", // Small: 1px vertical, 2px horizontal
            Size.Medium => "0.5rem", // Medium: 2px vertical, 4px horizontal
            Size.Large => "1rem", // Large: 3px vertical, 6px horizontal
            Size.ExtraLarge => "1.5rem",
            Size.None => "0rem", // ExtraLarge: 4px vertical, 8px horizontal
            _ => "0.5rem" // Default: Medium
        };
    }

    public static string GetStaticHeight(Size size)
    {
        return size switch
        {
            Size.Small => "36px",
            Size.Medium => "48px",
            Size.Large => "64px",
            Size.ExtraLarge => "80px",
            _ => "48px" // Default to Medium
        };
    }
}


==========================================
FILE: _Imports.razor
==========================================
Last Modified: 12/05/2024 13:22:27
Size: 63 bytes
------------------------------------------

@using Microsoft.AspNetCore.Components.Web
@using Blazicons
